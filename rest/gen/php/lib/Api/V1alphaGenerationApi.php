<?php
/**
 * V1alphaGenerationApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stability.ai REST API
 *
 * Welcome to the Stability.ai REST API developer preview!  Please note, this is an alpha version of our new REST API, and is subject to change according to your feedback.  Feedback during this test is crucial for us to understand what the pain points are and how we can improve it going forward.  Changes will be communicated here, as well as on our online REST API documentation, which can be found at: https://api.stability.ai/docs  Your DreamStudio API key will be required for authentication. You can learn more about API keys here: https://platform.stability.ai/docs/getting-started/authentication  If you encounter any issues, please let us know in the #API discord channel: https://discord.gg/stablediffusion
 *
 * The version of the OpenAPI document: 0.1
 * Contact: info@stability.ai
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * V1alphaGenerationApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class V1alphaGenerationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v1alphaGenerationImageToImage
     *
     * image-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\ImageToImageOptions $options options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1alphaGenerationImageToImage($engine_id, $accept, $init_image, $options, $organization = null)
    {
        $this->v1alphaGenerationImageToImageWithHttpInfo($engine_id, $accept, $init_image, $options, $organization);
    }

    /**
     * Operation v1alphaGenerationImageToImageWithHttpInfo
     *
     * image-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\ImageToImageOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1alphaGenerationImageToImageWithHttpInfo($engine_id, $accept, $init_image, $options, $organization = null)
    {
        $request = $this->v1alphaGenerationImageToImageRequest($engine_id, $accept, $init_image, $options, $organization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1alphaGenerationImageToImageAsync
     *
     * image-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\ImageToImageOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationImageToImageAsync($engine_id, $accept, $init_image, $options, $organization = null)
    {
        return $this->v1alphaGenerationImageToImageAsyncWithHttpInfo($engine_id, $accept, $init_image, $options, $organization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1alphaGenerationImageToImageAsyncWithHttpInfo
     *
     * image-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\ImageToImageOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationImageToImageAsyncWithHttpInfo($engine_id, $accept, $init_image, $options, $organization = null)
    {
        $returnType = '';
        $request = $this->v1alphaGenerationImageToImageRequest($engine_id, $accept, $init_image, $options, $organization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1alphaGenerationImageToImage'
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\ImageToImageOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1alphaGenerationImageToImageRequest($engine_id, $accept, $init_image, $options, $organization = null)
    {
        // verify the required parameter 'engine_id' is set
        if ($engine_id === null || (is_array($engine_id) && count($engine_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_id when calling v1alphaGenerationImageToImage'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling v1alphaGenerationImageToImage'
            );
        }
        // verify the required parameter 'init_image' is set
        if ($init_image === null || (is_array($init_image) && count($init_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $init_image when calling v1alphaGenerationImageToImage'
            );
        }
        // verify the required parameter 'options' is set
        if ($options === null || (is_array($options) && count($options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $options when calling v1alphaGenerationImageToImage'
            );
        }

        $resourcePath = '/v1alpha/generation/{engine_id}/image-to-image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($organization !== null) {
            $headerParams['Organization'] = ObjectSerializer::toHeaderValue($organization);
        }

        // path params
        if ($engine_id !== null) {
            $resourcePath = str_replace(
                '{' . 'engine_id' . '}',
                ObjectSerializer::toPathValue($engine_id),
                $resourcePath
            );
        }

        // form params
        if ($init_image !== null) {
            $multipart = true;
            $formParams['init_image'] = [];
            $paramFiles = is_array($init_image) ? $init_image : [$init_image];
            foreach ($paramFiles as $paramFile) {
                $formParams['init_image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($options !== null) {
            $formParams['options'] = ObjectSerializer::toFormValue($options);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/vnd.goa.error']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/vnd.goa.error'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1alphaGenerationMasking
     *
     * image-to-image/masking
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\MaskingOptions $options options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     * @param  \SplFileObject $mask_image Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1alphaGenerationMasking($engine_id, $accept, $init_image, $options, $organization = null, $mask_image = null)
    {
        $this->v1alphaGenerationMaskingWithHttpInfo($engine_id, $accept, $init_image, $options, $organization, $mask_image);
    }

    /**
     * Operation v1alphaGenerationMaskingWithHttpInfo
     *
     * image-to-image/masking
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\MaskingOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     * @param  \SplFileObject $mask_image Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1alphaGenerationMaskingWithHttpInfo($engine_id, $accept, $init_image, $options, $organization = null, $mask_image = null)
    {
        $request = $this->v1alphaGenerationMaskingRequest($engine_id, $accept, $init_image, $options, $organization, $mask_image);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1alphaGenerationMaskingAsync
     *
     * image-to-image/masking
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\MaskingOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     * @param  \SplFileObject $mask_image Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationMaskingAsync($engine_id, $accept, $init_image, $options, $organization = null, $mask_image = null)
    {
        return $this->v1alphaGenerationMaskingAsyncWithHttpInfo($engine_id, $accept, $init_image, $options, $organization, $mask_image)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1alphaGenerationMaskingAsyncWithHttpInfo
     *
     * image-to-image/masking
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\MaskingOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     * @param  \SplFileObject $mask_image Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationMaskingAsyncWithHttpInfo($engine_id, $accept, $init_image, $options, $organization = null, $mask_image = null)
    {
        $returnType = '';
        $request = $this->v1alphaGenerationMaskingRequest($engine_id, $accept, $init_image, $options, $organization, $mask_image);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1alphaGenerationMasking'
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \SplFileObject $init_image Initial image to use for the image-to-image generation (required)
     * @param  \OpenAPI\Client\Model\MaskingOptions $options (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     * @param  \SplFileObject $mask_image Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1alphaGenerationMaskingRequest($engine_id, $accept, $init_image, $options, $organization = null, $mask_image = null)
    {
        // verify the required parameter 'engine_id' is set
        if ($engine_id === null || (is_array($engine_id) && count($engine_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_id when calling v1alphaGenerationMasking'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling v1alphaGenerationMasking'
            );
        }
        // verify the required parameter 'init_image' is set
        if ($init_image === null || (is_array($init_image) && count($init_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $init_image when calling v1alphaGenerationMasking'
            );
        }
        // verify the required parameter 'options' is set
        if ($options === null || (is_array($options) && count($options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $options when calling v1alphaGenerationMasking'
            );
        }

        $resourcePath = '/v1alpha/generation/{engine_id}/image-to-image/masking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($organization !== null) {
            $headerParams['Organization'] = ObjectSerializer::toHeaderValue($organization);
        }

        // path params
        if ($engine_id !== null) {
            $resourcePath = str_replace(
                '{' . 'engine_id' . '}',
                ObjectSerializer::toPathValue($engine_id),
                $resourcePath
            );
        }

        // form params
        if ($init_image !== null) {
            $multipart = true;
            $formParams['init_image'] = [];
            $paramFiles = is_array($init_image) ? $init_image : [$init_image];
            foreach ($paramFiles as $paramFile) {
                $formParams['init_image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($mask_image !== null) {
            $multipart = true;
            $formParams['mask_image'] = [];
            $paramFiles = is_array($mask_image) ? $mask_image : [$mask_image];
            foreach ($paramFiles as $paramFile) {
                $formParams['mask_image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($options !== null) {
            $formParams['options'] = ObjectSerializer::toFormValue($options);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/vnd.goa.error']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/vnd.goa.error'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1alphaGenerationTextToImage
     *
     * text-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \OpenAPI\Client\Model\TextToImageRequestBody $text_to_image_request_body text_to_image_request_body (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1alphaGenerationTextToImage($engine_id, $accept, $text_to_image_request_body, $organization = null)
    {
        $this->v1alphaGenerationTextToImageWithHttpInfo($engine_id, $accept, $text_to_image_request_body, $organization);
    }

    /**
     * Operation v1alphaGenerationTextToImageWithHttpInfo
     *
     * text-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \OpenAPI\Client\Model\TextToImageRequestBody $text_to_image_request_body (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1alphaGenerationTextToImageWithHttpInfo($engine_id, $accept, $text_to_image_request_body, $organization = null)
    {
        $request = $this->v1alphaGenerationTextToImageRequest($engine_id, $accept, $text_to_image_request_body, $organization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1alphaGenerationTextToImageAsync
     *
     * text-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \OpenAPI\Client\Model\TextToImageRequestBody $text_to_image_request_body (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationTextToImageAsync($engine_id, $accept, $text_to_image_request_body, $organization = null)
    {
        return $this->v1alphaGenerationTextToImageAsyncWithHttpInfo($engine_id, $accept, $text_to_image_request_body, $organization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1alphaGenerationTextToImageAsyncWithHttpInfo
     *
     * text-to-image
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \OpenAPI\Client\Model\TextToImageRequestBody $text_to_image_request_body (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1alphaGenerationTextToImageAsyncWithHttpInfo($engine_id, $accept, $text_to_image_request_body, $organization = null)
    {
        $returnType = '';
        $request = $this->v1alphaGenerationTextToImageRequest($engine_id, $accept, $text_to_image_request_body, $organization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1alphaGenerationTextToImage'
     *
     * @param  string $engine_id   (required)
     * @param  string $accept   (required)
     * @param  \OpenAPI\Client\Model\TextToImageRequestBody $text_to_image_request_body (required)
     * @param  string $organization Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1alphaGenerationTextToImageRequest($engine_id, $accept, $text_to_image_request_body, $organization = null)
    {
        // verify the required parameter 'engine_id' is set
        if ($engine_id === null || (is_array($engine_id) && count($engine_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engine_id when calling v1alphaGenerationTextToImage'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling v1alphaGenerationTextToImage'
            );
        }
        // verify the required parameter 'text_to_image_request_body' is set
        if ($text_to_image_request_body === null || (is_array($text_to_image_request_body) && count($text_to_image_request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text_to_image_request_body when calling v1alphaGenerationTextToImage'
            );
        }

        $resourcePath = '/v1alpha/generation/{engine_id}/text-to-image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($organization !== null) {
            $headerParams['Organization'] = ObjectSerializer::toHeaderValue($organization);
        }

        // path params
        if ($engine_id !== null) {
            $resourcePath = str_replace(
                '{' . 'engine_id' . '}',
                ObjectSerializer::toPathValue($engine_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/vnd.goa.error']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/vnd.goa.error'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($text_to_image_request_body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($text_to_image_request_body));
            } else {
                $httpBody = $text_to_image_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
