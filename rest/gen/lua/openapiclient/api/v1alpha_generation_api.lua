--[[
  Stability.ai REST API

  Welcome to the Stability.ai REST API developer preview!  Please note, this is an alpha version of our new REST API, and is subject to change according to your feedback.  Feedback during this test is crucial for us to understand what the pain points are and how we can improve it going forward.  Changes will be communicated here, as well as on our online REST API documentation, which can be found at: https://api.stability.ai/docs  Your DreamStudio API key will be required for authentication. You can learn more about API keys here: https://platform.stability.ai/docs/getting-started/authentication  If you encounter any issues, please let us know in the #API discord channel: https://discord.gg/stablediffusion 

  The version of the OpenAPI document: 0.1
  Contact: info@stability.ai
  Generated by: https://openapi-generator.tech
]]

--package openapiclient

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local openapiclient_error = require "openapiclient.model.error"
local openapiclient_image_to_image_options = require "openapiclient.model.image_to_image_options"
local openapiclient_masking_options = require "openapiclient.model.masking_options"
local openapiclient_text_to_image_request_body = require "openapiclient.model.text_to_image_request_body"

local v1alpha_generation_api = {}
local v1alpha_generation_api_mt = {
	__name = "v1alpha_generation_api";
	__index = v1alpha_generation_api;
}

local function new_v1alpha_generation_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "https://api.stability.ai";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, v1alpha_generation_api_mt)
end

function v1alpha_generation_api:v1alpha_generation_image_to_image(engine_id, accept, init_image, options, organization)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/v1alpha/generation/%s/image-to-image",
			self.basePath, engine_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/vnd.goa.error" }
	req.headers:upsert("content-type", "application/vnd.goa.error")

	if accept then
		req.headers:upsert("Accept", accept)
	end
	if organization then
		req.headers:upsert("Organization", organization)
	end
	req:set_body(http_util.dict_to_query({
		["init_image"] = init_image;
		["options"] = options;
	}))
	-- api key in headers 'Authorization'
	if self.api_key['Authorization'] then
		req.headers:upsert("api_key_header_Authorization", self.api_key['Authorization'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function v1alpha_generation_api:v1alpha_generation_masking(engine_id, accept, init_image, options, organization, mask_image)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/v1alpha/generation/%s/image-to-image/masking",
			self.basePath, engine_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/vnd.goa.error" }
	req.headers:upsert("content-type", "application/vnd.goa.error")

	if accept then
		req.headers:upsert("Accept", accept)
	end
	if organization then
		req.headers:upsert("Organization", organization)
	end
	req:set_body(http_util.dict_to_query({
		["init_image"] = init_image;
		["mask_image"] = mask_image;
		["options"] = options;
	}))
	-- api key in headers 'Authorization'
	if self.api_key['Authorization'] then
		req.headers:upsert("api_key_header_Authorization", self.api_key['Authorization'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function v1alpha_generation_api:v1alpha_generation_text_to_image(engine_id, accept, text_to_image_request_body, organization)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/v1alpha/generation/%s/text-to-image",
			self.basePath, engine_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/vnd.goa.error" }
	req.headers:upsert("content-type", "application/vnd.goa.error")

	if accept then
		req.headers:upsert("Accept", accept)
	end
	if organization then
		req.headers:upsert("Organization", organization)
	end
	req:set_body(dkjson.encode(text_to_image_request_body))

	-- api key in headers 'Authorization'
	if self.api_key['Authorization'] then
		req.headers:upsert("api_key_header_Authorization", self.api_key['Authorization'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_v1alpha_generation_api;
}
