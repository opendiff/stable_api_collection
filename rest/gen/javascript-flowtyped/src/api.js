// @flow
/* eslint-disable no-use-before-define */
/**
 * Stability.ai REST API
 * Welcome to the Stability.ai REST API developer preview!  Please note, this is an alpha version of our new REST API, and is subject to change according to your feedback.  Feedback during this test is crucial for us to understand what the pain points are and how we can improve it going forward.  Changes will be communicated here, as well as on our online REST API documentation, which can be found at: https://api.stability.ai/docs  Your DreamStudio API key will be required for authentication. You can learn more about API keys here: https://platform.stability.ai/docs/getting-started/authentication  If you encounter any issues, please let us know in the #API discord channel: https://discord.gg/stablediffusion 
 *
 * The version of the OpenAPI document: 0.1
 * Contact: info@stability.ai
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.stability.ai".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AccountResponseBody = {
    /**
     * The user\'s email
     * @type {string}
     * @memberof AccountResponseBody
     */
    email: string;
    /**
     * The user\'s ID
     * @type {string}
     * @memberof AccountResponseBody
     */
    id: string;
    /**
     * The user\'s organizations
     * @type {Array<OrganizationMembership>}
     * @memberof AccountResponseBody
     */
    organizations: Array<OrganizationMembership>;
    /**
     * The user\'s profile picture
     * @type {string}
     * @memberof AccountResponseBody
     */
    profile_picture?: string;
}

/**
 * 
 * @export
 */
export type BalanceResponseBody = {
    /**
     * The balance of the account/organization associated with the API key
     * @type {number}
     * @memberof BalanceResponseBody
     */
    credits: number;
}


            export type EngineTypeEnum = 'AUDIO' | 'CLASSIFICATION' | 'PICTURE' | 'STORAGE' | 'TEXT' | 'VIDEO';
/**
 * 
 * @export
 */
export type Engine = {
    /**
     * 
     * @type {string}
     * @memberof Engine
     */
    description: string;
    /**
     * Unique identifier for the engine
     * @type {string}
     * @memberof Engine
     */
    id: string;
    /**
     * Name of the engine
     * @type {string}
     * @memberof Engine
     */
    name: string;
    /**
     * The type of content this engine produces
     * @type {string}
     * @memberof Engine
     */
    type: EngineTypeEnum;
}

/**
 * 
 * @export
 */
export type Error = {
    /**
     * Is the error a server-side fault?
     * @type {boolean}
     * @memberof Error
     */
    fault: boolean;
    /**
     * ID is a unique identifier for this particular occurrence of the problem.
     * @type {string}
     * @memberof Error
     */
    id: string;
    /**
     * Message is a human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof Error
     */
    message: string;
    /**
     * Name is the name of this class of errors.
     * @type {string}
     * @memberof Error
     */
    name: string;
    /**
     * Is the error temporary?
     * @type {boolean}
     * @memberof Error
     */
    temporary: boolean;
    /**
     * Is the error a timeout?
     * @type {boolean}
     * @memberof Error
     */
    timeout: boolean;
}

/**
 * 
 * @export
 */
export type ListEnginesResponseBody = {
    /**
     * The engines available to your user/organization
     * @type {Array<Engine>}
     * @memberof ListEnginesResponseBody
     */
    engines: Array<Engine>;
}

/**
 * 
 * @export
 */
export type OrganizationMembership = {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembership
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationMembership
     */
    is_default: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembership
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembership
     */
    role: string;
}

/**
 * Text prompt for image generation
 * @export
 */
export type TextPrompt = {
    /**
     * 
     * @type {string}
     * @memberof TextPrompt
     */
    text: string;
    /**
     * Weight of the prompt (use negative numbers for negative prompts)
     * @type {number}
     * @memberof TextPrompt
     */
    weight?: number;
}


            export type TextToImageRequestBodyClipGuidancePresetEnum = 'FAST_BLUE' | 'FAST_GREEN' | 'NONE' | 'SIMPLE' | 'SLOW' | 'SLOWER' | 'SLOWEST';

            export type TextToImageRequestBodySamplerEnum = 'DDIM' | 'DDPM' | 'K_DPMPP_2M' | 'K_DPMPP_2S_ANCESTRAL' | 'K_DPM_2' | 'K_DPM_2_ANCESTRAL' | 'K_EULER' | 'K_EULER_ANCESTRAL' | 'K_HEUN' | 'K_LMS';
/**
 * 
 * @export
 */
export type TextToImageRequestBody = {
    /**
     * How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt)
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    cfg_scale?: number;
    /**
     * 
     * @type {string}
     * @memberof TextToImageRequestBody
     */
    clip_guidance_preset?: TextToImageRequestBodyClipGuidancePresetEnum;
    /**
     * Height of the image (note: `height * width` must be <= 1 Megapixel)
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    height?: number;
    /**
     * Which sampler to use for the diffusion process. If this value is omitted we\'ll automatically select an appropriate sampler for you.
     * @type {string}
     * @memberof TextToImageRequestBody
     */
    sampler?: TextToImageRequestBodySamplerEnum;
    /**
     * Number of images to generate
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    samples?: number;
    /**
     * Random noise seed (omit this option or use `0` for a random seed)
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    seed?: number;
    /**
     * Number of diffusion steps to run
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    steps?: number;
    /**
     * 
     * @type {Array<TextPrompt>}
     * @memberof TextToImageRequestBody
     */
    text_prompts: Array<TextPrompt>;
    /**
     * Width of the image (note: `height * width` must be <= 1 Megapixel)
     * @type {number}
     * @memberof TextToImageRequestBody
     */
    width?: number;
}



/**
 * V1alphaEnginesApi - fetch parameter creator
 * @export
 */
export const V1alphaEnginesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all engines available to your organization/user
         * @summary list
         * @throws {RequiredError}
         */
        v1alphaEnginesListEngines(organization?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1alpha/engines/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organization !== undefined && organization !== null) {
                localVarHeaderParameter['Organization'] = ((organization:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type V1alphaEnginesApiType = { 
    v1alphaEnginesListEngines(organization?: string, options?: RequestOptions): Promise<ListEnginesResponseBody>,
}

/**
 * V1alphaEnginesApi - factory function to inject configuration 
 * @export
 */
export const V1alphaEnginesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): V1alphaEnginesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * List all engines available to your organization/user
         * @summary list
         * @throws {RequiredError}
         */
        v1alphaEnginesListEngines(organization?: string, options?: RequestOptions = {}): Promise<ListEnginesResponseBody> {
            const localVarFetchArgs = V1alphaEnginesApiFetchParamCreator(configuration).v1alphaEnginesListEngines(organization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * V1alphaGenerationApi - fetch parameter creator
 * @export
 */
export const V1alphaGenerationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate big fancy pictures from small fancy pictures
         * @summary image-to-image
         * @throws {RequiredError}
         */
        v1alphaGenerationImageToImage(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: ImageToImageOptions, organization?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'engineId' is not null or undefined
            if (engineId === null || engineId === undefined) {
                throw new RequiredError('engineId','Required parameter engineId was null or undefined when calling v1alphaGenerationImageToImage.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling v1alphaGenerationImageToImage.');
            }
            // verify required parameter 'initImage' is not null or undefined
            if (initImage === null || initImage === undefined) {
                throw new RequiredError('initImage','Required parameter initImage was null or undefined when calling v1alphaGenerationImageToImage.');
            }
            // verify required parameter 'options' is not null or undefined
            if (options === null || options === undefined) {
                throw new RequiredError('options','Required parameter options was null or undefined when calling v1alphaGenerationImageToImage.');
            }
            const localVarPath = `/v1alpha/generation/{engine_id}/image-to-image`
                .replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (organization !== undefined && organization !== null) {
                localVarHeaderParameter['Organization'] = ((organization:any):string);
            }

            if (initImage !== undefined) {
                localVarFormParams.set('init_image', ((initImage:any):string));
            }

            if (options !== undefined) {
                localVarFormParams.set('options', ((options:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paint fancy things into fancy pictures
         * @summary image-to-image/masking
         * @throws {RequiredError}
         */
        v1alphaGenerationMasking(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: MaskingOptions, organization?: string, maskImage?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'engineId' is not null or undefined
            if (engineId === null || engineId === undefined) {
                throw new RequiredError('engineId','Required parameter engineId was null or undefined when calling v1alphaGenerationMasking.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling v1alphaGenerationMasking.');
            }
            // verify required parameter 'initImage' is not null or undefined
            if (initImage === null || initImage === undefined) {
                throw new RequiredError('initImage','Required parameter initImage was null or undefined when calling v1alphaGenerationMasking.');
            }
            // verify required parameter 'options' is not null or undefined
            if (options === null || options === undefined) {
                throw new RequiredError('options','Required parameter options was null or undefined when calling v1alphaGenerationMasking.');
            }
            const localVarPath = `/v1alpha/generation/{engine_id}/image-to-image/masking`
                .replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (organization !== undefined && organization !== null) {
                localVarHeaderParameter['Organization'] = ((organization:any):string);
            }

            if (initImage !== undefined) {
                localVarFormParams.set('init_image', ((initImage:any):string));
            }

            if (maskImage !== undefined) {
                localVarFormParams.set('mask_image', ((maskImage:any):string));
            }

            if (options !== undefined) {
                localVarFormParams.set('options', ((options:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate an image from text
         * @summary text-to-image
         * @throws {RequiredError}
         */
        v1alphaGenerationTextToImage(engineId: string, accept: 'image/png' | 'application/json', textToImageRequestBody: TextToImageRequestBody, organization?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'engineId' is not null or undefined
            if (engineId === null || engineId === undefined) {
                throw new RequiredError('engineId','Required parameter engineId was null or undefined when calling v1alphaGenerationTextToImage.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling v1alphaGenerationTextToImage.');
            }
            // verify required parameter 'textToImageRequestBody' is not null or undefined
            if (textToImageRequestBody === null || textToImageRequestBody === undefined) {
                throw new RequiredError('textToImageRequestBody','Required parameter textToImageRequestBody was null or undefined when calling v1alphaGenerationTextToImage.');
            }
            const localVarPath = `/v1alpha/generation/{engine_id}/text-to-image`
                .replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (organization !== undefined && organization !== null) {
                localVarHeaderParameter['Organization'] = ((organization:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof textToImageRequestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(textToImageRequestBody != null ? textToImageRequestBody : {}) : (((textToImageRequestBody:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type V1alphaGenerationApiType = { 
    v1alphaGenerationImageToImage(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: ImageToImageOptions, organization?: string, options?: RequestOptions): Promise<Response>,

    v1alphaGenerationMasking(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: MaskingOptions, organization?: string, maskImage?: any, options?: RequestOptions): Promise<Response>,

    v1alphaGenerationTextToImage(engineId: string, accept: 'image/png' | 'application/json', textToImageRequestBody: TextToImageRequestBody, organization?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * V1alphaGenerationApi - factory function to inject configuration 
 * @export
 */
export const V1alphaGenerationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): V1alphaGenerationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Generate big fancy pictures from small fancy pictures
         * @summary image-to-image
         * @throws {RequiredError}
         */
        v1alphaGenerationImageToImage(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: ImageToImageOptions, organization?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = V1alphaGenerationApiFetchParamCreator(configuration).v1alphaGenerationImageToImage(engineId, accept, initImage, options, organization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Paint fancy things into fancy pictures
         * @summary image-to-image/masking
         * @throws {RequiredError}
         */
        v1alphaGenerationMasking(engineId: string, accept: 'image/png' | 'application/json', initImage: any, options: MaskingOptions, organization?: string, maskImage?: any, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = V1alphaGenerationApiFetchParamCreator(configuration).v1alphaGenerationMasking(engineId, accept, initImage, options, organization, maskImage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Generate an image from text
         * @summary text-to-image
         * @throws {RequiredError}
         */
        v1alphaGenerationTextToImage(engineId: string, accept: 'image/png' | 'application/json', textToImageRequestBody: TextToImageRequestBody, organization?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = V1alphaGenerationApiFetchParamCreator(configuration).v1alphaGenerationTextToImage(engineId, accept, textToImageRequestBody, organization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * V1alphaUserApi - fetch parameter creator
 * @export
 */
export const V1alphaUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about the account associated with the provided API key
         * @summary account
         * @throws {RequiredError}
         */
        v1alphaUserAccount(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1alpha/user/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the credit balance of the account/organization associated with the API key
         * @summary balance
         * @throws {RequiredError}
         */
        v1alphaUserBalance(organization?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1alpha/user/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication api_key_header_Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organization !== undefined && organization !== null) {
                localVarHeaderParameter['Organization'] = ((organization:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type V1alphaUserApiType = { 
    v1alphaUserAccount(options?: RequestOptions): Promise<AccountResponseBody>,

    v1alphaUserBalance(organization?: string, options?: RequestOptions): Promise<BalanceResponseBody>,
}

/**
 * V1alphaUserApi - factory function to inject configuration 
 * @export
 */
export const V1alphaUserApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): V1alphaUserApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get information about the account associated with the provided API key
         * @summary account
         * @throws {RequiredError}
         */
        v1alphaUserAccount(options?: RequestOptions = {}): Promise<AccountResponseBody> {
            const localVarFetchArgs = V1alphaUserApiFetchParamCreator(configuration).v1alphaUserAccount(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the credit balance of the account/organization associated with the API key
         * @summary balance
         * @throws {RequiredError}
         */
        v1alphaUserBalance(organization?: string, options?: RequestOptions = {}): Promise<BalanceResponseBody> {
            const localVarFetchArgs = V1alphaUserApiFetchParamCreator(configuration).v1alphaUserBalance(organization, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    V1alphaEnginesApi: V1alphaEnginesApiType,

    V1alphaGenerationApi: V1alphaGenerationApiType,

    V1alphaUserApi: V1alphaUserApiType,
 }
