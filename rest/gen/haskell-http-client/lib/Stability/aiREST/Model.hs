{-
   Stability.ai REST API

   Welcome to the Stability.ai REST API developer preview!  Please note, this is an alpha version of our new REST API, and is subject to change according to your feedback.  Feedback during this test is crucial for us to understand what the pain points are and how we can improve it going forward.  Changes will be communicated here, as well as on our online REST API documentation, which can be found at: https://api.stability.ai/docs  Your DreamStudio API key will be required for authentication. You can learn more about API keys here: https://platform.stability.ai/docs/getting-started/authentication  If you encounter any issues, please let us know in the #API discord channel: https://discord.gg/stablediffusion 

   OpenAPI Version: 3.0.3
   Stability.ai REST API API version: 0.1
   Contact: info@stability.ai
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Stability.aiREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Stability.aiREST.Model where

import Stability.aiREST.Core
import Stability.aiREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** EngineId
newtype EngineId = EngineId { unEngineId :: Text } deriving (P.Eq, P.Show)

-- ** InitImage
newtype InitImage = InitImage { unInitImage :: FilePath } deriving (P.Eq, P.Show)

-- ** MaskImage
newtype MaskImage = MaskImage { unMaskImage :: FilePath } deriving (P.Eq, P.Show)

-- ** Options
newtype Options = Options { unOptions :: ImageToImageOptions } deriving (P.Eq, P.Show)

-- ** OptionsMaskingOptions
newtype OptionsMaskingOptions = OptionsMaskingOptions { unOptionsMaskingOptions :: MaskingOptions } deriving (P.Eq, P.Show)

-- ** Organization
newtype Organization = Organization { unOrganization :: Text } deriving (P.Eq, P.Show)

-- ** ParamAccept
newtype ParamAccept = ParamAccept { unParamAccept :: E'ContentType } deriving (P.Eq, P.Show)

-- * Models


-- ** AccountResponseBody
-- | AccountResponseBody
data AccountResponseBody = AccountResponseBody
  { accountResponseBodyEmail :: !(Text) -- ^ /Required/ "email" - The user&#39;s email
  , accountResponseBodyId :: !(Text) -- ^ /Required/ "id" - The user&#39;s ID
  , accountResponseBodyOrganizations :: !([OrganizationMembership]) -- ^ /Required/ "organizations" - The user&#39;s organizations
  , accountResponseBodyProfilePicture :: !(Maybe Text) -- ^ "profile_picture" - The user&#39;s profile picture
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountResponseBody
instance A.FromJSON AccountResponseBody where
  parseJSON = A.withObject "AccountResponseBody" $ \o ->
    AccountResponseBody
      <$> (o .:  "email")
      <*> (o .:  "id")
      <*> (o .:  "organizations")
      <*> (o .:? "profile_picture")

-- | ToJSON AccountResponseBody
instance A.ToJSON AccountResponseBody where
  toJSON AccountResponseBody {..} =
   _omitNulls
      [ "email" .= accountResponseBodyEmail
      , "id" .= accountResponseBodyId
      , "organizations" .= accountResponseBodyOrganizations
      , "profile_picture" .= accountResponseBodyProfilePicture
      ]


-- | Construct a value of type 'AccountResponseBody' (by applying it's required fields, if any)
mkAccountResponseBody
  :: Text -- ^ 'accountResponseBodyEmail': The user's email
  -> Text -- ^ 'accountResponseBodyId': The user's ID
  -> [OrganizationMembership] -- ^ 'accountResponseBodyOrganizations': The user's organizations
  -> AccountResponseBody
mkAccountResponseBody accountResponseBodyEmail accountResponseBodyId accountResponseBodyOrganizations =
  AccountResponseBody
  { accountResponseBodyEmail
  , accountResponseBodyId
  , accountResponseBodyOrganizations
  , accountResponseBodyProfilePicture = Nothing
  }

-- ** BalanceResponseBody
-- | BalanceResponseBody
data BalanceResponseBody = BalanceResponseBody
  { balanceResponseBodyCredits :: !(Double) -- ^ /Required/ "credits" - The balance of the account/organization associated with the API key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceResponseBody
instance A.FromJSON BalanceResponseBody where
  parseJSON = A.withObject "BalanceResponseBody" $ \o ->
    BalanceResponseBody
      <$> (o .:  "credits")

-- | ToJSON BalanceResponseBody
instance A.ToJSON BalanceResponseBody where
  toJSON BalanceResponseBody {..} =
   _omitNulls
      [ "credits" .= balanceResponseBodyCredits
      ]


-- | Construct a value of type 'BalanceResponseBody' (by applying it's required fields, if any)
mkBalanceResponseBody
  :: Double -- ^ 'balanceResponseBodyCredits': The balance of the account/organization associated with the API key
  -> BalanceResponseBody
mkBalanceResponseBody balanceResponseBodyCredits =
  BalanceResponseBody
  { balanceResponseBodyCredits
  }

-- ** Engine
-- | Engine
data Engine = Engine
  { engineDescription :: !(Text) -- ^ /Required/ "description"
  , engineId :: !(Text) -- ^ /Required/ "id" - Unique identifier for the engine
  , engineName :: !(Text) -- ^ /Required/ "name" - Name of the engine
  , engineType :: !(E'Type) -- ^ /Required/ "type" - The type of content this engine produces
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Engine
instance A.FromJSON Engine where
  parseJSON = A.withObject "Engine" $ \o ->
    Engine
      <$> (o .:  "description")
      <*> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "type")

-- | ToJSON Engine
instance A.ToJSON Engine where
  toJSON Engine {..} =
   _omitNulls
      [ "description" .= engineDescription
      , "id" .= engineId
      , "name" .= engineName
      , "type" .= engineType
      ]


-- | Construct a value of type 'Engine' (by applying it's required fields, if any)
mkEngine
  :: Text -- ^ 'engineDescription' 
  -> Text -- ^ 'engineId': Unique identifier for the engine
  -> Text -- ^ 'engineName': Name of the engine
  -> E'Type -- ^ 'engineType': The type of content this engine produces
  -> Engine
mkEngine engineDescription engineId engineName engineType =
  Engine
  { engineDescription
  , engineId
  , engineName
  , engineType
  }

-- ** Error
-- | Error
data Error = Error
  { errorFault :: !(Bool) -- ^ /Required/ "fault" - Is the error a server-side fault?
  , errorId :: !(Text) -- ^ /Required/ "id" - ID is a unique identifier for this particular occurrence of the problem.
  , errorMessage :: !(Text) -- ^ /Required/ "message" - Message is a human-readable explanation specific to this occurrence of the problem.
  , errorName :: !(Text) -- ^ /Required/ "name" - Name is the name of this class of errors.
  , errorTemporary :: !(Bool) -- ^ /Required/ "temporary" - Is the error temporary?
  , errorTimeout :: !(Bool) -- ^ /Required/ "timeout" - Is the error a timeout?
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "fault")
      <*> (o .:  "id")
      <*> (o .:  "message")
      <*> (o .:  "name")
      <*> (o .:  "temporary")
      <*> (o .:  "timeout")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "fault" .= errorFault
      , "id" .= errorId
      , "message" .= errorMessage
      , "name" .= errorName
      , "temporary" .= errorTemporary
      , "timeout" .= errorTimeout
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Bool -- ^ 'errorFault': Is the error a server-side fault?
  -> Text -- ^ 'errorId': ID is a unique identifier for this particular occurrence of the problem.
  -> Text -- ^ 'errorMessage': Message is a human-readable explanation specific to this occurrence of the problem.
  -> Text -- ^ 'errorName': Name is the name of this class of errors.
  -> Bool -- ^ 'errorTemporary': Is the error temporary?
  -> Bool -- ^ 'errorTimeout': Is the error a timeout?
  -> Error
mkError errorFault errorId errorMessage errorName errorTemporary errorTimeout =
  Error
  { errorFault
  , errorId
  , errorMessage
  , errorName
  , errorTemporary
  , errorTimeout
  }

-- ** ListEnginesResponseBody
-- | ListEnginesResponseBody
data ListEnginesResponseBody = ListEnginesResponseBody
  { listEnginesResponseBodyEngines :: !([Engine]) -- ^ /Required/ "engines" - The engines available to your user/organization
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListEnginesResponseBody
instance A.FromJSON ListEnginesResponseBody where
  parseJSON = A.withObject "ListEnginesResponseBody" $ \o ->
    ListEnginesResponseBody
      <$> (o .:  "engines")

-- | ToJSON ListEnginesResponseBody
instance A.ToJSON ListEnginesResponseBody where
  toJSON ListEnginesResponseBody {..} =
   _omitNulls
      [ "engines" .= listEnginesResponseBodyEngines
      ]


-- | Construct a value of type 'ListEnginesResponseBody' (by applying it's required fields, if any)
mkListEnginesResponseBody
  :: [Engine] -- ^ 'listEnginesResponseBodyEngines': The engines available to your user/organization
  -> ListEnginesResponseBody
mkListEnginesResponseBody listEnginesResponseBodyEngines =
  ListEnginesResponseBody
  { listEnginesResponseBodyEngines
  }

-- ** OrganizationMembership
-- | OrganizationMembership
data OrganizationMembership = OrganizationMembership
  { organizationMembershipId :: !(Text) -- ^ /Required/ "id"
  , organizationMembershipIsDefault :: !(Bool) -- ^ /Required/ "is_default"
  , organizationMembershipName :: !(Text) -- ^ /Required/ "name"
  , organizationMembershipRole :: !(Text) -- ^ /Required/ "role"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationMembership
instance A.FromJSON OrganizationMembership where
  parseJSON = A.withObject "OrganizationMembership" $ \o ->
    OrganizationMembership
      <$> (o .:  "id")
      <*> (o .:  "is_default")
      <*> (o .:  "name")
      <*> (o .:  "role")

-- | ToJSON OrganizationMembership
instance A.ToJSON OrganizationMembership where
  toJSON OrganizationMembership {..} =
   _omitNulls
      [ "id" .= organizationMembershipId
      , "is_default" .= organizationMembershipIsDefault
      , "name" .= organizationMembershipName
      , "role" .= organizationMembershipRole
      ]


-- | Construct a value of type 'OrganizationMembership' (by applying it's required fields, if any)
mkOrganizationMembership
  :: Text -- ^ 'organizationMembershipId' 
  -> Bool -- ^ 'organizationMembershipIsDefault' 
  -> Text -- ^ 'organizationMembershipName' 
  -> Text -- ^ 'organizationMembershipRole' 
  -> OrganizationMembership
mkOrganizationMembership organizationMembershipId organizationMembershipIsDefault organizationMembershipName organizationMembershipRole =
  OrganizationMembership
  { organizationMembershipId
  , organizationMembershipIsDefault
  , organizationMembershipName
  , organizationMembershipRole
  }

-- ** TextPrompt
-- | TextPrompt
-- Text prompt for image generation
data TextPrompt = TextPrompt
  { textPromptText :: !(Text) -- ^ /Required/ "text"
  , textPromptWeight :: !(Maybe Float) -- ^ "weight" - Weight of the prompt (use negative numbers for negative prompts)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TextPrompt
instance A.FromJSON TextPrompt where
  parseJSON = A.withObject "TextPrompt" $ \o ->
    TextPrompt
      <$> (o .:  "text")
      <*> (o .:? "weight")

-- | ToJSON TextPrompt
instance A.ToJSON TextPrompt where
  toJSON TextPrompt {..} =
   _omitNulls
      [ "text" .= textPromptText
      , "weight" .= textPromptWeight
      ]


-- | Construct a value of type 'TextPrompt' (by applying it's required fields, if any)
mkTextPrompt
  :: Text -- ^ 'textPromptText' 
  -> TextPrompt
mkTextPrompt textPromptText =
  TextPrompt
  { textPromptText
  , textPromptWeight = Nothing
  }

-- ** TextToImageRequestBody
-- | TextToImageRequestBody
data TextToImageRequestBody = TextToImageRequestBody
  { textToImageRequestBodyCfgScale :: !(Maybe Double) -- ^ "cfg_scale" - How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt)
  , textToImageRequestBodyClipGuidancePreset :: !(Maybe E'ClipGuidancePreset) -- ^ "clip_guidance_preset"
  , textToImageRequestBodyHeight :: !(Maybe Int) -- ^ "height" - Height of the image (note: &#x60;height * width&#x60; must be &lt;&#x3D; 1 Megapixel)
  , textToImageRequestBodySampler :: !(Maybe E'Sampler) -- ^ "sampler" - Which sampler to use for the diffusion process. If this value is omitted we&#39;ll automatically select an appropriate sampler for you.
  , textToImageRequestBodySamples :: !(Maybe Int) -- ^ "samples" - Number of images to generate
  , textToImageRequestBodySeed :: !(Maybe Int) -- ^ "seed" - Random noise seed (omit this option or use &#x60;0&#x60; for a random seed)
  , textToImageRequestBodySteps :: !(Maybe Int) -- ^ "steps" - Number of diffusion steps to run
  , textToImageRequestBodyTextPrompts :: !([TextPrompt]) -- ^ /Required/ "text_prompts"
  , textToImageRequestBodyWidth :: !(Maybe Int) -- ^ "width" - Width of the image (note: &#x60;height * width&#x60; must be &lt;&#x3D; 1 Megapixel)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TextToImageRequestBody
instance A.FromJSON TextToImageRequestBody where
  parseJSON = A.withObject "TextToImageRequestBody" $ \o ->
    TextToImageRequestBody
      <$> (o .:? "cfg_scale")
      <*> (o .:? "clip_guidance_preset")
      <*> (o .:? "height")
      <*> (o .:? "sampler")
      <*> (o .:? "samples")
      <*> (o .:? "seed")
      <*> (o .:? "steps")
      <*> (o .:  "text_prompts")
      <*> (o .:? "width")

-- | ToJSON TextToImageRequestBody
instance A.ToJSON TextToImageRequestBody where
  toJSON TextToImageRequestBody {..} =
   _omitNulls
      [ "cfg_scale" .= textToImageRequestBodyCfgScale
      , "clip_guidance_preset" .= textToImageRequestBodyClipGuidancePreset
      , "height" .= textToImageRequestBodyHeight
      , "sampler" .= textToImageRequestBodySampler
      , "samples" .= textToImageRequestBodySamples
      , "seed" .= textToImageRequestBodySeed
      , "steps" .= textToImageRequestBodySteps
      , "text_prompts" .= textToImageRequestBodyTextPrompts
      , "width" .= textToImageRequestBodyWidth
      ]


-- | Construct a value of type 'TextToImageRequestBody' (by applying it's required fields, if any)
mkTextToImageRequestBody
  :: [TextPrompt] -- ^ 'textToImageRequestBodyTextPrompts' 
  -> TextToImageRequestBody
mkTextToImageRequestBody textToImageRequestBodyTextPrompts =
  TextToImageRequestBody
  { textToImageRequestBodyCfgScale = Nothing
  , textToImageRequestBodyClipGuidancePreset = Nothing
  , textToImageRequestBodyHeight = Nothing
  , textToImageRequestBodySampler = Nothing
  , textToImageRequestBodySamples = Nothing
  , textToImageRequestBodySeed = Nothing
  , textToImageRequestBodySteps = Nothing
  , textToImageRequestBodyTextPrompts
  , textToImageRequestBodyWidth = Nothing
  }


-- * Enums


-- ** E'ClipGuidancePreset

-- | Enum of 'Text'
data E'ClipGuidancePreset
  = E'ClipGuidancePreset'FAST_BLUE -- ^ @"FAST_BLUE"@
  | E'ClipGuidancePreset'FAST_GREEN -- ^ @"FAST_GREEN"@
  | E'ClipGuidancePreset'NONE -- ^ @"NONE"@
  | E'ClipGuidancePreset'SIMPLE -- ^ @"SIMPLE"@
  | E'ClipGuidancePreset'SLOW -- ^ @"SLOW"@
  | E'ClipGuidancePreset'SLOWER -- ^ @"SLOWER"@
  | E'ClipGuidancePreset'SLOWEST -- ^ @"SLOWEST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ClipGuidancePreset where toJSON = A.toJSON . fromE'ClipGuidancePreset
instance A.FromJSON E'ClipGuidancePreset where parseJSON o = P.either P.fail (pure . P.id) . toE'ClipGuidancePreset =<< A.parseJSON o
instance WH.ToHttpApiData E'ClipGuidancePreset where toQueryParam = WH.toQueryParam . fromE'ClipGuidancePreset
instance WH.FromHttpApiData E'ClipGuidancePreset where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ClipGuidancePreset
instance MimeRender MimeMultipartFormData E'ClipGuidancePreset where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ClipGuidancePreset' enum
fromE'ClipGuidancePreset :: E'ClipGuidancePreset -> Text
fromE'ClipGuidancePreset = \case
  E'ClipGuidancePreset'FAST_BLUE -> "FAST_BLUE"
  E'ClipGuidancePreset'FAST_GREEN -> "FAST_GREEN"
  E'ClipGuidancePreset'NONE -> "NONE"
  E'ClipGuidancePreset'SIMPLE -> "SIMPLE"
  E'ClipGuidancePreset'SLOW -> "SLOW"
  E'ClipGuidancePreset'SLOWER -> "SLOWER"
  E'ClipGuidancePreset'SLOWEST -> "SLOWEST"

-- | parse 'E'ClipGuidancePreset' enum
toE'ClipGuidancePreset :: Text -> P.Either String E'ClipGuidancePreset
toE'ClipGuidancePreset = \case
  "FAST_BLUE" -> P.Right E'ClipGuidancePreset'FAST_BLUE
  "FAST_GREEN" -> P.Right E'ClipGuidancePreset'FAST_GREEN
  "NONE" -> P.Right E'ClipGuidancePreset'NONE
  "SIMPLE" -> P.Right E'ClipGuidancePreset'SIMPLE
  "SLOW" -> P.Right E'ClipGuidancePreset'SLOW
  "SLOWER" -> P.Right E'ClipGuidancePreset'SLOWER
  "SLOWEST" -> P.Right E'ClipGuidancePreset'SLOWEST
  s -> P.Left $ "toE'ClipGuidancePreset: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Image_png -- ^ @"image/png"@
  | E'ContentType'Application_json -- ^ @"application/json"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Image_png -> "image/png"
  E'ContentType'Application_json -> "application/json"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "image/png" -> P.Right E'ContentType'Image_png
  "application/json" -> P.Right E'ContentType'Application_json
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'FinishReason

-- | Enum of 'Text' .
-- The result of the generation process. - `SUCCESS` indicates success - `ERROR` indicates an error - `CONTENT_FILTERED` indicates the result affected by the content filter and may be blurred.
data E'FinishReason
  = E'FinishReason'SUCCESS -- ^ @"SUCCESS"@
  | E'FinishReason'ERROR -- ^ @"ERROR"@
  | E'FinishReason'CONTENT_FILTERED -- ^ @"CONTENT_FILTERED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason where toJSON = A.toJSON . fromE'FinishReason
instance A.FromJSON E'FinishReason where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason where toQueryParam = WH.toQueryParam . fromE'FinishReason
instance WH.FromHttpApiData E'FinishReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason
instance MimeRender MimeMultipartFormData E'FinishReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason' enum
fromE'FinishReason :: E'FinishReason -> Text
fromE'FinishReason = \case
  E'FinishReason'SUCCESS -> "SUCCESS"
  E'FinishReason'ERROR -> "ERROR"
  E'FinishReason'CONTENT_FILTERED -> "CONTENT_FILTERED"

-- | parse 'E'FinishReason' enum
toE'FinishReason :: Text -> P.Either String E'FinishReason
toE'FinishReason = \case
  "SUCCESS" -> P.Right E'FinishReason'SUCCESS
  "ERROR" -> P.Right E'FinishReason'ERROR
  "CONTENT_FILTERED" -> P.Right E'FinishReason'CONTENT_FILTERED
  s -> P.Left $ "toE'FinishReason: enum parse failure: " P.++ P.show s


-- ** E'Sampler

-- | Enum of 'Text' .
-- Which sampler to use for the diffusion process. If this value is omitted we'll automatically select an appropriate sampler for you.
data E'Sampler
  = E'Sampler'DDIM -- ^ @"DDIM"@
  | E'Sampler'DDPM -- ^ @"DDPM"@
  | E'Sampler'K_DPMPP_2M -- ^ @"K_DPMPP_2M"@
  | E'Sampler'K_DPMPP_2S_ANCESTRAL -- ^ @"K_DPMPP_2S_ANCESTRAL"@
  | E'Sampler'K_DPM_2 -- ^ @"K_DPM_2"@
  | E'Sampler'K_DPM_2_ANCESTRAL -- ^ @"K_DPM_2_ANCESTRAL"@
  | E'Sampler'K_EULER -- ^ @"K_EULER"@
  | E'Sampler'K_EULER_ANCESTRAL -- ^ @"K_EULER_ANCESTRAL"@
  | E'Sampler'K_HEUN -- ^ @"K_HEUN"@
  | E'Sampler'K_LMS -- ^ @"K_LMS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sampler where toJSON = A.toJSON . fromE'Sampler
instance A.FromJSON E'Sampler where parseJSON o = P.either P.fail (pure . P.id) . toE'Sampler =<< A.parseJSON o
instance WH.ToHttpApiData E'Sampler where toQueryParam = WH.toQueryParam . fromE'Sampler
instance WH.FromHttpApiData E'Sampler where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sampler
instance MimeRender MimeMultipartFormData E'Sampler where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sampler' enum
fromE'Sampler :: E'Sampler -> Text
fromE'Sampler = \case
  E'Sampler'DDIM -> "DDIM"
  E'Sampler'DDPM -> "DDPM"
  E'Sampler'K_DPMPP_2M -> "K_DPMPP_2M"
  E'Sampler'K_DPMPP_2S_ANCESTRAL -> "K_DPMPP_2S_ANCESTRAL"
  E'Sampler'K_DPM_2 -> "K_DPM_2"
  E'Sampler'K_DPM_2_ANCESTRAL -> "K_DPM_2_ANCESTRAL"
  E'Sampler'K_EULER -> "K_EULER"
  E'Sampler'K_EULER_ANCESTRAL -> "K_EULER_ANCESTRAL"
  E'Sampler'K_HEUN -> "K_HEUN"
  E'Sampler'K_LMS -> "K_LMS"

-- | parse 'E'Sampler' enum
toE'Sampler :: Text -> P.Either String E'Sampler
toE'Sampler = \case
  "DDIM" -> P.Right E'Sampler'DDIM
  "DDPM" -> P.Right E'Sampler'DDPM
  "K_DPMPP_2M" -> P.Right E'Sampler'K_DPMPP_2M
  "K_DPMPP_2S_ANCESTRAL" -> P.Right E'Sampler'K_DPMPP_2S_ANCESTRAL
  "K_DPM_2" -> P.Right E'Sampler'K_DPM_2
  "K_DPM_2_ANCESTRAL" -> P.Right E'Sampler'K_DPM_2_ANCESTRAL
  "K_EULER" -> P.Right E'Sampler'K_EULER
  "K_EULER_ANCESTRAL" -> P.Right E'Sampler'K_EULER_ANCESTRAL
  "K_HEUN" -> P.Right E'Sampler'K_HEUN
  "K_LMS" -> P.Right E'Sampler'K_LMS
  s -> P.Left $ "toE'Sampler: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- The type of content this engine produces
data E'Type
  = E'Type'AUDIO -- ^ @"AUDIO"@
  | E'Type'CLASSIFICATION -- ^ @"CLASSIFICATION"@
  | E'Type'PICTURE -- ^ @"PICTURE"@
  | E'Type'STORAGE -- ^ @"STORAGE"@
  | E'Type'TEXT -- ^ @"TEXT"@
  | E'Type'VIDEO -- ^ @"VIDEO"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'AUDIO -> "AUDIO"
  E'Type'CLASSIFICATION -> "CLASSIFICATION"
  E'Type'PICTURE -> "PICTURE"
  E'Type'STORAGE -> "STORAGE"
  E'Type'TEXT -> "TEXT"
  E'Type'VIDEO -> "VIDEO"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "AUDIO" -> P.Right E'Type'AUDIO
  "CLASSIFICATION" -> P.Right E'Type'CLASSIFICATION
  "PICTURE" -> P.Right E'Type'PICTURE
  "STORAGE" -> P.Right E'Type'STORAGE
  "TEXT" -> P.Right E'Type'TEXT
  "VIDEO" -> P.Right E'Type'VIDEO
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKeyHeaderAuthorization
data AuthApiKeyApiKeyHeaderAuthorization =
  AuthApiKeyApiKeyHeaderAuthorization Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyHeaderAuthorization where
  applyAuthMethod _ a@(AuthApiKeyApiKeyHeaderAuthorization secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


