/*
Stability.ai REST API

Welcome to the Stability.ai REST API developer preview!  Please note, this is an alpha version of our new REST API, and is subject to change according to your feedback.  Feedback during this test is crucial for us to understand what the pain points are and how we can improve it going forward.  Changes will be communicated here, as well as on our online REST API documentation, which can be found at: https://api.stability.ai/docs  Your DreamStudio API key will be required for authentication. You can learn more about API keys here: https://platform.stability.ai/docs/getting-started/authentication  If you encounter any issues, please let us know in the #API discord channel: https://discord.gg/stablediffusion 

API version: 0.1
Contact: info@stability.ai
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// V1alphaGenerationApiService V1alphaGenerationApi service
type V1alphaGenerationApiService service

type ApiV1alphaGenerationImageToImageRequest struct {
	ctx context.Context
	ApiService *V1alphaGenerationApiService
	engineId string
	accept *string
	initImage **os.File
	options *ImageToImageOptions
	organization *string
}

//  
func (r ApiV1alphaGenerationImageToImageRequest) Accept(accept string) ApiV1alphaGenerationImageToImageRequest {
	r.accept = &accept
	return r
}

// Initial image to use for the image-to-image generation
func (r ApiV1alphaGenerationImageToImageRequest) InitImage(initImage *os.File) ApiV1alphaGenerationImageToImageRequest {
	r.initImage = &initImage
	return r
}

func (r ApiV1alphaGenerationImageToImageRequest) Options(options ImageToImageOptions) ApiV1alphaGenerationImageToImageRequest {
	r.options = &options
	return r
}

// Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used.
func (r ApiV1alphaGenerationImageToImageRequest) Organization(organization string) ApiV1alphaGenerationImageToImageRequest {
	r.organization = &organization
	return r
}

func (r ApiV1alphaGenerationImageToImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1alphaGenerationImageToImageExecute(r)
}

/*
V1alphaGenerationImageToImage image-to-image

Generate big fancy pictures from small fancy pictures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param engineId  
 @return ApiV1alphaGenerationImageToImageRequest
*/
func (a *V1alphaGenerationApiService) V1alphaGenerationImageToImage(ctx context.Context, engineId string) ApiV1alphaGenerationImageToImageRequest {
	return ApiV1alphaGenerationImageToImageRequest{
		ApiService: a,
		ctx: ctx,
		engineId: engineId,
	}
}

// Execute executes the request
func (a *V1alphaGenerationApiService) V1alphaGenerationImageToImageExecute(r ApiV1alphaGenerationImageToImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1alphaGenerationApiService.V1alphaGenerationImageToImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/generation/{engine_id}/image-to-image"
	localVarPath = strings.Replace(localVarPath, "{"+"engine_id"+"}", url.PathEscape(parameterToString(r.engineId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}
	if r.initImage == nil {
		return nil, reportError("initImage is required and must be specified")
	}
	if r.options == nil {
		return nil, reportError("options is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	if r.organization != nil {
		localVarHeaderParams["Organization"] = parameterToString(*r.organization, "")
	}
	var initImageLocalVarFormFileName string
	var initImageLocalVarFileName     string
	var initImageLocalVarFileBytes    []byte

	initImageLocalVarFormFileName = "init_image"

	initImageLocalVarFile := *r.initImage
	if initImageLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(initImageLocalVarFile)
		initImageLocalVarFileBytes = fbs
		initImageLocalVarFileName = initImageLocalVarFile.Name()
		initImageLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: initImageLocalVarFileBytes, fileName: initImageLocalVarFileName, formFileName: initImageLocalVarFormFileName})
	localVarFormParams.Add("options", parameterToString(*r.options, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1alphaGenerationMaskingRequest struct {
	ctx context.Context
	ApiService *V1alphaGenerationApiService
	engineId string
	accept *string
	initImage **os.File
	options *MaskingOptions
	organization *string
	maskImage **os.File
}

//  
func (r ApiV1alphaGenerationMaskingRequest) Accept(accept string) ApiV1alphaGenerationMaskingRequest {
	r.accept = &accept
	return r
}

// Initial image to use for the image-to-image generation
func (r ApiV1alphaGenerationMaskingRequest) InitImage(initImage *os.File) ApiV1alphaGenerationMaskingRequest {
	r.initImage = &initImage
	return r
}

func (r ApiV1alphaGenerationMaskingRequest) Options(options MaskingOptions) ApiV1alphaGenerationMaskingRequest {
	r.options = &options
	return r
}

// Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used.
func (r ApiV1alphaGenerationMaskingRequest) Organization(organization string) ApiV1alphaGenerationMaskingRequest {
	r.organization = &organization
	return r
}

// Optional mask image to use for masking. Must be the same dimensions as the &#x60;init_image&#x60;. Use the &#x60;mask_source&#x60; option to specify whether the white or black pixels should be inpainted. (Note: if you set &#x60;mask_source&#x60; to &#x60;INIT_IMAGE_ALPHA&#x60; you can omit the &#x60;mask_image&#x60; parameter completely.)
func (r ApiV1alphaGenerationMaskingRequest) MaskImage(maskImage *os.File) ApiV1alphaGenerationMaskingRequest {
	r.maskImage = &maskImage
	return r
}

func (r ApiV1alphaGenerationMaskingRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1alphaGenerationMaskingExecute(r)
}

/*
V1alphaGenerationMasking image-to-image/masking

Paint fancy things into fancy pictures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param engineId  
 @return ApiV1alphaGenerationMaskingRequest
*/
func (a *V1alphaGenerationApiService) V1alphaGenerationMasking(ctx context.Context, engineId string) ApiV1alphaGenerationMaskingRequest {
	return ApiV1alphaGenerationMaskingRequest{
		ApiService: a,
		ctx: ctx,
		engineId: engineId,
	}
}

// Execute executes the request
func (a *V1alphaGenerationApiService) V1alphaGenerationMaskingExecute(r ApiV1alphaGenerationMaskingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1alphaGenerationApiService.V1alphaGenerationMasking")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/generation/{engine_id}/image-to-image/masking"
	localVarPath = strings.Replace(localVarPath, "{"+"engine_id"+"}", url.PathEscape(parameterToString(r.engineId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}
	if r.initImage == nil {
		return nil, reportError("initImage is required and must be specified")
	}
	if r.options == nil {
		return nil, reportError("options is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	if r.organization != nil {
		localVarHeaderParams["Organization"] = parameterToString(*r.organization, "")
	}
	var initImageLocalVarFormFileName string
	var initImageLocalVarFileName     string
	var initImageLocalVarFileBytes    []byte

	initImageLocalVarFormFileName = "init_image"

	initImageLocalVarFile := *r.initImage
	if initImageLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(initImageLocalVarFile)
		initImageLocalVarFileBytes = fbs
		initImageLocalVarFileName = initImageLocalVarFile.Name()
		initImageLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: initImageLocalVarFileBytes, fileName: initImageLocalVarFileName, formFileName: initImageLocalVarFormFileName})
	var maskImageLocalVarFormFileName string
	var maskImageLocalVarFileName     string
	var maskImageLocalVarFileBytes    []byte

	maskImageLocalVarFormFileName = "mask_image"

	var maskImageLocalVarFile *os.File
	if r.maskImage != nil {
		maskImageLocalVarFile = *r.maskImage
	}
	if maskImageLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(maskImageLocalVarFile)
		maskImageLocalVarFileBytes = fbs
		maskImageLocalVarFileName = maskImageLocalVarFile.Name()
		maskImageLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: maskImageLocalVarFileBytes, fileName: maskImageLocalVarFileName, formFileName: maskImageLocalVarFormFileName})
	localVarFormParams.Add("options", parameterToString(*r.options, ""))
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1alphaGenerationTextToImageRequest struct {
	ctx context.Context
	ApiService *V1alphaGenerationApiService
	engineId string
	accept *string
	textToImageRequestBody *TextToImageRequestBody
	organization *string
}

//  
func (r ApiV1alphaGenerationTextToImageRequest) Accept(accept string) ApiV1alphaGenerationTextToImageRequest {
	r.accept = &accept
	return r
}

func (r ApiV1alphaGenerationTextToImageRequest) TextToImageRequestBody(textToImageRequestBody TextToImageRequestBody) ApiV1alphaGenerationTextToImageRequest {
	r.textToImageRequestBody = &textToImageRequestBody
	return r
}

// Optional: Allows for requests to be scoped to an organization other than the user&#39;s default.  If not provided, the user&#39;s default organization will be used.
func (r ApiV1alphaGenerationTextToImageRequest) Organization(organization string) ApiV1alphaGenerationTextToImageRequest {
	r.organization = &organization
	return r
}

func (r ApiV1alphaGenerationTextToImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1alphaGenerationTextToImageExecute(r)
}

/*
V1alphaGenerationTextToImage text-to-image

Generate an image from text

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param engineId  
 @return ApiV1alphaGenerationTextToImageRequest
*/
func (a *V1alphaGenerationApiService) V1alphaGenerationTextToImage(ctx context.Context, engineId string) ApiV1alphaGenerationTextToImageRequest {
	return ApiV1alphaGenerationTextToImageRequest{
		ApiService: a,
		ctx: ctx,
		engineId: engineId,
	}
}

// Execute executes the request
func (a *V1alphaGenerationApiService) V1alphaGenerationTextToImageExecute(r ApiV1alphaGenerationTextToImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1alphaGenerationApiService.V1alphaGenerationTextToImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1alpha/generation/{engine_id}/text-to-image"
	localVarPath = strings.Replace(localVarPath, "{"+"engine_id"+"}", url.PathEscape(parameterToString(r.engineId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}
	if r.textToImageRequestBody == nil {
		return nil, reportError("textToImageRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	if r.organization != nil {
		localVarHeaderParams["Organization"] = parameterToString(*r.organization, "")
	}
	// body params
	localVarPostBody = r.textToImageRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
