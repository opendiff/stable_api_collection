// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: generation.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Generation.pbobjc.h"
#import "Tensors.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AnswerMeta);
GPBObjCClassDeclaration(Artifact);
GPBObjCClassDeclaration(AssetParameters);
GPBObjCClassDeclaration(ClassifierCategory);
GPBObjCClassDeclaration(ClassifierConcept);
GPBObjCClassDeclaration(ClassifierParameters);
GPBObjCClassDeclaration(ConditionerParameters);
GPBObjCClassDeclaration(CutoutParameters);
GPBObjCClassDeclaration(GuidanceInstanceParameters);
GPBObjCClassDeclaration(GuidanceParameters);
GPBObjCClassDeclaration(GuidanceScheduleParameters);
GPBObjCClassDeclaration(ImageParameters);
GPBObjCClassDeclaration(Model);
GPBObjCClassDeclaration(OnStatus);
GPBObjCClassDeclaration(Prompt);
GPBObjCClassDeclaration(PromptParameters);
GPBObjCClassDeclaration(Request);
GPBObjCClassDeclaration(SamplerParameters);
GPBObjCClassDeclaration(ScheduleParameters);
GPBObjCClassDeclaration(Stage);
GPBObjCClassDeclaration(StepParameter);
GPBObjCClassDeclaration(Tensor);
GPBObjCClassDeclaration(Token);
GPBObjCClassDeclaration(Tokens);
GPBObjCClassDeclaration(TransformType);

#pragma mark - GenerationRoot

@implementation GenerationRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - GenerationRoot_FileDescriptor

static GPBFileDescriptor *GenerationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"gooseai"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum FinishReason

GPBEnumDescriptor *FinishReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Null\000Length\000Stop\000Error\000Filter\000";
    static const int32_t values[] = {
        FinishReason_Null,
        FinishReason_Length,
        FinishReason_Stop,
        FinishReason_Error,
        FinishReason_Filter,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FinishReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FinishReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FinishReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case FinishReason_Null:
    case FinishReason_Length:
    case FinishReason_Stop:
    case FinishReason_Error:
    case FinishReason_Filter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ArtifactType

GPBEnumDescriptor *ArtifactType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ArtifactNone\000ArtifactImage\000ArtifactVideo"
        "\000ArtifactText\000ArtifactTokens\000ArtifactEmb"
        "edding\000ArtifactClassifications\000ArtifactM"
        "ask\000ArtifactLatent\000ArtifactTensor\000";
    static const int32_t values[] = {
        ArtifactType_ArtifactNone,
        ArtifactType_ArtifactImage,
        ArtifactType_ArtifactVideo,
        ArtifactType_ArtifactText,
        ArtifactType_ArtifactTokens,
        ArtifactType_ArtifactEmbedding,
        ArtifactType_ArtifactClassifications,
        ArtifactType_ArtifactMask,
        ArtifactType_ArtifactLatent,
        ArtifactType_ArtifactTensor,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ArtifactType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ArtifactType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ArtifactType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ArtifactType_ArtifactNone:
    case ArtifactType_ArtifactImage:
    case ArtifactType_ArtifactVideo:
    case ArtifactType_ArtifactText:
    case ArtifactType_ArtifactTokens:
    case ArtifactType_ArtifactEmbedding:
    case ArtifactType_ArtifactClassifications:
    case ArtifactType_ArtifactMask:
    case ArtifactType_ArtifactLatent:
    case ArtifactType_ArtifactTensor:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MaskedAreaInit

GPBEnumDescriptor *MaskedAreaInit_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MaskedAreaInitZero\000MaskedAreaInitRandom\000"
        "MaskedAreaInitOriginal\000";
    static const int32_t values[] = {
        MaskedAreaInit_MaskedAreaInitZero,
        MaskedAreaInit_MaskedAreaInitRandom,
        MaskedAreaInit_MaskedAreaInitOriginal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MaskedAreaInit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MaskedAreaInit_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MaskedAreaInit_IsValidValue(int32_t value__) {
  switch (value__) {
    case MaskedAreaInit_MaskedAreaInitZero:
    case MaskedAreaInit_MaskedAreaInitRandom:
    case MaskedAreaInit_MaskedAreaInitOriginal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum WeightMethod

GPBEnumDescriptor *WeightMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextEncoder\000CrossAttention\000";
    static const int32_t values[] = {
        WeightMethod_TextEncoder,
        WeightMethod_CrossAttention,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WeightMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WeightMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WeightMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case WeightMethod_TextEncoder:
    case WeightMethod_CrossAttention:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DiffusionSampler

GPBEnumDescriptor *DiffusionSampler_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SamplerDdim\000SamplerDdpm\000SamplerKEuler\000Sa"
        "mplerKEulerAncestral\000SamplerKHeun\000Sample"
        "rKDpm2\000SamplerKDpm2Ancestral\000SamplerKLms"
        "\000SamplerKDpmpp2SAncestral\000SamplerKDpmpp2"
        "M\000SamplerKDpmppSde\000";
    static const int32_t values[] = {
        DiffusionSampler_SamplerDdim,
        DiffusionSampler_SamplerDdpm,
        DiffusionSampler_SamplerKEuler,
        DiffusionSampler_SamplerKEulerAncestral,
        DiffusionSampler_SamplerKHeun,
        DiffusionSampler_SamplerKDpm2,
        DiffusionSampler_SamplerKDpm2Ancestral,
        DiffusionSampler_SamplerKLms,
        DiffusionSampler_SamplerKDpmpp2SAncestral,
        DiffusionSampler_SamplerKDpmpp2M,
        DiffusionSampler_SamplerKDpmppSde,
    };
    static const char *extraTextFormatInfo = "\004\005g\201\343\201\000\006g\201\343\201\351\000\010g\201\345\202\351\000\tg\201\345\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DiffusionSampler)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DiffusionSampler_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DiffusionSampler_IsValidValue(int32_t value__) {
  switch (value__) {
    case DiffusionSampler_SamplerDdim:
    case DiffusionSampler_SamplerDdpm:
    case DiffusionSampler_SamplerKEuler:
    case DiffusionSampler_SamplerKEulerAncestral:
    case DiffusionSampler_SamplerKHeun:
    case DiffusionSampler_SamplerKDpm2:
    case DiffusionSampler_SamplerKDpm2Ancestral:
    case DiffusionSampler_SamplerKLms:
    case DiffusionSampler_SamplerKDpmpp2SAncestral:
    case DiffusionSampler_SamplerKDpmpp2M:
    case DiffusionSampler_SamplerKDpmppSde:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Upscaler

GPBEnumDescriptor *Upscaler_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UpscalerRgb\000UpscalerGfpgan\000UpscalerEsrga"
        "n\000";
    static const int32_t values[] = {
        Upscaler_UpscalerRgb,
        Upscaler_UpscalerGfpgan,
        Upscaler_UpscalerEsrgan,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Upscaler)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Upscaler_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Upscaler_IsValidValue(int32_t value__) {
  switch (value__) {
    case Upscaler_UpscalerRgb:
    case Upscaler_UpscalerGfpgan:
    case Upscaler_UpscalerEsrgan:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GuidancePreset

GPBEnumDescriptor *GuidancePreset_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GuidancePresetNone\000GuidancePresetSimple\000"
        "GuidancePresetFastBlue\000GuidancePresetFas"
        "tGreen\000GuidancePresetSlow\000GuidancePreset"
        "Slower\000GuidancePresetSlowest\000";
    static const int32_t values[] = {
        GuidancePreset_GuidancePresetNone,
        GuidancePreset_GuidancePresetSimple,
        GuidancePreset_GuidancePresetFastBlue,
        GuidancePreset_GuidancePresetFastGreen,
        GuidancePreset_GuidancePresetSlow,
        GuidancePreset_GuidancePresetSlower,
        GuidancePreset_GuidancePresetSlowest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GuidancePreset)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GuidancePreset_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GuidancePreset_IsValidValue(int32_t value__) {
  switch (value__) {
    case GuidancePreset_GuidancePresetNone:
    case GuidancePreset_GuidancePresetSimple:
    case GuidancePreset_GuidancePresetFastBlue:
    case GuidancePreset_GuidancePresetFastGreen:
    case GuidancePreset_GuidancePresetSlow:
    case GuidancePreset_GuidancePresetSlower:
    case GuidancePreset_GuidancePresetSlowest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ModelArchitecture

GPBEnumDescriptor *ModelArchitecture_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ModelArchitectureNone\000ModelArchitectureC"
        "lipVit\000ModelArchitectureClipResnet\000Model"
        "ArchitectureLdm\000";
    static const int32_t values[] = {
        ModelArchitecture_ModelArchitectureNone,
        ModelArchitecture_ModelArchitectureClipVit,
        ModelArchitecture_ModelArchitectureClipResnet,
        ModelArchitecture_ModelArchitectureLdm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ModelArchitecture)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ModelArchitecture_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ModelArchitecture_IsValidValue(int32_t value__) {
  switch (value__) {
    case ModelArchitecture_ModelArchitectureNone:
    case ModelArchitecture_ModelArchitectureClipVit:
    case ModelArchitecture_ModelArchitectureClipResnet:
    case ModelArchitecture_ModelArchitectureLdm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Action

GPBEnumDescriptor *Action_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ActionPassthrough\000ActionRegenerateDuplic"
        "ate\000ActionRegenerate\000ActionObfuscateDupl"
        "icate\000ActionObfuscate\000ActionDiscard\000";
    static const int32_t values[] = {
        Action_ActionPassthrough,
        Action_ActionRegenerateDuplicate,
        Action_ActionRegenerate,
        Action_ActionObfuscateDuplicate,
        Action_ActionObfuscate,
        Action_ActionDiscard,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_ActionPassthrough:
    case Action_ActionRegenerateDuplicate:
    case Action_ActionRegenerate:
    case Action_ActionObfuscateDuplicate:
    case Action_ActionObfuscate:
    case Action_ActionDiscard:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ClassifierMode

GPBEnumDescriptor *ClassifierMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClsfrModeZeroshot\000ClsfrModeMulticlass\000";
    static const int32_t values[] = {
        ClassifierMode_ClsfrModeZeroshot,
        ClassifierMode_ClsfrModeMulticlass,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClassifierMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClassifierMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClassifierMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClassifierMode_ClsfrModeZeroshot:
    case ClassifierMode_ClsfrModeMulticlass:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AssetAction

GPBEnumDescriptor *AssetAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AssetPut\000AssetGet\000AssetDelete\000";
    static const int32_t values[] = {
        AssetAction_AssetPut,
        AssetAction_AssetGet,
        AssetAction_AssetDelete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AssetAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AssetAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AssetAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case AssetAction_AssetPut:
    case AssetAction_AssetGet:
    case AssetAction_AssetDelete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AssetUse

GPBEnumDescriptor *AssetUse_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AssetUseUndefined\000AssetUseInput\000AssetUse"
        "Output\000AssetUseIntermediate\000AssetUseProj"
        "ect\000";
    static const int32_t values[] = {
        AssetUse_AssetUseUndefined,
        AssetUse_AssetUseInput,
        AssetUse_AssetUseOutput,
        AssetUse_AssetUseIntermediate,
        AssetUse_AssetUseProject,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AssetUse)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AssetUse_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AssetUse_IsValidValue(int32_t value__) {
  switch (value__) {
    case AssetUse_AssetUseUndefined:
    case AssetUse_AssetUseInput:
    case AssetUse_AssetUseOutput:
    case AssetUse_AssetUseIntermediate:
    case AssetUse_AssetUseProject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum StageAction

GPBEnumDescriptor *StageAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StageActionPass\000StageActionDiscard\000Stage"
        "ActionReturn\000";
    static const int32_t values[] = {
        StageAction_StageActionPass,
        StageAction_StageActionDiscard,
        StageAction_StageActionReturn,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StageAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StageAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StageAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case StageAction_StageActionPass:
    case StageAction_StageActionDiscard:
    case StageAction_StageActionReturn:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Token

@implementation Token

@dynamic hasText, text;
@dynamic id_p;

typedef struct Token__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  NSString *text;
} Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Token_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Token__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Token_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Token__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Token class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Token__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Tokens

@implementation Tokens

@dynamic tokensArray, tokensArray_Count;
@dynamic hasTokenizerId, tokenizerId;

typedef struct Tokens__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tokensArray;
  NSString *tokenizerId;
} Tokens__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokensArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Token),
        .number = Tokens_FieldNumber_TokensArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Tokens__storage_, tokensArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tokenizerId",
        .dataTypeSpecific.clazz = Nil,
        .number = Tokens_FieldNumber_TokenizerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tokens__storage_, tokenizerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Tokens class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tokens__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Artifact

@implementation Artifact

@dynamic dataOneOfCase;
@dynamic id_p;
@dynamic type;
@dynamic mime;
@dynamic hasMagic, magic;
@dynamic binary;
@dynamic text;
@dynamic tokens;
@dynamic classifier;
@dynamic tensor;
@dynamic index;
@dynamic finishReason;
@dynamic seed;
@dynamic uuid;
@dynamic size;

typedef struct Artifact__storage_ {
  uint32_t _has_storage_[2];
  ArtifactType type;
  uint32_t index;
  FinishReason finishReason;
  uint32_t seed;
  NSString *mime;
  NSString *magic;
  NSData *binary;
  NSString *text;
  Tokens *tokens;
  ClassifierParameters *classifier;
  NSString *uuid;
  Tensor *tensor;
  uint64_t id_p;
  uint64_t size;
} Artifact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Artifact__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ArtifactType_EnumDescriptor,
        .number = Artifact_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Artifact__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mime",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Mime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Artifact__storage_, mime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magic",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Magic,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Artifact__storage_, magic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "binary",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Binary,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Artifact__storage_, binary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Artifact__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokens",
        .dataTypeSpecific.clazz = GPBObjCClass(Tokens),
        .number = Artifact_FieldNumber_Tokens,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Artifact__storage_, tokens),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Index,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Artifact__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "finishReason",
        .dataTypeSpecific.enumDescFunc = FinishReason_EnumDescriptor,
        .number = Artifact_FieldNumber_FinishReason,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Artifact__storage_, finishReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "seed",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Seed,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Artifact__storage_, seed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "classifier",
        .dataTypeSpecific.clazz = GPBObjCClass(ClassifierParameters),
        .number = Artifact_FieldNumber_Classifier,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Artifact__storage_, classifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Uuid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Artifact__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = Artifact_FieldNumber_Size,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Artifact__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tensor",
        .dataTypeSpecific.clazz = GPBObjCClass(Tensor),
        .number = Artifact_FieldNumber_Tensor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Artifact__storage_, tensor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Artifact class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Artifact__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Artifact_Type_RawValue(Artifact *message) {
  GPBDescriptor *descriptor = [Artifact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Artifact_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetArtifact_Type_RawValue(Artifact *message, int32_t value) {
  GPBDescriptor *descriptor = [Artifact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Artifact_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Artifact_FinishReason_RawValue(Artifact *message) {
  GPBDescriptor *descriptor = [Artifact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Artifact_FieldNumber_FinishReason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetArtifact_FinishReason_RawValue(Artifact *message, int32_t value) {
  GPBDescriptor *descriptor = [Artifact descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Artifact_FieldNumber_FinishReason];
  GPBSetMessageRawEnumField(message, field, value);
}

void Artifact_ClearDataOneOfCase(Artifact *message) {
  GPBDescriptor *descriptor = [Artifact descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - PromptParameters

@implementation PromptParameters

@dynamic hasInit_p, init_p;
@dynamic hasWeight, weight;

typedef struct PromptParameters__storage_ {
  uint32_t _has_storage_[1];
  float weight;
} PromptParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "init_p",
        .dataTypeSpecific.clazz = Nil,
        .number = PromptParameters_FieldNumber_Init_p,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "weight",
        .dataTypeSpecific.clazz = Nil,
        .number = PromptParameters_FieldNumber_Weight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PromptParameters__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PromptParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PromptParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Prompt

@implementation Prompt

@dynamic promptOneOfCase;
@dynamic hasParameters, parameters;
@dynamic text;
@dynamic tokens;
@dynamic artifact;

typedef struct Prompt__storage_ {
  uint32_t _has_storage_[2];
  PromptParameters *parameters;
  NSString *text;
  Tokens *tokens;
  Artifact *artifact;
} Prompt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parameters",
        .dataTypeSpecific.clazz = GPBObjCClass(PromptParameters),
        .number = Prompt_FieldNumber_Parameters,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Prompt__storage_, parameters),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Prompt_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Prompt__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokens",
        .dataTypeSpecific.clazz = GPBObjCClass(Tokens),
        .number = Prompt_FieldNumber_Tokens,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Prompt__storage_, tokens),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifact",
        .dataTypeSpecific.clazz = GPBObjCClass(Artifact),
        .number = Prompt_FieldNumber_Artifact,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Prompt__storage_, artifact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Prompt class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Prompt__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "prompt",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Prompt_ClearPromptOneOfCase(Prompt *message) {
  GPBDescriptor *descriptor = [Prompt descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SamplerParameters

@implementation SamplerParameters

@dynamic hasEta, eta;
@dynamic hasSamplingSteps, samplingSteps;
@dynamic hasLatentChannels, latentChannels;
@dynamic hasDownsamplingFactor, downsamplingFactor;
@dynamic hasCfgScale, cfgScale;
@dynamic hasInitNoiseScale, initNoiseScale;
@dynamic hasStepNoiseScale, stepNoiseScale;

typedef struct SamplerParameters__storage_ {
  uint32_t _has_storage_[1];
  float eta;
  float cfgScale;
  float initNoiseScale;
  float stepNoiseScale;
  uint64_t samplingSteps;
  uint64_t latentChannels;
  uint64_t downsamplingFactor;
} SamplerParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eta",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_Eta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, eta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "samplingSteps",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_SamplingSteps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, samplingSteps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latentChannels",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_LatentChannels,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, latentChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "downsamplingFactor",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_DownsamplingFactor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, downsamplingFactor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "cfgScale",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_CfgScale,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, cfgScale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "initNoiseScale",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_InitNoiseScale,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, initNoiseScale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "stepNoiseScale",
        .dataTypeSpecific.clazz = Nil,
        .number = SamplerParameters_FieldNumber_StepNoiseScale,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SamplerParameters__storage_, stepNoiseScale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SamplerParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SamplerParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConditionerParameters

@implementation ConditionerParameters

@dynamic hasVectorAdjustPrior, vectorAdjustPrior;
@dynamic hasConditioner, conditioner;

typedef struct ConditionerParameters__storage_ {
  uint32_t _has_storage_[1];
  NSString *vectorAdjustPrior;
  Model *conditioner;
} ConditionerParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vectorAdjustPrior",
        .dataTypeSpecific.clazz = Nil,
        .number = ConditionerParameters_FieldNumber_VectorAdjustPrior,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConditionerParameters__storage_, vectorAdjustPrior),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conditioner",
        .dataTypeSpecific.clazz = GPBObjCClass(Model),
        .number = ConditionerParameters_FieldNumber_Conditioner,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConditionerParameters__storage_, conditioner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConditionerParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConditionerParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScheduleParameters

@implementation ScheduleParameters

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasValue, value;

typedef struct ScheduleParameters__storage_ {
  uint32_t _has_storage_[1];
  float start;
  float end;
  float value;
} ScheduleParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = Nil,
        .number = ScheduleParameters_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScheduleParameters__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "end",
        .dataTypeSpecific.clazz = Nil,
        .number = ScheduleParameters_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScheduleParameters__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ScheduleParameters_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScheduleParameters__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScheduleParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScheduleParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StepParameter

@implementation StepParameter

@dynamic scaledStep;
@dynamic hasSampler, sampler;
@dynamic hasSchedule, schedule;
@dynamic hasGuidance, guidance;

typedef struct StepParameter__storage_ {
  uint32_t _has_storage_[1];
  float scaledStep;
  SamplerParameters *sampler;
  ScheduleParameters *schedule;
  GuidanceParameters *guidance;
} StepParameter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "scaledStep",
        .dataTypeSpecific.clazz = Nil,
        .number = StepParameter_FieldNumber_ScaledStep,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StepParameter__storage_, scaledStep),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "sampler",
        .dataTypeSpecific.clazz = GPBObjCClass(SamplerParameters),
        .number = StepParameter_FieldNumber_Sampler,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StepParameter__storage_, sampler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "schedule",
        .dataTypeSpecific.clazz = GPBObjCClass(ScheduleParameters),
        .number = StepParameter_FieldNumber_Schedule,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StepParameter__storage_, schedule),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "guidance",
        .dataTypeSpecific.clazz = GPBObjCClass(GuidanceParameters),
        .number = StepParameter_FieldNumber_Guidance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StepParameter__storage_, guidance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StepParameter class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StepParameter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model

@implementation Model

@dynamic architecture;
@dynamic publisher;
@dynamic dataset;
@dynamic version;
@dynamic semanticVersion;
@dynamic alias;

typedef struct Model__storage_ {
  uint32_t _has_storage_[1];
  ModelArchitecture architecture;
  float version;
  NSString *publisher;
  NSString *dataset;
  NSString *semanticVersion;
  NSString *alias;
} Model__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "architecture",
        .dataTypeSpecific.enumDescFunc = ModelArchitecture_EnumDescriptor,
        .number = Model_FieldNumber_Architecture,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Model__storage_, architecture),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "publisher",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Publisher,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Model__storage_, publisher),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataset",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Dataset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Model__storage_, dataset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Model__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "semanticVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_SemanticVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Model__storage_, semanticVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Alias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Model__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Model__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Model_Architecture_RawValue(Model *message) {
  GPBDescriptor *descriptor = [Model descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Model_FieldNumber_Architecture];
  return GPBGetMessageRawEnumField(message, field);
}

void SetModel_Architecture_RawValue(Model *message, int32_t value) {
  GPBDescriptor *descriptor = [Model descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Model_FieldNumber_Architecture];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CutoutParameters

@implementation CutoutParameters

@dynamic cutoutsArray, cutoutsArray_Count;
@dynamic hasCount, count;
@dynamic hasGray, gray;
@dynamic hasBlur, blur;
@dynamic hasSizePower, sizePower;

typedef struct CutoutParameters__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  float gray;
  float blur;
  float sizePower;
  NSMutableArray *cutoutsArray;
} CutoutParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cutoutsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CutoutParameters),
        .number = CutoutParameters_FieldNumber_CutoutsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CutoutParameters__storage_, cutoutsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = CutoutParameters_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CutoutParameters__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gray",
        .dataTypeSpecific.clazz = Nil,
        .number = CutoutParameters_FieldNumber_Gray,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CutoutParameters__storage_, gray),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "blur",
        .dataTypeSpecific.clazz = Nil,
        .number = CutoutParameters_FieldNumber_Blur,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CutoutParameters__storage_, blur),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "sizePower",
        .dataTypeSpecific.clazz = Nil,
        .number = CutoutParameters_FieldNumber_SizePower,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CutoutParameters__storage_, sizePower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CutoutParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CutoutParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GuidanceScheduleParameters

@implementation GuidanceScheduleParameters

@dynamic duration;
@dynamic value;

typedef struct GuidanceScheduleParameters__storage_ {
  uint32_t _has_storage_[1];
  float duration;
  float value;
} GuidanceScheduleParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = GuidanceScheduleParameters_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GuidanceScheduleParameters__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GuidanceScheduleParameters_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GuidanceScheduleParameters__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GuidanceScheduleParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GuidanceScheduleParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GuidanceInstanceParameters

@implementation GuidanceInstanceParameters

@dynamic modelsArray, modelsArray_Count;
@dynamic hasGuidanceStrength, guidanceStrength;
@dynamic scheduleArray, scheduleArray_Count;
@dynamic hasCutouts, cutouts;
@dynamic hasPrompt, prompt;

typedef struct GuidanceInstanceParameters__storage_ {
  uint32_t _has_storage_[1];
  float guidanceStrength;
  NSMutableArray *modelsArray;
  NSMutableArray *scheduleArray;
  CutoutParameters *cutouts;
  Prompt *prompt;
} GuidanceInstanceParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Model),
        .number = GuidanceInstanceParameters_FieldNumber_ModelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GuidanceInstanceParameters__storage_, modelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "guidanceStrength",
        .dataTypeSpecific.clazz = Nil,
        .number = GuidanceInstanceParameters_FieldNumber_GuidanceStrength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GuidanceInstanceParameters__storage_, guidanceStrength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "scheduleArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GuidanceScheduleParameters),
        .number = GuidanceInstanceParameters_FieldNumber_ScheduleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GuidanceInstanceParameters__storage_, scheduleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cutouts",
        .dataTypeSpecific.clazz = GPBObjCClass(CutoutParameters),
        .number = GuidanceInstanceParameters_FieldNumber_Cutouts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GuidanceInstanceParameters__storage_, cutouts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prompt",
        .dataTypeSpecific.clazz = GPBObjCClass(Prompt),
        .number = GuidanceInstanceParameters_FieldNumber_Prompt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GuidanceInstanceParameters__storage_, prompt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GuidanceInstanceParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GuidanceInstanceParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GuidanceParameters

@implementation GuidanceParameters

@dynamic guidancePreset;
@dynamic instancesArray, instancesArray_Count;

typedef struct GuidanceParameters__storage_ {
  uint32_t _has_storage_[1];
  GuidancePreset guidancePreset;
  NSMutableArray *instancesArray;
} GuidanceParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "guidancePreset",
        .dataTypeSpecific.enumDescFunc = GuidancePreset_EnumDescriptor,
        .number = GuidanceParameters_FieldNumber_GuidancePreset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GuidanceParameters__storage_, guidancePreset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "instancesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GuidanceInstanceParameters),
        .number = GuidanceParameters_FieldNumber_InstancesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GuidanceParameters__storage_, instancesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GuidanceParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GuidanceParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GuidanceParameters_GuidancePreset_RawValue(GuidanceParameters *message) {
  GPBDescriptor *descriptor = [GuidanceParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GuidanceParameters_FieldNumber_GuidancePreset];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGuidanceParameters_GuidancePreset_RawValue(GuidanceParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [GuidanceParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GuidanceParameters_FieldNumber_GuidancePreset];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TransformType

@implementation TransformType

@dynamic typeOneOfCase;
@dynamic diffusion;
@dynamic upscaler;

typedef struct TransformType__storage_ {
  uint32_t _has_storage_[2];
  DiffusionSampler diffusion;
  Upscaler upscaler;
} TransformType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "diffusion",
        .dataTypeSpecific.enumDescFunc = DiffusionSampler_EnumDescriptor,
        .number = TransformType_FieldNumber_Diffusion,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransformType__storage_, diffusion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "upscaler",
        .dataTypeSpecific.enumDescFunc = Upscaler_EnumDescriptor,
        .number = TransformType_FieldNumber_Upscaler,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransformType__storage_, upscaler),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransformType class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransformType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "type",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransformType_Diffusion_RawValue(TransformType *message) {
  GPBDescriptor *descriptor = [TransformType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransformType_FieldNumber_Diffusion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTransformType_Diffusion_RawValue(TransformType *message, int32_t value) {
  GPBDescriptor *descriptor = [TransformType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransformType_FieldNumber_Diffusion];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t TransformType_Upscaler_RawValue(TransformType *message) {
  GPBDescriptor *descriptor = [TransformType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransformType_FieldNumber_Upscaler];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTransformType_Upscaler_RawValue(TransformType *message, int32_t value) {
  GPBDescriptor *descriptor = [TransformType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransformType_FieldNumber_Upscaler];
  GPBSetMessageRawEnumField(message, field, value);
}

void TransformType_ClearTypeOneOfCase(TransformType *message) {
  GPBDescriptor *descriptor = [TransformType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ImageParameters

@implementation ImageParameters

@dynamic hasHeight, height;
@dynamic hasWidth, width;
@dynamic seedArray, seedArray_Count;
@dynamic hasSamples, samples;
@dynamic hasSteps, steps;
@dynamic hasTransform, transform;
@dynamic parametersArray, parametersArray_Count;
@dynamic hasMaskedAreaInit, maskedAreaInit;
@dynamic hasWeightMethod, weightMethod;
@dynamic hasQuantize, quantize;

typedef struct ImageParameters__storage_ {
  uint32_t _has_storage_[1];
  MaskedAreaInit maskedAreaInit;
  WeightMethod weightMethod;
  GPBUInt32Array *seedArray;
  TransformType *transform;
  NSMutableArray *parametersArray;
  uint64_t height;
  uint64_t width;
  uint64_t samples;
  uint64_t steps;
} ImageParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "seedArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_SeedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, seedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "samples",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_Samples,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, samples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "steps",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_Steps,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, steps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transform",
        .dataTypeSpecific.clazz = GPBObjCClass(TransformType),
        .number = ImageParameters_FieldNumber_Transform,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, transform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "parametersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StepParameter),
        .number = ImageParameters_FieldNumber_ParametersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, parametersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maskedAreaInit",
        .dataTypeSpecific.enumDescFunc = MaskedAreaInit_EnumDescriptor,
        .number = ImageParameters_FieldNumber_MaskedAreaInit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, maskedAreaInit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "weightMethod",
        .dataTypeSpecific.enumDescFunc = WeightMethod_EnumDescriptor,
        .number = ImageParameters_FieldNumber_WeightMethod,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ImageParameters__storage_, weightMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "quantize",
        .dataTypeSpecific.clazz = Nil,
        .number = ImageParameters_FieldNumber_Quantize,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ImageParameters_MaskedAreaInit_RawValue(ImageParameters *message) {
  GPBDescriptor *descriptor = [ImageParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImageParameters_FieldNumber_MaskedAreaInit];
  return GPBGetMessageRawEnumField(message, field);
}

void SetImageParameters_MaskedAreaInit_RawValue(ImageParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [ImageParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImageParameters_FieldNumber_MaskedAreaInit];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ImageParameters_WeightMethod_RawValue(ImageParameters *message) {
  GPBDescriptor *descriptor = [ImageParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImageParameters_FieldNumber_WeightMethod];
  return GPBGetMessageRawEnumField(message, field);
}

void SetImageParameters_WeightMethod_RawValue(ImageParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [ImageParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ImageParameters_FieldNumber_WeightMethod];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ClassifierConcept

@implementation ClassifierConcept

@dynamic concept;
@dynamic hasThreshold, threshold;

typedef struct ClassifierConcept__storage_ {
  uint32_t _has_storage_[1];
  float threshold;
  NSString *concept;
} ClassifierConcept__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "concept",
        .dataTypeSpecific.clazz = Nil,
        .number = ClassifierConcept_FieldNumber_Concept,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClassifierConcept__storage_, concept),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.clazz = Nil,
        .number = ClassifierConcept_FieldNumber_Threshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClassifierConcept__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClassifierConcept class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClassifierConcept__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClassifierCategory

@implementation ClassifierCategory

@dynamic name;
@dynamic conceptsArray, conceptsArray_Count;
@dynamic hasAdjustment, adjustment;
@dynamic hasAction, action;
@dynamic hasClassifierMode, classifierMode;

typedef struct ClassifierCategory__storage_ {
  uint32_t _has_storage_[1];
  float adjustment;
  Action action;
  ClassifierMode classifierMode;
  NSString *name;
  NSMutableArray *conceptsArray;
} ClassifierCategory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ClassifierCategory_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClassifierCategory__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conceptsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ClassifierConcept),
        .number = ClassifierCategory_FieldNumber_ConceptsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClassifierCategory__storage_, conceptsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "adjustment",
        .dataTypeSpecific.clazz = Nil,
        .number = ClassifierCategory_FieldNumber_Adjustment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClassifierCategory__storage_, adjustment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = Action_EnumDescriptor,
        .number = ClassifierCategory_FieldNumber_Action,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClassifierCategory__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "classifierMode",
        .dataTypeSpecific.enumDescFunc = ClassifierMode_EnumDescriptor,
        .number = ClassifierCategory_FieldNumber_ClassifierMode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClassifierCategory__storage_, classifierMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClassifierCategory class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClassifierCategory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ClassifierCategory_Action_RawValue(ClassifierCategory *message) {
  GPBDescriptor *descriptor = [ClassifierCategory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierCategory_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetClassifierCategory_Action_RawValue(ClassifierCategory *message, int32_t value) {
  GPBDescriptor *descriptor = [ClassifierCategory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierCategory_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ClassifierCategory_ClassifierMode_RawValue(ClassifierCategory *message) {
  GPBDescriptor *descriptor = [ClassifierCategory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierCategory_FieldNumber_ClassifierMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetClassifierCategory_ClassifierMode_RawValue(ClassifierCategory *message, int32_t value) {
  GPBDescriptor *descriptor = [ClassifierCategory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierCategory_FieldNumber_ClassifierMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ClassifierParameters

@implementation ClassifierParameters

@dynamic categoriesArray, categoriesArray_Count;
@dynamic exceedsArray, exceedsArray_Count;
@dynamic hasRealizedAction, realizedAction;

typedef struct ClassifierParameters__storage_ {
  uint32_t _has_storage_[1];
  Action realizedAction;
  NSMutableArray *categoriesArray;
  NSMutableArray *exceedsArray;
} ClassifierParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "categoriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ClassifierCategory),
        .number = ClassifierParameters_FieldNumber_CategoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClassifierParameters__storage_, categoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exceedsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ClassifierCategory),
        .number = ClassifierParameters_FieldNumber_ExceedsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClassifierParameters__storage_, exceedsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realizedAction",
        .dataTypeSpecific.enumDescFunc = Action_EnumDescriptor,
        .number = ClassifierParameters_FieldNumber_RealizedAction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClassifierParameters__storage_, realizedAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClassifierParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClassifierParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ClassifierParameters_RealizedAction_RawValue(ClassifierParameters *message) {
  GPBDescriptor *descriptor = [ClassifierParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierParameters_FieldNumber_RealizedAction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetClassifierParameters_RealizedAction_RawValue(ClassifierParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [ClassifierParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClassifierParameters_FieldNumber_RealizedAction];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AssetParameters

@implementation AssetParameters

@dynamic action;
@dynamic projectId;
@dynamic use;

typedef struct AssetParameters__storage_ {
  uint32_t _has_storage_[1];
  AssetAction action;
  AssetUse use;
  NSString *projectId;
} AssetParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = AssetAction_EnumDescriptor,
        .number = AssetParameters_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetParameters__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "projectId",
        .dataTypeSpecific.clazz = Nil,
        .number = AssetParameters_FieldNumber_ProjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssetParameters__storage_, projectId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "use",
        .dataTypeSpecific.enumDescFunc = AssetUse_EnumDescriptor,
        .number = AssetParameters_FieldNumber_Use,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssetParameters__storage_, use),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetParameters class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AssetParameters_Action_RawValue(AssetParameters *message) {
  GPBDescriptor *descriptor = [AssetParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AssetParameters_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAssetParameters_Action_RawValue(AssetParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [AssetParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AssetParameters_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t AssetParameters_Use_RawValue(AssetParameters *message) {
  GPBDescriptor *descriptor = [AssetParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AssetParameters_FieldNumber_Use];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAssetParameters_Use_RawValue(AssetParameters *message, int32_t value) {
  GPBDescriptor *descriptor = [AssetParameters descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AssetParameters_FieldNumber_Use];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AnswerMeta

@implementation AnswerMeta

@dynamic hasGpuId, gpuId;
@dynamic hasCpuId, cpuId;
@dynamic hasNodeId, nodeId;
@dynamic hasEngineId, engineId;

typedef struct AnswerMeta__storage_ {
  uint32_t _has_storage_[1];
  NSString *gpuId;
  NSString *cpuId;
  NSString *nodeId;
  NSString *engineId;
} AnswerMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gpuId",
        .dataTypeSpecific.clazz = Nil,
        .number = AnswerMeta_FieldNumber_GpuId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AnswerMeta__storage_, gpuId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuId",
        .dataTypeSpecific.clazz = Nil,
        .number = AnswerMeta_FieldNumber_CpuId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AnswerMeta__storage_, cpuId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nodeId",
        .dataTypeSpecific.clazz = Nil,
        .number = AnswerMeta_FieldNumber_NodeId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AnswerMeta__storage_, nodeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "engineId",
        .dataTypeSpecific.clazz = Nil,
        .number = AnswerMeta_FieldNumber_EngineId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AnswerMeta__storage_, engineId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AnswerMeta class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AnswerMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Answer

@implementation Answer

@dynamic answerId;
@dynamic requestId;
@dynamic received;
@dynamic created;
@dynamic hasMeta, meta;
@dynamic artifactsArray, artifactsArray_Count;

typedef struct Answer__storage_ {
  uint32_t _has_storage_[1];
  NSString *answerId;
  NSString *requestId;
  AnswerMeta *meta;
  NSMutableArray *artifactsArray;
  uint64_t received;
  uint64_t created;
} Answer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "answerId",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_AnswerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Answer__storage_, answerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_RequestId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Answer__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "received",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_Received,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Answer__storage_, received),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "created",
        .dataTypeSpecific.clazz = Nil,
        .number = Answer_FieldNumber_Created,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Answer__storage_, created),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "meta",
        .dataTypeSpecific.clazz = GPBObjCClass(AnswerMeta),
        .number = Answer_FieldNumber_Meta,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Answer__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Artifact),
        .number = Answer_FieldNumber_ArtifactsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Answer__storage_, artifactsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Answer class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Answer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Request

@implementation Request

@dynamic paramsOneOfCase;
@dynamic engineId;
@dynamic requestId;
@dynamic requestedType;
@dynamic promptArray, promptArray_Count;
@dynamic image;
@dynamic classifier;
@dynamic asset;
@dynamic hasConditioner, conditioner;

typedef struct Request__storage_ {
  uint32_t _has_storage_[2];
  ArtifactType requestedType;
  NSString *engineId;
  NSString *requestId;
  NSMutableArray *promptArray;
  ImageParameters *image;
  ConditionerParameters *conditioner;
  ClassifierParameters *classifier;
  AssetParameters *asset;
} Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "engineId",
        .dataTypeSpecific.clazz = Nil,
        .number = Request_FieldNumber_EngineId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Request__storage_, engineId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.clazz = Nil,
        .number = Request_FieldNumber_RequestId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Request__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestedType",
        .dataTypeSpecific.enumDescFunc = ArtifactType_EnumDescriptor,
        .number = Request_FieldNumber_RequestedType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Request__storage_, requestedType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "promptArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Prompt),
        .number = Request_FieldNumber_PromptArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Request__storage_, promptArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(ImageParameters),
        .number = Request_FieldNumber_Image,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conditioner",
        .dataTypeSpecific.clazz = GPBObjCClass(ConditionerParameters),
        .number = Request_FieldNumber_Conditioner,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Request__storage_, conditioner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "classifier",
        .dataTypeSpecific.clazz = GPBObjCClass(ClassifierParameters),
        .number = Request_FieldNumber_Classifier,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, classifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asset",
        .dataTypeSpecific.clazz = GPBObjCClass(AssetParameters),
        .number = Request_FieldNumber_Asset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, asset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Request class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Request__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "params",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Request_RequestedType_RawValue(Request *message) {
  GPBDescriptor *descriptor = [Request descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Request_FieldNumber_RequestedType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequest_RequestedType_RawValue(Request *message, int32_t value) {
  GPBDescriptor *descriptor = [Request descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Request_FieldNumber_RequestedType];
  GPBSetMessageRawEnumField(message, field, value);
}

void Request_ClearParamsOneOfCase(Request *message) {
  GPBDescriptor *descriptor = [Request descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - OnStatus

@implementation OnStatus

@dynamic reasonArray, reasonArray_Count;
@dynamic hasTarget, target;
@dynamic actionArray, actionArray_Count;

typedef struct OnStatus__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *reasonArray;
  NSString *target;
  GPBEnumArray *actionArray;
} OnStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reasonArray",
        .dataTypeSpecific.enumDescFunc = FinishReason_EnumDescriptor,
        .number = OnStatus_FieldNumber_ReasonArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OnStatus__storage_, reasonArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "target",
        .dataTypeSpecific.clazz = Nil,
        .number = OnStatus_FieldNumber_Target,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnStatus__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actionArray",
        .dataTypeSpecific.enumDescFunc = StageAction_EnumDescriptor,
        .number = OnStatus_FieldNumber_ActionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OnStatus__storage_, actionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnStatus class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Stage

@implementation Stage

@dynamic id_p;
@dynamic hasRequest, request;
@dynamic onStatusArray, onStatusArray_Count;

typedef struct Stage__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  Request *request;
  NSMutableArray *onStatusArray;
} Stage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Stage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Stage__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "request",
        .dataTypeSpecific.clazz = GPBObjCClass(Request),
        .number = Stage_FieldNumber_Request,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Stage__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onStatusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OnStatus),
        .number = Stage_FieldNumber_OnStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Stage__storage_, onStatusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Stage class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Stage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainRequest

@implementation ChainRequest

@dynamic requestId;
@dynamic stageArray, stageArray_Count;

typedef struct ChainRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *requestId;
  NSMutableArray *stageArray;
} ChainRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChainRequest_FieldNumber_RequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainRequest__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stageArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Stage),
        .number = ChainRequest_FieldNumber_StageArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainRequest__storage_, stageArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainRequest class]
                                     rootClass:[GenerationRoot class]
                                          file:GenerationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
