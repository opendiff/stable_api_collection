// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensors.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Tensors.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Attribute);
GPBObjCClassDeclaration(Module);
GPBObjCClassDeclaration(Tensor);

#pragma mark - TensorsRoot

@implementation TensorsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TensorsRoot_FileDescriptor

static GPBFileDescriptor *TensorsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"tensors"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Dtype

GPBEnumDescriptor *Dtype_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DtInvalid\000DtFloat32\000DtFloat64\000DtFloat16\000"
        "DtBfloat16\000DtComplex32\000DtComplex64\000DtCom"
        "plex128\000DtUint8\000DtInt8\000DtInt16\000DtInt32\000D"
        "tInt64\000DtBool\000DtQuint8\000DtQint8\000DtQint32\000"
        "DtQuint42\000";
    static const int32_t values[] = {
        Dtype_DtInvalid,
        Dtype_DtFloat32,
        Dtype_DtFloat64,
        Dtype_DtFloat16,
        Dtype_DtBfloat16,
        Dtype_DtComplex32,
        Dtype_DtComplex64,
        Dtype_DtComplex128,
        Dtype_DtUint8,
        Dtype_DtInt8,
        Dtype_DtInt16,
        Dtype_DtInt32,
        Dtype_DtInt64,
        Dtype_DtBool,
        Dtype_DtQuint8,
        Dtype_DtQint8,
        Dtype_DtQint32,
        Dtype_DtQuint42,
    };
    static const char *extraTextFormatInfo = "\001\021b\345\001\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Dtype)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Dtype_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Dtype_IsValidValue(int32_t value__) {
  switch (value__) {
    case Dtype_DtInvalid:
    case Dtype_DtFloat32:
    case Dtype_DtFloat64:
    case Dtype_DtFloat16:
    case Dtype_DtBfloat16:
    case Dtype_DtComplex32:
    case Dtype_DtComplex64:
    case Dtype_DtComplex128:
    case Dtype_DtUint8:
    case Dtype_DtInt8:
    case Dtype_DtInt16:
    case Dtype_DtInt32:
    case Dtype_DtInt64:
    case Dtype_DtBool:
    case Dtype_DtQuint8:
    case Dtype_DtQint8:
    case Dtype_DtQint32:
    case Dtype_DtQuint42:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AttributeType

GPBEnumDescriptor *AttributeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AtParameter\000AtBuffer\000";
    static const int32_t values[] = {
        AttributeType_AtParameter,
        AttributeType_AtBuffer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AttributeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AttributeType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AttributeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AttributeType_AtParameter:
    case AttributeType_AtBuffer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Tensor

@implementation Tensor

@dynamic dtype;
@dynamic shapeArray, shapeArray_Count;
@dynamic data_p;
@dynamic hasAttrType, attrType;

typedef struct Tensor__storage_ {
  uint32_t _has_storage_[1];
  Dtype dtype;
  AttributeType attrType;
  GPBInt64Array *shapeArray;
  NSData *data_p;
} Tensor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dtype",
        .dataTypeSpecific.enumDescFunc = Dtype_EnumDescriptor,
        .number = Tensor_FieldNumber_Dtype,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tensor__storage_, dtype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shapeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Tensor_FieldNumber_ShapeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Tensor__storage_, shapeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Tensor_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Tensor__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "attrType",
        .dataTypeSpecific.enumDescFunc = AttributeType_EnumDescriptor,
        .number = Tensor_FieldNumber_AttrType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Tensor__storage_, attrType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Tensor class]
                                     rootClass:[TensorsRoot class]
                                          file:TensorsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tensor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Tensor_Dtype_RawValue(Tensor *message) {
  GPBDescriptor *descriptor = [Tensor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Tensor_FieldNumber_Dtype];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTensor_Dtype_RawValue(Tensor *message, int32_t value) {
  GPBDescriptor *descriptor = [Tensor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Tensor_FieldNumber_Dtype];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Tensor_AttrType_RawValue(Tensor *message) {
  GPBDescriptor *descriptor = [Tensor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Tensor_FieldNumber_AttrType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTensor_AttrType_RawValue(Tensor *message, int32_t value) {
  GPBDescriptor *descriptor = [Tensor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Tensor_FieldNumber_AttrType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Attribute

@implementation Attribute

@dynamic valueOneOfCase;
@dynamic name;
@dynamic module;
@dynamic tensor;
@dynamic string;
@dynamic int64;
@dynamic float_p;
@dynamic bool_p;

typedef struct Attribute__storage_ {
  uint32_t _has_storage_[2];
  float float_p;
  NSString *name;
  Module *module;
  Tensor *tensor;
  NSString *string;
  int64_t int64;
} Attribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Attribute__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "module",
        .dataTypeSpecific.clazz = GPBObjCClass(Module),
        .number = Attribute_FieldNumber_Module,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Attribute__storage_, module),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tensor",
        .dataTypeSpecific.clazz = GPBObjCClass(Tensor),
        .number = Attribute_FieldNumber_Tensor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Attribute__storage_, tensor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "string",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_String,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Attribute__storage_, string),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "int64",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Int64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Attribute__storage_, int64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "float_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Float_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Attribute__storage_, float_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bool_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Bool_p,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Attribute class]
                                     rootClass:[TensorsRoot class]
                                          file:TensorsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Attribute__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Attribute_ClearValueOneOfCase(Attribute *message) {
  GPBDescriptor *descriptor = [Attribute descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Module

@implementation Module

@dynamic name;
@dynamic namesArray, namesArray_Count;
@dynamic attributesArray, attributesArray_Count;

typedef struct Module__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *namesArray;
  NSMutableArray *attributesArray;
} Module__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Module__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "namesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_NamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, namesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Attribute),
        .number = Module_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Module class]
                                     rootClass:[TensorsRoot class]
                                          file:TensorsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Module__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
