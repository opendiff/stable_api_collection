// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dashboard.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dashboard_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dashboard_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dashboard_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dashboard_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dashboard_2eproto;
namespace gooseai {
class APIKey;
struct APIKeyDefaultTypeInternal;
extern APIKeyDefaultTypeInternal _APIKey_default_instance_;
class APIKeyFindRequest;
struct APIKeyFindRequestDefaultTypeInternal;
extern APIKeyFindRequestDefaultTypeInternal _APIKeyFindRequest_default_instance_;
class APIKeyRequest;
struct APIKeyRequestDefaultTypeInternal;
extern APIKeyRequestDefaultTypeInternal _APIKeyRequest_default_instance_;
class AutoChargeIntent;
struct AutoChargeIntentDefaultTypeInternal;
extern AutoChargeIntentDefaultTypeInternal _AutoChargeIntent_default_instance_;
class Charge;
struct ChargeDefaultTypeInternal;
extern ChargeDefaultTypeInternal _Charge_default_instance_;
class Charges;
struct ChargesDefaultTypeInternal;
extern ChargesDefaultTypeInternal _Charges_default_instance_;
class ClientSettings;
struct ClientSettingsDefaultTypeInternal;
extern ClientSettingsDefaultTypeInternal _ClientSettings_default_instance_;
class CostData;
struct CostDataDefaultTypeInternal;
extern CostDataDefaultTypeInternal _CostData_default_instance_;
class CostTotal;
struct CostTotalDefaultTypeInternal;
extern CostTotalDefaultTypeInternal _CostTotal_default_instance_;
class CreateAutoChargeIntentRequest;
struct CreateAutoChargeIntentRequestDefaultTypeInternal;
extern CreateAutoChargeIntentRequestDefaultTypeInternal _CreateAutoChargeIntentRequest_default_instance_;
class CreateChargeRequest;
struct CreateChargeRequestDefaultTypeInternal;
extern CreateChargeRequestDefaultTypeInternal _CreateChargeRequest_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class GetAutoChargeRequest;
struct GetAutoChargeRequestDefaultTypeInternal;
extern GetAutoChargeRequestDefaultTypeInternal _GetAutoChargeRequest_default_instance_;
class GetChargesRequest;
struct GetChargesRequestDefaultTypeInternal;
extern GetChargesRequestDefaultTypeInternal _GetChargesRequest_default_instance_;
class GetMetricsRequest;
struct GetMetricsRequestDefaultTypeInternal;
extern GetMetricsRequestDefaultTypeInternal _GetMetricsRequest_default_instance_;
class GetOrganizationRequest;
struct GetOrganizationRequestDefaultTypeInternal;
extern GetOrganizationRequestDefaultTypeInternal _GetOrganizationRequest_default_instance_;
class Metrics;
struct MetricsDefaultTypeInternal;
extern MetricsDefaultTypeInternal _Metrics_default_instance_;
class Organization;
struct OrganizationDefaultTypeInternal;
extern OrganizationDefaultTypeInternal _Organization_default_instance_;
class OrganizationAutoCharge;
struct OrganizationAutoChargeDefaultTypeInternal;
extern OrganizationAutoChargeDefaultTypeInternal _OrganizationAutoCharge_default_instance_;
class OrganizationGrant;
struct OrganizationGrantDefaultTypeInternal;
extern OrganizationGrantDefaultTypeInternal _OrganizationGrant_default_instance_;
class OrganizationMember;
struct OrganizationMemberDefaultTypeInternal;
extern OrganizationMemberDefaultTypeInternal _OrganizationMember_default_instance_;
class OrganizationPaymentInfo;
struct OrganizationPaymentInfoDefaultTypeInternal;
extern OrganizationPaymentInfoDefaultTypeInternal _OrganizationPaymentInfo_default_instance_;
class TotalMetricsData;
struct TotalMetricsDataDefaultTypeInternal;
extern TotalMetricsDataDefaultTypeInternal _TotalMetricsData_default_instance_;
class UpdateDefaultOrganizationRequest;
struct UpdateDefaultOrganizationRequestDefaultTypeInternal;
extern UpdateDefaultOrganizationRequestDefaultTypeInternal _UpdateDefaultOrganizationRequest_default_instance_;
class UpdateUserInfoRequest;
struct UpdateUserInfoRequestDefaultTypeInternal;
extern UpdateUserInfoRequestDefaultTypeInternal _UpdateUserInfoRequest_default_instance_;
class UsageMetric;
struct UsageMetricDefaultTypeInternal;
extern UsageMetricDefaultTypeInternal _UsageMetric_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserPasswordChangeTicket;
struct UserPasswordChangeTicketDefaultTypeInternal;
extern UserPasswordChangeTicketDefaultTypeInternal _UserPasswordChangeTicket_default_instance_;
}  // namespace gooseai
PROTOBUF_NAMESPACE_OPEN
template<> ::gooseai::APIKey* Arena::CreateMaybeMessage<::gooseai::APIKey>(Arena*);
template<> ::gooseai::APIKeyFindRequest* Arena::CreateMaybeMessage<::gooseai::APIKeyFindRequest>(Arena*);
template<> ::gooseai::APIKeyRequest* Arena::CreateMaybeMessage<::gooseai::APIKeyRequest>(Arena*);
template<> ::gooseai::AutoChargeIntent* Arena::CreateMaybeMessage<::gooseai::AutoChargeIntent>(Arena*);
template<> ::gooseai::Charge* Arena::CreateMaybeMessage<::gooseai::Charge>(Arena*);
template<> ::gooseai::Charges* Arena::CreateMaybeMessage<::gooseai::Charges>(Arena*);
template<> ::gooseai::ClientSettings* Arena::CreateMaybeMessage<::gooseai::ClientSettings>(Arena*);
template<> ::gooseai::CostData* Arena::CreateMaybeMessage<::gooseai::CostData>(Arena*);
template<> ::gooseai::CostTotal* Arena::CreateMaybeMessage<::gooseai::CostTotal>(Arena*);
template<> ::gooseai::CreateAutoChargeIntentRequest* Arena::CreateMaybeMessage<::gooseai::CreateAutoChargeIntentRequest>(Arena*);
template<> ::gooseai::CreateChargeRequest* Arena::CreateMaybeMessage<::gooseai::CreateChargeRequest>(Arena*);
template<> ::gooseai::EmptyRequest* Arena::CreateMaybeMessage<::gooseai::EmptyRequest>(Arena*);
template<> ::gooseai::GetAutoChargeRequest* Arena::CreateMaybeMessage<::gooseai::GetAutoChargeRequest>(Arena*);
template<> ::gooseai::GetChargesRequest* Arena::CreateMaybeMessage<::gooseai::GetChargesRequest>(Arena*);
template<> ::gooseai::GetMetricsRequest* Arena::CreateMaybeMessage<::gooseai::GetMetricsRequest>(Arena*);
template<> ::gooseai::GetOrganizationRequest* Arena::CreateMaybeMessage<::gooseai::GetOrganizationRequest>(Arena*);
template<> ::gooseai::Metrics* Arena::CreateMaybeMessage<::gooseai::Metrics>(Arena*);
template<> ::gooseai::Organization* Arena::CreateMaybeMessage<::gooseai::Organization>(Arena*);
template<> ::gooseai::OrganizationAutoCharge* Arena::CreateMaybeMessage<::gooseai::OrganizationAutoCharge>(Arena*);
template<> ::gooseai::OrganizationGrant* Arena::CreateMaybeMessage<::gooseai::OrganizationGrant>(Arena*);
template<> ::gooseai::OrganizationMember* Arena::CreateMaybeMessage<::gooseai::OrganizationMember>(Arena*);
template<> ::gooseai::OrganizationPaymentInfo* Arena::CreateMaybeMessage<::gooseai::OrganizationPaymentInfo>(Arena*);
template<> ::gooseai::TotalMetricsData* Arena::CreateMaybeMessage<::gooseai::TotalMetricsData>(Arena*);
template<> ::gooseai::UpdateDefaultOrganizationRequest* Arena::CreateMaybeMessage<::gooseai::UpdateDefaultOrganizationRequest>(Arena*);
template<> ::gooseai::UpdateUserInfoRequest* Arena::CreateMaybeMessage<::gooseai::UpdateUserInfoRequest>(Arena*);
template<> ::gooseai::UsageMetric* Arena::CreateMaybeMessage<::gooseai::UsageMetric>(Arena*);
template<> ::gooseai::User* Arena::CreateMaybeMessage<::gooseai::User>(Arena*);
template<> ::gooseai::UserPasswordChangeTicket* Arena::CreateMaybeMessage<::gooseai::UserPasswordChangeTicket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gooseai {

enum OrganizationRole : int {
  MEMBER = 0,
  ACCOUNTANT = 1,
  OWNER = 2,
  OrganizationRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrganizationRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrganizationRole_IsValid(int value);
constexpr OrganizationRole OrganizationRole_MIN = MEMBER;
constexpr OrganizationRole OrganizationRole_MAX = OWNER;
constexpr int OrganizationRole_ARRAYSIZE = OrganizationRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrganizationRole_descriptor();
template<typename T>
inline const std::string& OrganizationRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrganizationRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrganizationRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrganizationRole_descriptor(), enum_t_value);
}
inline bool OrganizationRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrganizationRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrganizationRole>(
    OrganizationRole_descriptor(), name, value);
}
// ===================================================================

class OrganizationMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.OrganizationMember) */ {
 public:
  inline OrganizationMember() : OrganizationMember(nullptr) {}
  ~OrganizationMember() override;
  explicit PROTOBUF_CONSTEXPR OrganizationMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationMember(const OrganizationMember& from);
  OrganizationMember(OrganizationMember&& from) noexcept
    : OrganizationMember() {
    *this = ::std::move(from);
  }

  inline OrganizationMember& operator=(const OrganizationMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationMember& operator=(OrganizationMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationMember* internal_default_instance() {
    return reinterpret_cast<const OrganizationMember*>(
               &_OrganizationMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OrganizationMember& a, OrganizationMember& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrganizationMember& from) {
    OrganizationMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.OrganizationMember";
  }
  protected:
  explicit OrganizationMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationFieldNumber = 1,
    kUserFieldNumber = 2,
    kRoleFieldNumber = 3,
    kIsDefaultFieldNumber = 4,
  };
  // .gooseai.Organization organization = 1 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::gooseai::Organization& organization() const;
  PROTOBUF_NODISCARD ::gooseai::Organization* release_organization();
  ::gooseai::Organization* mutable_organization();
  void set_allocated_organization(::gooseai::Organization* organization);
  private:
  const ::gooseai::Organization& _internal_organization() const;
  ::gooseai::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::gooseai::Organization* organization);
  ::gooseai::Organization* unsafe_arena_release_organization();

  // optional .gooseai.User user = 2 [json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::gooseai::User& user() const;
  PROTOBUF_NODISCARD ::gooseai::User* release_user();
  ::gooseai::User* mutable_user();
  void set_allocated_user(::gooseai::User* user);
  private:
  const ::gooseai::User& _internal_user() const;
  ::gooseai::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::gooseai::User* user);
  ::gooseai::User* unsafe_arena_release_user();

  // .gooseai.OrganizationRole role = 3 [json_name = "role"];
  void clear_role();
  ::gooseai::OrganizationRole role() const;
  void set_role(::gooseai::OrganizationRole value);
  private:
  ::gooseai::OrganizationRole _internal_role() const;
  void _internal_set_role(::gooseai::OrganizationRole value);
  public:

  // bool is_default = 4 [json_name = "isDefault"];
  void clear_is_default();
  bool is_default() const;
  void set_is_default(bool value);
  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.OrganizationMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::gooseai::Organization* organization_;
    ::gooseai::User* user_;
    int role_;
    bool is_default_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class OrganizationGrant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.OrganizationGrant) */ {
 public:
  inline OrganizationGrant() : OrganizationGrant(nullptr) {}
  ~OrganizationGrant() override;
  explicit PROTOBUF_CONSTEXPR OrganizationGrant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationGrant(const OrganizationGrant& from);
  OrganizationGrant(OrganizationGrant&& from) noexcept
    : OrganizationGrant() {
    *this = ::std::move(from);
  }

  inline OrganizationGrant& operator=(const OrganizationGrant& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationGrant& operator=(OrganizationGrant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationGrant& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationGrant* internal_default_instance() {
    return reinterpret_cast<const OrganizationGrant*>(
               &_OrganizationGrant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrganizationGrant& a, OrganizationGrant& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationGrant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationGrant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationGrant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationGrant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationGrant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrganizationGrant& from) {
    OrganizationGrant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationGrant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.OrganizationGrant";
  }
  protected:
  explicit OrganizationGrant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountGrantedFieldNumber = 1,
    kAmountUsedFieldNumber = 2,
    kExpiresAtFieldNumber = 3,
    kGrantedAtFieldNumber = 4,
  };
  // double amount_granted = 1 [json_name = "amountGranted"];
  void clear_amount_granted();
  double amount_granted() const;
  void set_amount_granted(double value);
  private:
  double _internal_amount_granted() const;
  void _internal_set_amount_granted(double value);
  public:

  // double amount_used = 2 [json_name = "amountUsed"];
  void clear_amount_used();
  double amount_used() const;
  void set_amount_used(double value);
  private:
  double _internal_amount_used() const;
  void _internal_set_amount_used(double value);
  public:

  // uint64 expires_at = 3 [json_name = "expiresAt"];
  void clear_expires_at();
  uint64_t expires_at() const;
  void set_expires_at(uint64_t value);
  private:
  uint64_t _internal_expires_at() const;
  void _internal_set_expires_at(uint64_t value);
  public:

  // uint64 granted_at = 4 [json_name = "grantedAt"];
  void clear_granted_at();
  uint64_t granted_at() const;
  void set_granted_at(uint64_t value);
  private:
  uint64_t _internal_granted_at() const;
  void _internal_set_granted_at(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.OrganizationGrant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double amount_granted_;
    double amount_used_;
    uint64_t expires_at_;
    uint64_t granted_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class OrganizationPaymentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.OrganizationPaymentInfo) */ {
 public:
  inline OrganizationPaymentInfo() : OrganizationPaymentInfo(nullptr) {}
  ~OrganizationPaymentInfo() override;
  explicit PROTOBUF_CONSTEXPR OrganizationPaymentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationPaymentInfo(const OrganizationPaymentInfo& from);
  OrganizationPaymentInfo(OrganizationPaymentInfo&& from) noexcept
    : OrganizationPaymentInfo() {
    *this = ::std::move(from);
  }

  inline OrganizationPaymentInfo& operator=(const OrganizationPaymentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationPaymentInfo& operator=(OrganizationPaymentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationPaymentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationPaymentInfo* internal_default_instance() {
    return reinterpret_cast<const OrganizationPaymentInfo*>(
               &_OrganizationPaymentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrganizationPaymentInfo& a, OrganizationPaymentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationPaymentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationPaymentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationPaymentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationPaymentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationPaymentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrganizationPaymentInfo& from) {
    OrganizationPaymentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationPaymentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.OrganizationPaymentInfo";
  }
  protected:
  explicit OrganizationPaymentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantsFieldNumber = 2,
    kBalanceFieldNumber = 1,
  };
  // repeated .gooseai.OrganizationGrant grants = 2 [json_name = "grants"];
  int grants_size() const;
  private:
  int _internal_grants_size() const;
  public:
  void clear_grants();
  ::gooseai::OrganizationGrant* mutable_grants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationGrant >*
      mutable_grants();
  private:
  const ::gooseai::OrganizationGrant& _internal_grants(int index) const;
  ::gooseai::OrganizationGrant* _internal_add_grants();
  public:
  const ::gooseai::OrganizationGrant& grants(int index) const;
  ::gooseai::OrganizationGrant* add_grants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationGrant >&
      grants() const;

  // double balance = 1 [json_name = "balance"];
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.OrganizationPaymentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationGrant > grants_;
    double balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class OrganizationAutoCharge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.OrganizationAutoCharge) */ {
 public:
  inline OrganizationAutoCharge() : OrganizationAutoCharge(nullptr) {}
  ~OrganizationAutoCharge() override;
  explicit PROTOBUF_CONSTEXPR OrganizationAutoCharge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrganizationAutoCharge(const OrganizationAutoCharge& from);
  OrganizationAutoCharge(OrganizationAutoCharge&& from) noexcept
    : OrganizationAutoCharge() {
    *this = ::std::move(from);
  }

  inline OrganizationAutoCharge& operator=(const OrganizationAutoCharge& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrganizationAutoCharge& operator=(OrganizationAutoCharge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrganizationAutoCharge& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrganizationAutoCharge* internal_default_instance() {
    return reinterpret_cast<const OrganizationAutoCharge*>(
               &_OrganizationAutoCharge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OrganizationAutoCharge& a, OrganizationAutoCharge& b) {
    a.Swap(&b);
  }
  inline void Swap(OrganizationAutoCharge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrganizationAutoCharge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrganizationAutoCharge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrganizationAutoCharge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrganizationAutoCharge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrganizationAutoCharge& from) {
    OrganizationAutoCharge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrganizationAutoCharge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.OrganizationAutoCharge";
  }
  protected:
  explicit OrganizationAutoCharge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kEnabledFieldNumber = 1,
  };
  // string id = 2 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 created_at = 3 [json_name = "createdAt"];
  void clear_created_at();
  uint64_t created_at() const;
  void set_created_at(uint64_t value);
  private:
  uint64_t _internal_created_at() const;
  void _internal_set_created_at(uint64_t value);
  public:

  // bool enabled = 1 [json_name = "enabled"];
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.OrganizationAutoCharge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t created_at_;
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class Organization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Organization) */ {
 public:
  inline Organization() : Organization(nullptr) {}
  ~Organization() override;
  explicit PROTOBUF_CONSTEXPR Organization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Organization(const Organization& from);
  Organization(Organization&& from) noexcept
    : Organization() {
    *this = ::std::move(from);
  }

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Organization& operator=(Organization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Organization& default_instance() {
    return *internal_default_instance();
  }
  static inline const Organization* internal_default_instance() {
    return reinterpret_cast<const Organization*>(
               &_Organization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Organization& a, Organization& b) {
    a.Swap(&b);
  }
  inline void Swap(Organization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Organization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Organization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Organization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Organization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Organization& from) {
    Organization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Organization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Organization";
  }
  protected:
  explicit Organization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 4,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kStripeCustomerIdFieldNumber = 6,
    kPaymentInfoFieldNumber = 5,
    kAutoChargeFieldNumber = 7,
  };
  // repeated .gooseai.OrganizationMember members = 4 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::gooseai::OrganizationMember* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >*
      mutable_members();
  private:
  const ::gooseai::OrganizationMember& _internal_members(int index) const;
  ::gooseai::OrganizationMember* _internal_add_members();
  public:
  const ::gooseai::OrganizationMember& members(int index) const;
  ::gooseai::OrganizationMember* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >&
      members() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string stripe_customer_id = 6 [json_name = "stripeCustomerId"];
  bool has_stripe_customer_id() const;
  private:
  bool _internal_has_stripe_customer_id() const;
  public:
  void clear_stripe_customer_id();
  const std::string& stripe_customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stripe_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stripe_customer_id();
  PROTOBUF_NODISCARD std::string* release_stripe_customer_id();
  void set_allocated_stripe_customer_id(std::string* stripe_customer_id);
  private:
  const std::string& _internal_stripe_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stripe_customer_id(const std::string& value);
  std::string* _internal_mutable_stripe_customer_id();
  public:

  // optional .gooseai.OrganizationPaymentInfo payment_info = 5 [json_name = "paymentInfo"];
  bool has_payment_info() const;
  private:
  bool _internal_has_payment_info() const;
  public:
  void clear_payment_info();
  const ::gooseai::OrganizationPaymentInfo& payment_info() const;
  PROTOBUF_NODISCARD ::gooseai::OrganizationPaymentInfo* release_payment_info();
  ::gooseai::OrganizationPaymentInfo* mutable_payment_info();
  void set_allocated_payment_info(::gooseai::OrganizationPaymentInfo* payment_info);
  private:
  const ::gooseai::OrganizationPaymentInfo& _internal_payment_info() const;
  ::gooseai::OrganizationPaymentInfo* _internal_mutable_payment_info();
  public:
  void unsafe_arena_set_allocated_payment_info(
      ::gooseai::OrganizationPaymentInfo* payment_info);
  ::gooseai::OrganizationPaymentInfo* unsafe_arena_release_payment_info();

  // optional .gooseai.OrganizationAutoCharge auto_charge = 7 [json_name = "autoCharge"];
  bool has_auto_charge() const;
  private:
  bool _internal_has_auto_charge() const;
  public:
  void clear_auto_charge();
  const ::gooseai::OrganizationAutoCharge& auto_charge() const;
  PROTOBUF_NODISCARD ::gooseai::OrganizationAutoCharge* release_auto_charge();
  ::gooseai::OrganizationAutoCharge* mutable_auto_charge();
  void set_allocated_auto_charge(::gooseai::OrganizationAutoCharge* auto_charge);
  private:
  const ::gooseai::OrganizationAutoCharge& _internal_auto_charge() const;
  ::gooseai::OrganizationAutoCharge* _internal_mutable_auto_charge();
  public:
  void unsafe_arena_set_allocated_auto_charge(
      ::gooseai::OrganizationAutoCharge* auto_charge);
  ::gooseai::OrganizationAutoCharge* unsafe_arena_release_auto_charge();

  // @@protoc_insertion_point(class_scope:gooseai.Organization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember > members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stripe_customer_id_;
    ::gooseai::OrganizationPaymentInfo* payment_info_;
    ::gooseai::OrganizationAutoCharge* auto_charge_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class APIKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.APIKey) */ {
 public:
  inline APIKey() : APIKey(nullptr) {}
  ~APIKey() override;
  explicit PROTOBUF_CONSTEXPR APIKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKey(const APIKey& from);
  APIKey(APIKey&& from) noexcept
    : APIKey() {
    *this = ::std::move(from);
  }

  inline APIKey& operator=(const APIKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKey& operator=(APIKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKey* internal_default_instance() {
    return reinterpret_cast<const APIKey*>(
               &_APIKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(APIKey& a, APIKey& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIKey& from) {
    APIKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.APIKey";
  }
  protected:
  explicit APIKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kCreatedAtFieldNumber = 3,
    kIsSecretFieldNumber = 2,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 created_at = 3 [json_name = "createdAt"];
  void clear_created_at();
  uint64_t created_at() const;
  void set_created_at(uint64_t value);
  private:
  uint64_t _internal_created_at() const;
  void _internal_set_created_at(uint64_t value);
  public:

  // bool is_secret = 2 [json_name = "isSecret"];
  void clear_is_secret();
  bool is_secret() const;
  void set_is_secret(bool value);
  private:
  bool _internal_is_secret() const;
  void _internal_set_is_secret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.APIKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t created_at_;
    bool is_secret_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationsFieldNumber = 5,
    kApiKeysFieldNumber = 7,
    kIdFieldNumber = 1,
    kAuthIdFieldNumber = 2,
    kProfilePictureFieldNumber = 3,
    kEmailFieldNumber = 4,
    kCreatedAtFieldNumber = 8,
    kEmailVerifiedFieldNumber = 9,
  };
  // repeated .gooseai.OrganizationMember organizations = 5 [json_name = "organizations"];
  int organizations_size() const;
  private:
  int _internal_organizations_size() const;
  public:
  void clear_organizations();
  ::gooseai::OrganizationMember* mutable_organizations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >*
      mutable_organizations();
  private:
  const ::gooseai::OrganizationMember& _internal_organizations(int index) const;
  ::gooseai::OrganizationMember* _internal_add_organizations();
  public:
  const ::gooseai::OrganizationMember& organizations(int index) const;
  ::gooseai::OrganizationMember* add_organizations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >&
      organizations() const;

  // repeated .gooseai.APIKey api_keys = 7 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::gooseai::APIKey* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::APIKey >*
      mutable_api_keys();
  private:
  const ::gooseai::APIKey& _internal_api_keys(int index) const;
  ::gooseai::APIKey* _internal_add_api_keys();
  public:
  const ::gooseai::APIKey& api_keys(int index) const;
  ::gooseai::APIKey* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::APIKey >&
      api_keys() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string auth_id = 2 [json_name = "authId"];
  bool has_auth_id() const;
  private:
  bool _internal_has_auth_id() const;
  public:
  void clear_auth_id();
  const std::string& auth_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_id();
  PROTOBUF_NODISCARD std::string* release_auth_id();
  void set_allocated_auth_id(std::string* auth_id);
  private:
  const std::string& _internal_auth_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_id(const std::string& value);
  std::string* _internal_mutable_auth_id();
  public:

  // string profile_picture = 3 [json_name = "profilePicture"];
  void clear_profile_picture();
  const std::string& profile_picture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profile_picture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profile_picture();
  PROTOBUF_NODISCARD std::string* release_profile_picture();
  void set_allocated_profile_picture(std::string* profile_picture);
  private:
  const std::string& _internal_profile_picture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile_picture(const std::string& value);
  std::string* _internal_mutable_profile_picture();
  public:

  // string email = 4 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // uint64 created_at = 8 [json_name = "createdAt"];
  void clear_created_at();
  uint64_t created_at() const;
  void set_created_at(uint64_t value);
  private:
  uint64_t _internal_created_at() const;
  void _internal_set_created_at(uint64_t value);
  public:

  // optional bool email_verified = 9 [json_name = "emailVerified"];
  bool has_email_verified() const;
  private:
  bool _internal_has_email_verified() const;
  public:
  void clear_email_verified();
  bool email_verified() const;
  void set_email_verified(bool value);
  private:
  bool _internal_email_verified() const;
  void _internal_set_email_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember > organizations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::APIKey > api_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_picture_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    uint64_t created_at_;
    bool email_verified_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class CostData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.CostData) */ {
 public:
  inline CostData() : CostData(nullptr) {}
  ~CostData() override;
  explicit PROTOBUF_CONSTEXPR CostData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CostData(const CostData& from);
  CostData(CostData&& from) noexcept
    : CostData() {
    *this = ::std::move(from);
  }

  inline CostData& operator=(const CostData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostData& operator=(CostData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostData* internal_default_instance() {
    return reinterpret_cast<const CostData*>(
               &_CostData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CostData& a, CostData& b) {
    a.Swap(&b);
  }
  inline void Swap(CostData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CostData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CostData& from) {
    CostData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.CostData";
  }
  protected:
  explicit CostData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountCreditsFieldNumber = 2,
    kAmountTokensFieldNumber = 1,
  };
  // double amount_credits = 2 [json_name = "amountCredits"];
  void clear_amount_credits();
  double amount_credits() const;
  void set_amount_credits(double value);
  private:
  double _internal_amount_credits() const;
  void _internal_set_amount_credits(double value);
  public:

  // uint32 amount_tokens = 1 [json_name = "amountTokens"];
  void clear_amount_tokens();
  uint32_t amount_tokens() const;
  void set_amount_tokens(uint32_t value);
  private:
  uint32_t _internal_amount_tokens() const;
  void _internal_set_amount_tokens(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.CostData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double amount_credits_;
    uint32_t amount_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class UsageMetric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.UsageMetric) */ {
 public:
  inline UsageMetric() : UsageMetric(nullptr) {}
  ~UsageMetric() override;
  explicit PROTOBUF_CONSTEXPR UsageMetric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsageMetric(const UsageMetric& from);
  UsageMetric(UsageMetric&& from) noexcept
    : UsageMetric() {
    *this = ::std::move(from);
  }

  inline UsageMetric& operator=(const UsageMetric& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsageMetric& operator=(UsageMetric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsageMetric& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsageMetric* internal_default_instance() {
    return reinterpret_cast<const UsageMetric*>(
               &_UsageMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UsageMetric& a, UsageMetric& b) {
    a.Swap(&b);
  }
  inline void Swap(UsageMetric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsageMetric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsageMetric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsageMetric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsageMetric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsageMetric& from) {
    UsageMetric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsageMetric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.UsageMetric";
  }
  protected:
  explicit UsageMetric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationFieldNumber = 1,
    kEngineFieldNumber = 2,
    kUserFieldNumber = 5,
    kInputCostFieldNumber = 3,
    kOutputCostFieldNumber = 4,
    kAggregationTimestampFieldNumber = 6,
  };
  // string operation = 1 [json_name = "operation"];
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // string engine = 2 [json_name = "engine"];
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // optional string user = 5 [json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // .gooseai.CostData input_cost = 3 [json_name = "inputCost"];
  bool has_input_cost() const;
  private:
  bool _internal_has_input_cost() const;
  public:
  void clear_input_cost();
  const ::gooseai::CostData& input_cost() const;
  PROTOBUF_NODISCARD ::gooseai::CostData* release_input_cost();
  ::gooseai::CostData* mutable_input_cost();
  void set_allocated_input_cost(::gooseai::CostData* input_cost);
  private:
  const ::gooseai::CostData& _internal_input_cost() const;
  ::gooseai::CostData* _internal_mutable_input_cost();
  public:
  void unsafe_arena_set_allocated_input_cost(
      ::gooseai::CostData* input_cost);
  ::gooseai::CostData* unsafe_arena_release_input_cost();

  // .gooseai.CostData output_cost = 4 [json_name = "outputCost"];
  bool has_output_cost() const;
  private:
  bool _internal_has_output_cost() const;
  public:
  void clear_output_cost();
  const ::gooseai::CostData& output_cost() const;
  PROTOBUF_NODISCARD ::gooseai::CostData* release_output_cost();
  ::gooseai::CostData* mutable_output_cost();
  void set_allocated_output_cost(::gooseai::CostData* output_cost);
  private:
  const ::gooseai::CostData& _internal_output_cost() const;
  ::gooseai::CostData* _internal_mutable_output_cost();
  public:
  void unsafe_arena_set_allocated_output_cost(
      ::gooseai::CostData* output_cost);
  ::gooseai::CostData* unsafe_arena_release_output_cost();

  // uint64 aggregation_timestamp = 6 [json_name = "aggregationTimestamp"];
  void clear_aggregation_timestamp();
  uint64_t aggregation_timestamp() const;
  void set_aggregation_timestamp(uint64_t value);
  private:
  uint64_t _internal_aggregation_timestamp() const;
  void _internal_set_aggregation_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.UsageMetric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::gooseai::CostData* input_cost_;
    ::gooseai::CostData* output_cost_;
    uint64_t aggregation_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class CostTotal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.CostTotal) */ {
 public:
  inline CostTotal() : CostTotal(nullptr) {}
  ~CostTotal() override;
  explicit PROTOBUF_CONSTEXPR CostTotal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CostTotal(const CostTotal& from);
  CostTotal(CostTotal&& from) noexcept
    : CostTotal() {
    *this = ::std::move(from);
  }

  inline CostTotal& operator=(const CostTotal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostTotal& operator=(CostTotal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostTotal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostTotal* internal_default_instance() {
    return reinterpret_cast<const CostTotal*>(
               &_CostTotal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CostTotal& a, CostTotal& b) {
    a.Swap(&b);
  }
  inline void Swap(CostTotal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostTotal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostTotal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostTotal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CostTotal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CostTotal& from) {
    CostTotal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostTotal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.CostTotal";
  }
  protected:
  explicit CostTotal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountCreditsFieldNumber = 2,
    kAmountTokensFieldNumber = 1,
  };
  // double amount_credits = 2 [json_name = "amountCredits"];
  void clear_amount_credits();
  double amount_credits() const;
  void set_amount_credits(double value);
  private:
  double _internal_amount_credits() const;
  void _internal_set_amount_credits(double value);
  public:

  // uint32 amount_tokens = 1 [json_name = "amountTokens"];
  void clear_amount_tokens();
  uint32_t amount_tokens() const;
  void set_amount_tokens(uint32_t value);
  private:
  uint32_t _internal_amount_tokens() const;
  void _internal_set_amount_tokens(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.CostTotal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double amount_credits_;
    uint32_t amount_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class TotalMetricsData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.TotalMetricsData) */ {
 public:
  inline TotalMetricsData() : TotalMetricsData(nullptr) {}
  ~TotalMetricsData() override;
  explicit PROTOBUF_CONSTEXPR TotalMetricsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TotalMetricsData(const TotalMetricsData& from);
  TotalMetricsData(TotalMetricsData&& from) noexcept
    : TotalMetricsData() {
    *this = ::std::move(from);
  }

  inline TotalMetricsData& operator=(const TotalMetricsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TotalMetricsData& operator=(TotalMetricsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TotalMetricsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TotalMetricsData* internal_default_instance() {
    return reinterpret_cast<const TotalMetricsData*>(
               &_TotalMetricsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TotalMetricsData& a, TotalMetricsData& b) {
    a.Swap(&b);
  }
  inline void Swap(TotalMetricsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TotalMetricsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TotalMetricsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TotalMetricsData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TotalMetricsData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TotalMetricsData& from) {
    TotalMetricsData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TotalMetricsData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.TotalMetricsData";
  }
  protected:
  explicit TotalMetricsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputTotalFieldNumber = 1,
    kOutputTotalFieldNumber = 2,
  };
  // .gooseai.CostTotal input_total = 1 [json_name = "inputTotal"];
  bool has_input_total() const;
  private:
  bool _internal_has_input_total() const;
  public:
  void clear_input_total();
  const ::gooseai::CostTotal& input_total() const;
  PROTOBUF_NODISCARD ::gooseai::CostTotal* release_input_total();
  ::gooseai::CostTotal* mutable_input_total();
  void set_allocated_input_total(::gooseai::CostTotal* input_total);
  private:
  const ::gooseai::CostTotal& _internal_input_total() const;
  ::gooseai::CostTotal* _internal_mutable_input_total();
  public:
  void unsafe_arena_set_allocated_input_total(
      ::gooseai::CostTotal* input_total);
  ::gooseai::CostTotal* unsafe_arena_release_input_total();

  // .gooseai.CostTotal output_total = 2 [json_name = "outputTotal"];
  bool has_output_total() const;
  private:
  bool _internal_has_output_total() const;
  public:
  void clear_output_total();
  const ::gooseai::CostTotal& output_total() const;
  PROTOBUF_NODISCARD ::gooseai::CostTotal* release_output_total();
  ::gooseai::CostTotal* mutable_output_total();
  void set_allocated_output_total(::gooseai::CostTotal* output_total);
  private:
  const ::gooseai::CostTotal& _internal_output_total() const;
  ::gooseai::CostTotal* _internal_mutable_output_total();
  public:
  void unsafe_arena_set_allocated_output_total(
      ::gooseai::CostTotal* output_total);
  ::gooseai::CostTotal* unsafe_arena_release_output_total();

  // @@protoc_insertion_point(class_scope:gooseai.TotalMetricsData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::gooseai::CostTotal* input_total_;
    ::gooseai::CostTotal* output_total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class Metrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Metrics) */ {
 public:
  inline Metrics() : Metrics(nullptr) {}
  ~Metrics() override;
  explicit PROTOBUF_CONSTEXPR Metrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metrics(const Metrics& from);
  Metrics(Metrics&& from) noexcept
    : Metrics() {
    *this = ::std::move(from);
  }

  inline Metrics& operator=(const Metrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metrics& operator=(Metrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metrics* internal_default_instance() {
    return reinterpret_cast<const Metrics*>(
               &_Metrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Metrics& a, Metrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Metrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metrics& from) {
    Metrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Metrics";
  }
  protected:
  explicit Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // repeated .gooseai.UsageMetric metrics = 1 [json_name = "metrics"];
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::gooseai::UsageMetric* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::UsageMetric >*
      mutable_metrics();
  private:
  const ::gooseai::UsageMetric& _internal_metrics(int index) const;
  ::gooseai::UsageMetric* _internal_add_metrics();
  public:
  const ::gooseai::UsageMetric& metrics(int index) const;
  ::gooseai::UsageMetric* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::UsageMetric >&
      metrics() const;

  // .gooseai.TotalMetricsData total = 2 [json_name = "total"];
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  const ::gooseai::TotalMetricsData& total() const;
  PROTOBUF_NODISCARD ::gooseai::TotalMetricsData* release_total();
  ::gooseai::TotalMetricsData* mutable_total();
  void set_allocated_total(::gooseai::TotalMetricsData* total);
  private:
  const ::gooseai::TotalMetricsData& _internal_total() const;
  ::gooseai::TotalMetricsData* _internal_mutable_total();
  public:
  void unsafe_arena_set_allocated_total(
      ::gooseai::TotalMetricsData* total);
  ::gooseai::TotalMetricsData* unsafe_arena_release_total();

  // @@protoc_insertion_point(class_scope:gooseai.Metrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::UsageMetric > metrics_;
    ::gooseai::TotalMetricsData* total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class EmptyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:gooseai.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyRequest(const EmptyRequest& from);
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gooseai.EmptyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GetOrganizationRequest) */ {
 public:
  inline GetOrganizationRequest() : GetOrganizationRequest(nullptr) {}
  ~GetOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationRequest(const GetOrganizationRequest& from);
  GetOrganizationRequest(GetOrganizationRequest&& from) noexcept
    : GetOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationRequest& operator=(const GetOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationRequest& operator=(GetOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationRequest*>(
               &_GetOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetOrganizationRequest& a, GetOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOrganizationRequest& from) {
    GetOrganizationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GetOrganizationRequest";
  }
  protected:
  explicit GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GetOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class GetMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GetMetricsRequest) */ {
 public:
  inline GetMetricsRequest() : GetMetricsRequest(nullptr) {}
  ~GetMetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMetricsRequest(const GetMetricsRequest& from);
  GetMetricsRequest(GetMetricsRequest&& from) noexcept
    : GetMetricsRequest() {
    *this = ::std::move(from);
  }

  inline GetMetricsRequest& operator=(const GetMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMetricsRequest& operator=(GetMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const GetMetricsRequest*>(
               &_GetMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetMetricsRequest& a, GetMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMetricsRequest& from) {
    GetMetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GetMetricsRequest";
  }
  protected:
  explicit GetMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kRangeFromFieldNumber = 3,
    kRangeToFieldNumber = 4,
    kIncludePerRequestMetricsFieldNumber = 5,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // optional string user_id = 2 [json_name = "userId"];
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // uint64 range_from = 3 [json_name = "rangeFrom"];
  void clear_range_from();
  uint64_t range_from() const;
  void set_range_from(uint64_t value);
  private:
  uint64_t _internal_range_from() const;
  void _internal_set_range_from(uint64_t value);
  public:

  // uint64 range_to = 4 [json_name = "rangeTo"];
  void clear_range_to();
  uint64_t range_to() const;
  void set_range_to(uint64_t value);
  private:
  uint64_t _internal_range_to() const;
  void _internal_set_range_to(uint64_t value);
  public:

  // bool include_per_request_metrics = 5 [json_name = "includePerRequestMetrics"];
  void clear_include_per_request_metrics();
  bool include_per_request_metrics() const;
  void set_include_per_request_metrics(bool value);
  private:
  bool _internal_include_per_request_metrics() const;
  void _internal_set_include_per_request_metrics(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GetMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    uint64_t range_from_;
    uint64_t range_to_;
    bool include_per_request_metrics_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class APIKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.APIKeyRequest) */ {
 public:
  inline APIKeyRequest() : APIKeyRequest(nullptr) {}
  ~APIKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR APIKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKeyRequest(const APIKeyRequest& from);
  APIKeyRequest(APIKeyRequest&& from) noexcept
    : APIKeyRequest() {
    *this = ::std::move(from);
  }

  inline APIKeyRequest& operator=(const APIKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKeyRequest& operator=(APIKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKeyRequest* internal_default_instance() {
    return reinterpret_cast<const APIKeyRequest*>(
               &_APIKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(APIKeyRequest& a, APIKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIKeyRequest& from) {
    APIKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.APIKeyRequest";
  }
  protected:
  explicit APIKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSecretFieldNumber = 1,
  };
  // bool is_secret = 1 [json_name = "isSecret"];
  void clear_is_secret();
  bool is_secret() const;
  void set_is_secret(bool value);
  private:
  bool _internal_is_secret() const;
  void _internal_set_is_secret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.APIKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_secret_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class APIKeyFindRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.APIKeyFindRequest) */ {
 public:
  inline APIKeyFindRequest() : APIKeyFindRequest(nullptr) {}
  ~APIKeyFindRequest() override;
  explicit PROTOBUF_CONSTEXPR APIKeyFindRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIKeyFindRequest(const APIKeyFindRequest& from);
  APIKeyFindRequest(APIKeyFindRequest&& from) noexcept
    : APIKeyFindRequest() {
    *this = ::std::move(from);
  }

  inline APIKeyFindRequest& operator=(const APIKeyFindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIKeyFindRequest& operator=(APIKeyFindRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIKeyFindRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIKeyFindRequest* internal_default_instance() {
    return reinterpret_cast<const APIKeyFindRequest*>(
               &_APIKeyFindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(APIKeyFindRequest& a, APIKeyFindRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(APIKeyFindRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIKeyFindRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIKeyFindRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIKeyFindRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIKeyFindRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIKeyFindRequest& from) {
    APIKeyFindRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIKeyFindRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.APIKeyFindRequest";
  }
  protected:
  explicit APIKeyFindRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.APIKeyFindRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class UpdateDefaultOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.UpdateDefaultOrganizationRequest) */ {
 public:
  inline UpdateDefaultOrganizationRequest() : UpdateDefaultOrganizationRequest(nullptr) {}
  ~UpdateDefaultOrganizationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateDefaultOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDefaultOrganizationRequest(const UpdateDefaultOrganizationRequest& from);
  UpdateDefaultOrganizationRequest(UpdateDefaultOrganizationRequest&& from) noexcept
    : UpdateDefaultOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateDefaultOrganizationRequest& operator=(const UpdateDefaultOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDefaultOrganizationRequest& operator=(UpdateDefaultOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDefaultOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDefaultOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateDefaultOrganizationRequest*>(
               &_UpdateDefaultOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateDefaultOrganizationRequest& a, UpdateDefaultOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDefaultOrganizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDefaultOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDefaultOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDefaultOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDefaultOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDefaultOrganizationRequest& from) {
    UpdateDefaultOrganizationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDefaultOrganizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.UpdateDefaultOrganizationRequest";
  }
  protected:
  explicit UpdateDefaultOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.UpdateDefaultOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class ClientSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ClientSettings) */ {
 public:
  inline ClientSettings() : ClientSettings(nullptr) {}
  ~ClientSettings() override;
  explicit PROTOBUF_CONSTEXPR ClientSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettings(const ClientSettings& from);
  ClientSettings(ClientSettings&& from) noexcept
    : ClientSettings() {
    *this = ::std::move(from);
  }

  inline ClientSettings& operator=(const ClientSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettings& operator=(ClientSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettings* internal_default_instance() {
    return reinterpret_cast<const ClientSettings*>(
               &_ClientSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ClientSettings& a, ClientSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientSettings& from) {
    ClientSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ClientSettings";
  }
  protected:
  explicit ClientSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // bytes settings = 1 [json_name = "settings"];
  void clear_settings();
  const std::string& settings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_settings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_settings();
  PROTOBUF_NODISCARD std::string* release_settings();
  void set_allocated_settings(std::string* settings);
  private:
  const std::string& _internal_settings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settings(const std::string& value);
  std::string* _internal_mutable_settings();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ClientSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class CreateAutoChargeIntentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.CreateAutoChargeIntentRequest) */ {
 public:
  inline CreateAutoChargeIntentRequest() : CreateAutoChargeIntentRequest(nullptr) {}
  ~CreateAutoChargeIntentRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateAutoChargeIntentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAutoChargeIntentRequest(const CreateAutoChargeIntentRequest& from);
  CreateAutoChargeIntentRequest(CreateAutoChargeIntentRequest&& from) noexcept
    : CreateAutoChargeIntentRequest() {
    *this = ::std::move(from);
  }

  inline CreateAutoChargeIntentRequest& operator=(const CreateAutoChargeIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAutoChargeIntentRequest& operator=(CreateAutoChargeIntentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAutoChargeIntentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAutoChargeIntentRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAutoChargeIntentRequest*>(
               &_CreateAutoChargeIntentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateAutoChargeIntentRequest& a, CreateAutoChargeIntentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAutoChargeIntentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAutoChargeIntentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAutoChargeIntentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAutoChargeIntentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAutoChargeIntentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAutoChargeIntentRequest& from) {
    CreateAutoChargeIntentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAutoChargeIntentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.CreateAutoChargeIntentRequest";
  }
  protected:
  explicit CreateAutoChargeIntentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kMonthlyMaximumFieldNumber = 2,
    kMinimumValueFieldNumber = 3,
    kAmountCreditsFieldNumber = 4,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // uint64 monthly_maximum = 2 [json_name = "monthlyMaximum"];
  void clear_monthly_maximum();
  uint64_t monthly_maximum() const;
  void set_monthly_maximum(uint64_t value);
  private:
  uint64_t _internal_monthly_maximum() const;
  void _internal_set_monthly_maximum(uint64_t value);
  public:

  // uint64 minimum_value = 3 [json_name = "minimumValue"];
  void clear_minimum_value();
  uint64_t minimum_value() const;
  void set_minimum_value(uint64_t value);
  private:
  uint64_t _internal_minimum_value() const;
  void _internal_set_minimum_value(uint64_t value);
  public:

  // uint64 amount_credits = 4 [json_name = "amountCredits"];
  void clear_amount_credits();
  uint64_t amount_credits() const;
  void set_amount_credits(uint64_t value);
  private:
  uint64_t _internal_amount_credits() const;
  void _internal_set_amount_credits(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.CreateAutoChargeIntentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    uint64_t monthly_maximum_;
    uint64_t minimum_value_;
    uint64_t amount_credits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class CreateChargeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.CreateChargeRequest) */ {
 public:
  inline CreateChargeRequest() : CreateChargeRequest(nullptr) {}
  ~CreateChargeRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateChargeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChargeRequest(const CreateChargeRequest& from);
  CreateChargeRequest(CreateChargeRequest&& from) noexcept
    : CreateChargeRequest() {
    *this = ::std::move(from);
  }

  inline CreateChargeRequest& operator=(const CreateChargeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChargeRequest& operator=(CreateChargeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChargeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChargeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateChargeRequest*>(
               &_CreateChargeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateChargeRequest& a, CreateChargeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChargeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChargeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChargeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChargeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChargeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChargeRequest& from) {
    CreateChargeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChargeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.CreateChargeRequest";
  }
  protected:
  explicit CreateChargeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 2,
    kAmountFieldNumber = 1,
  };
  // string organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // uint64 amount = 1 [json_name = "amount"];
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.CreateChargeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    uint64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class GetChargesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GetChargesRequest) */ {
 public:
  inline GetChargesRequest() : GetChargesRequest(nullptr) {}
  ~GetChargesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetChargesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChargesRequest(const GetChargesRequest& from);
  GetChargesRequest(GetChargesRequest&& from) noexcept
    : GetChargesRequest() {
    *this = ::std::move(from);
  }

  inline GetChargesRequest& operator=(const GetChargesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChargesRequest& operator=(GetChargesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChargesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChargesRequest* internal_default_instance() {
    return reinterpret_cast<const GetChargesRequest*>(
               &_GetChargesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetChargesRequest& a, GetChargesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChargesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChargesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChargesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChargesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChargesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetChargesRequest& from) {
    GetChargesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChargesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GetChargesRequest";
  }
  protected:
  explicit GetChargesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kRangeFromFieldNumber = 2,
    kRangeToFieldNumber = 3,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // uint64 range_from = 2 [json_name = "rangeFrom"];
  void clear_range_from();
  uint64_t range_from() const;
  void set_range_from(uint64_t value);
  private:
  uint64_t _internal_range_from() const;
  void _internal_set_range_from(uint64_t value);
  public:

  // uint64 range_to = 3 [json_name = "rangeTo"];
  void clear_range_to();
  uint64_t range_to() const;
  void set_range_to(uint64_t value);
  private:
  uint64_t _internal_range_to() const;
  void _internal_set_range_to(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GetChargesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    uint64_t range_from_;
    uint64_t range_to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class Charge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Charge) */ {
 public:
  inline Charge() : Charge(nullptr) {}
  ~Charge() override;
  explicit PROTOBUF_CONSTEXPR Charge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Charge(const Charge& from);
  Charge(Charge&& from) noexcept
    : Charge() {
    *this = ::std::move(from);
  }

  inline Charge& operator=(const Charge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Charge& operator=(Charge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Charge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Charge* internal_default_instance() {
    return reinterpret_cast<const Charge*>(
               &_Charge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Charge& a, Charge& b) {
    a.Swap(&b);
  }
  inline void Swap(Charge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Charge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Charge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Charge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Charge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Charge& from) {
    Charge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Charge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Charge";
  }
  protected:
  explicit Charge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kReceiptLinkFieldNumber = 3,
    kPaymentLinkFieldNumber = 4,
    kCreatedAtFieldNumber = 5,
    kAmountCreditsFieldNumber = 6,
    kPaidFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string receipt_link = 3 [json_name = "receiptLink"];
  void clear_receipt_link();
  const std::string& receipt_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_link();
  PROTOBUF_NODISCARD std::string* release_receipt_link();
  void set_allocated_receipt_link(std::string* receipt_link);
  private:
  const std::string& _internal_receipt_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_link(const std::string& value);
  std::string* _internal_mutable_receipt_link();
  public:

  // string payment_link = 4 [json_name = "paymentLink"];
  void clear_payment_link();
  const std::string& payment_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_link();
  PROTOBUF_NODISCARD std::string* release_payment_link();
  void set_allocated_payment_link(std::string* payment_link);
  private:
  const std::string& _internal_payment_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_link(const std::string& value);
  std::string* _internal_mutable_payment_link();
  public:

  // uint64 created_at = 5 [json_name = "createdAt"];
  void clear_created_at();
  uint64_t created_at() const;
  void set_created_at(uint64_t value);
  private:
  uint64_t _internal_created_at() const;
  void _internal_set_created_at(uint64_t value);
  public:

  // uint64 amount_credits = 6 [json_name = "amountCredits"];
  void clear_amount_credits();
  uint64_t amount_credits() const;
  void set_amount_credits(uint64_t value);
  private:
  uint64_t _internal_amount_credits() const;
  void _internal_set_amount_credits(uint64_t value);
  public:

  // bool paid = 2 [json_name = "paid"];
  void clear_paid();
  bool paid() const;
  void set_paid(bool value);
  private:
  bool _internal_paid() const;
  void _internal_set_paid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.Charge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_link_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_link_;
    uint64_t created_at_;
    uint64_t amount_credits_;
    bool paid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class Charges final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Charges) */ {
 public:
  inline Charges() : Charges(nullptr) {}
  ~Charges() override;
  explicit PROTOBUF_CONSTEXPR Charges(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Charges(const Charges& from);
  Charges(Charges&& from) noexcept
    : Charges() {
    *this = ::std::move(from);
  }

  inline Charges& operator=(const Charges& from) {
    CopyFrom(from);
    return *this;
  }
  inline Charges& operator=(Charges&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Charges& default_instance() {
    return *internal_default_instance();
  }
  static inline const Charges* internal_default_instance() {
    return reinterpret_cast<const Charges*>(
               &_Charges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Charges& a, Charges& b) {
    a.Swap(&b);
  }
  inline void Swap(Charges* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Charges* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Charges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Charges>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Charges& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Charges& from) {
    Charges::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Charges* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Charges";
  }
  protected:
  explicit Charges(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChargesFieldNumber = 1,
  };
  // repeated .gooseai.Charge charges = 1 [json_name = "charges"];
  int charges_size() const;
  private:
  int _internal_charges_size() const;
  public:
  void clear_charges();
  ::gooseai::Charge* mutable_charges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Charge >*
      mutable_charges();
  private:
  const ::gooseai::Charge& _internal_charges(int index) const;
  ::gooseai::Charge* _internal_add_charges();
  public:
  const ::gooseai::Charge& charges(int index) const;
  ::gooseai::Charge* add_charges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Charge >&
      charges() const;

  // @@protoc_insertion_point(class_scope:gooseai.Charges)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Charge > charges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class GetAutoChargeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GetAutoChargeRequest) */ {
 public:
  inline GetAutoChargeRequest() : GetAutoChargeRequest(nullptr) {}
  ~GetAutoChargeRequest() override;
  explicit PROTOBUF_CONSTEXPR GetAutoChargeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAutoChargeRequest(const GetAutoChargeRequest& from);
  GetAutoChargeRequest(GetAutoChargeRequest&& from) noexcept
    : GetAutoChargeRequest() {
    *this = ::std::move(from);
  }

  inline GetAutoChargeRequest& operator=(const GetAutoChargeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAutoChargeRequest& operator=(GetAutoChargeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAutoChargeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAutoChargeRequest* internal_default_instance() {
    return reinterpret_cast<const GetAutoChargeRequest*>(
               &_GetAutoChargeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetAutoChargeRequest& a, GetAutoChargeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAutoChargeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAutoChargeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAutoChargeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAutoChargeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAutoChargeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAutoChargeRequest& from) {
    GetAutoChargeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAutoChargeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GetAutoChargeRequest";
  }
  protected:
  explicit GetAutoChargeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_NODISCARD std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GetAutoChargeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class AutoChargeIntent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.AutoChargeIntent) */ {
 public:
  inline AutoChargeIntent() : AutoChargeIntent(nullptr) {}
  ~AutoChargeIntent() override;
  explicit PROTOBUF_CONSTEXPR AutoChargeIntent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoChargeIntent(const AutoChargeIntent& from);
  AutoChargeIntent(AutoChargeIntent&& from) noexcept
    : AutoChargeIntent() {
    *this = ::std::move(from);
  }

  inline AutoChargeIntent& operator=(const AutoChargeIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoChargeIntent& operator=(AutoChargeIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoChargeIntent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoChargeIntent* internal_default_instance() {
    return reinterpret_cast<const AutoChargeIntent*>(
               &_AutoChargeIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AutoChargeIntent& a, AutoChargeIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoChargeIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoChargeIntent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoChargeIntent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoChargeIntent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoChargeIntent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AutoChargeIntent& from) {
    AutoChargeIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoChargeIntent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.AutoChargeIntent";
  }
  protected:
  explicit AutoChargeIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPaymentLinkFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kMonthlyMaximumFieldNumber = 4,
    kMinimumValueFieldNumber = 5,
    kAmountCreditsFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string payment_link = 2 [json_name = "paymentLink"];
  void clear_payment_link();
  const std::string& payment_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_link();
  PROTOBUF_NODISCARD std::string* release_payment_link();
  void set_allocated_payment_link(std::string* payment_link);
  private:
  const std::string& _internal_payment_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_link(const std::string& value);
  std::string* _internal_mutable_payment_link();
  public:

  // uint64 created_at = 3 [json_name = "createdAt"];
  void clear_created_at();
  uint64_t created_at() const;
  void set_created_at(uint64_t value);
  private:
  uint64_t _internal_created_at() const;
  void _internal_set_created_at(uint64_t value);
  public:

  // uint64 monthly_maximum = 4 [json_name = "monthlyMaximum"];
  void clear_monthly_maximum();
  uint64_t monthly_maximum() const;
  void set_monthly_maximum(uint64_t value);
  private:
  uint64_t _internal_monthly_maximum() const;
  void _internal_set_monthly_maximum(uint64_t value);
  public:

  // uint64 minimum_value = 5 [json_name = "minimumValue"];
  void clear_minimum_value();
  uint64_t minimum_value() const;
  void set_minimum_value(uint64_t value);
  private:
  uint64_t _internal_minimum_value() const;
  void _internal_set_minimum_value(uint64_t value);
  public:

  // uint64 amount_credits = 6 [json_name = "amountCredits"];
  void clear_amount_credits();
  uint64_t amount_credits() const;
  void set_amount_credits(uint64_t value);
  private:
  uint64_t _internal_amount_credits() const;
  void _internal_set_amount_credits(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.AutoChargeIntent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_link_;
    uint64_t created_at_;
    uint64_t monthly_maximum_;
    uint64_t minimum_value_;
    uint64_t amount_credits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.UpdateUserInfoRequest) */ {
 public:
  inline UpdateUserInfoRequest() : UpdateUserInfoRequest(nullptr) {}
  ~UpdateUserInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateUserInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserInfoRequest(const UpdateUserInfoRequest& from);
  UpdateUserInfoRequest(UpdateUserInfoRequest&& from) noexcept
    : UpdateUserInfoRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserInfoRequest& operator=(const UpdateUserInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserInfoRequest& operator=(UpdateUserInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserInfoRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserInfoRequest*>(
               &_UpdateUserInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UpdateUserInfoRequest& a, UpdateUserInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateUserInfoRequest& from) {
    UpdateUserInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.UpdateUserInfoRequest";
  }
  protected:
  explicit UpdateUserInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // optional string email = 1 [json_name = "email"];
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.UpdateUserInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// -------------------------------------------------------------------

class UserPasswordChangeTicket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.UserPasswordChangeTicket) */ {
 public:
  inline UserPasswordChangeTicket() : UserPasswordChangeTicket(nullptr) {}
  ~UserPasswordChangeTicket() override;
  explicit PROTOBUF_CONSTEXPR UserPasswordChangeTicket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPasswordChangeTicket(const UserPasswordChangeTicket& from);
  UserPasswordChangeTicket(UserPasswordChangeTicket&& from) noexcept
    : UserPasswordChangeTicket() {
    *this = ::std::move(from);
  }

  inline UserPasswordChangeTicket& operator=(const UserPasswordChangeTicket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPasswordChangeTicket& operator=(UserPasswordChangeTicket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPasswordChangeTicket& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPasswordChangeTicket* internal_default_instance() {
    return reinterpret_cast<const UserPasswordChangeTicket*>(
               &_UserPasswordChangeTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UserPasswordChangeTicket& a, UserPasswordChangeTicket& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPasswordChangeTicket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPasswordChangeTicket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPasswordChangeTicket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPasswordChangeTicket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPasswordChangeTicket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserPasswordChangeTicket& from) {
    UserPasswordChangeTicket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPasswordChangeTicket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.UserPasswordChangeTicket";
  }
  protected:
  explicit UserPasswordChangeTicket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // string ticket = 1 [json_name = "ticket"];
  void clear_ticket();
  const std::string& ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket();
  PROTOBUF_NODISCARD std::string* release_ticket();
  void set_allocated_ticket(std::string* ticket);
  private:
  const std::string& _internal_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.UserPasswordChangeTicket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dashboard_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OrganizationMember

// .gooseai.Organization organization = 1 [json_name = "organization"];
inline bool OrganizationMember::_internal_has_organization() const {
  return this != internal_default_instance() && _impl_.organization_ != nullptr;
}
inline bool OrganizationMember::has_organization() const {
  return _internal_has_organization();
}
inline void OrganizationMember::clear_organization() {
  if (GetArenaForAllocation() == nullptr && _impl_.organization_ != nullptr) {
    delete _impl_.organization_;
  }
  _impl_.organization_ = nullptr;
}
inline const ::gooseai::Organization& OrganizationMember::_internal_organization() const {
  const ::gooseai::Organization* p = _impl_.organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::Organization&>(
      ::gooseai::_Organization_default_instance_);
}
inline const ::gooseai::Organization& OrganizationMember::organization() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationMember.organization)
  return _internal_organization();
}
inline void OrganizationMember::unsafe_arena_set_allocated_organization(
    ::gooseai::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.organization_);
  }
  _impl_.organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.OrganizationMember.organization)
}
inline ::gooseai::Organization* OrganizationMember::release_organization() {
  
  ::gooseai::Organization* temp = _impl_.organization_;
  _impl_.organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::Organization* OrganizationMember::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:gooseai.OrganizationMember.organization)
  
  ::gooseai::Organization* temp = _impl_.organization_;
  _impl_.organization_ = nullptr;
  return temp;
}
inline ::gooseai::Organization* OrganizationMember::_internal_mutable_organization() {
  
  if (_impl_.organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::Organization>(GetArenaForAllocation());
    _impl_.organization_ = p;
  }
  return _impl_.organization_;
}
inline ::gooseai::Organization* OrganizationMember::mutable_organization() {
  ::gooseai::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:gooseai.OrganizationMember.organization)
  return _msg;
}
inline void OrganizationMember::set_allocated_organization(::gooseai::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.organization_;
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(organization);
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:gooseai.OrganizationMember.organization)
}

// optional .gooseai.User user = 2 [json_name = "user"];
inline bool OrganizationMember::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline bool OrganizationMember::has_user() const {
  return _internal_has_user();
}
inline void OrganizationMember::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::User& OrganizationMember::_internal_user() const {
  const ::gooseai::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::User&>(
      ::gooseai::_User_default_instance_);
}
inline const ::gooseai::User& OrganizationMember::user() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationMember.user)
  return _internal_user();
}
inline void OrganizationMember::unsafe_arena_set_allocated_user(
    ::gooseai::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.OrganizationMember.user)
}
inline ::gooseai::User* OrganizationMember::release_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::User* OrganizationMember::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:gooseai.OrganizationMember.user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::gooseai::User* OrganizationMember::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::gooseai::User* OrganizationMember::mutable_user() {
  ::gooseai::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:gooseai.OrganizationMember.user)
  return _msg;
}
inline void OrganizationMember::set_allocated_user(::gooseai::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:gooseai.OrganizationMember.user)
}

// .gooseai.OrganizationRole role = 3 [json_name = "role"];
inline void OrganizationMember::clear_role() {
  _impl_.role_ = 0;
}
inline ::gooseai::OrganizationRole OrganizationMember::_internal_role() const {
  return static_cast< ::gooseai::OrganizationRole >(_impl_.role_);
}
inline ::gooseai::OrganizationRole OrganizationMember::role() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationMember.role)
  return _internal_role();
}
inline void OrganizationMember::_internal_set_role(::gooseai::OrganizationRole value) {
  
  _impl_.role_ = value;
}
inline void OrganizationMember::set_role(::gooseai::OrganizationRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationMember.role)
}

// bool is_default = 4 [json_name = "isDefault"];
inline void OrganizationMember::clear_is_default() {
  _impl_.is_default_ = false;
}
inline bool OrganizationMember::_internal_is_default() const {
  return _impl_.is_default_;
}
inline bool OrganizationMember::is_default() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationMember.is_default)
  return _internal_is_default();
}
inline void OrganizationMember::_internal_set_is_default(bool value) {
  
  _impl_.is_default_ = value;
}
inline void OrganizationMember::set_is_default(bool value) {
  _internal_set_is_default(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationMember.is_default)
}

// -------------------------------------------------------------------

// OrganizationGrant

// double amount_granted = 1 [json_name = "amountGranted"];
inline void OrganizationGrant::clear_amount_granted() {
  _impl_.amount_granted_ = 0;
}
inline double OrganizationGrant::_internal_amount_granted() const {
  return _impl_.amount_granted_;
}
inline double OrganizationGrant::amount_granted() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationGrant.amount_granted)
  return _internal_amount_granted();
}
inline void OrganizationGrant::_internal_set_amount_granted(double value) {
  
  _impl_.amount_granted_ = value;
}
inline void OrganizationGrant::set_amount_granted(double value) {
  _internal_set_amount_granted(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationGrant.amount_granted)
}

// double amount_used = 2 [json_name = "amountUsed"];
inline void OrganizationGrant::clear_amount_used() {
  _impl_.amount_used_ = 0;
}
inline double OrganizationGrant::_internal_amount_used() const {
  return _impl_.amount_used_;
}
inline double OrganizationGrant::amount_used() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationGrant.amount_used)
  return _internal_amount_used();
}
inline void OrganizationGrant::_internal_set_amount_used(double value) {
  
  _impl_.amount_used_ = value;
}
inline void OrganizationGrant::set_amount_used(double value) {
  _internal_set_amount_used(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationGrant.amount_used)
}

// uint64 expires_at = 3 [json_name = "expiresAt"];
inline void OrganizationGrant::clear_expires_at() {
  _impl_.expires_at_ = uint64_t{0u};
}
inline uint64_t OrganizationGrant::_internal_expires_at() const {
  return _impl_.expires_at_;
}
inline uint64_t OrganizationGrant::expires_at() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationGrant.expires_at)
  return _internal_expires_at();
}
inline void OrganizationGrant::_internal_set_expires_at(uint64_t value) {
  
  _impl_.expires_at_ = value;
}
inline void OrganizationGrant::set_expires_at(uint64_t value) {
  _internal_set_expires_at(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationGrant.expires_at)
}

// uint64 granted_at = 4 [json_name = "grantedAt"];
inline void OrganizationGrant::clear_granted_at() {
  _impl_.granted_at_ = uint64_t{0u};
}
inline uint64_t OrganizationGrant::_internal_granted_at() const {
  return _impl_.granted_at_;
}
inline uint64_t OrganizationGrant::granted_at() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationGrant.granted_at)
  return _internal_granted_at();
}
inline void OrganizationGrant::_internal_set_granted_at(uint64_t value) {
  
  _impl_.granted_at_ = value;
}
inline void OrganizationGrant::set_granted_at(uint64_t value) {
  _internal_set_granted_at(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationGrant.granted_at)
}

// -------------------------------------------------------------------

// OrganizationPaymentInfo

// double balance = 1 [json_name = "balance"];
inline void OrganizationPaymentInfo::clear_balance() {
  _impl_.balance_ = 0;
}
inline double OrganizationPaymentInfo::_internal_balance() const {
  return _impl_.balance_;
}
inline double OrganizationPaymentInfo::balance() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationPaymentInfo.balance)
  return _internal_balance();
}
inline void OrganizationPaymentInfo::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void OrganizationPaymentInfo::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationPaymentInfo.balance)
}

// repeated .gooseai.OrganizationGrant grants = 2 [json_name = "grants"];
inline int OrganizationPaymentInfo::_internal_grants_size() const {
  return _impl_.grants_.size();
}
inline int OrganizationPaymentInfo::grants_size() const {
  return _internal_grants_size();
}
inline void OrganizationPaymentInfo::clear_grants() {
  _impl_.grants_.Clear();
}
inline ::gooseai::OrganizationGrant* OrganizationPaymentInfo::mutable_grants(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.OrganizationPaymentInfo.grants)
  return _impl_.grants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationGrant >*
OrganizationPaymentInfo::mutable_grants() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.OrganizationPaymentInfo.grants)
  return &_impl_.grants_;
}
inline const ::gooseai::OrganizationGrant& OrganizationPaymentInfo::_internal_grants(int index) const {
  return _impl_.grants_.Get(index);
}
inline const ::gooseai::OrganizationGrant& OrganizationPaymentInfo::grants(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationPaymentInfo.grants)
  return _internal_grants(index);
}
inline ::gooseai::OrganizationGrant* OrganizationPaymentInfo::_internal_add_grants() {
  return _impl_.grants_.Add();
}
inline ::gooseai::OrganizationGrant* OrganizationPaymentInfo::add_grants() {
  ::gooseai::OrganizationGrant* _add = _internal_add_grants();
  // @@protoc_insertion_point(field_add:gooseai.OrganizationPaymentInfo.grants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationGrant >&
OrganizationPaymentInfo::grants() const {
  // @@protoc_insertion_point(field_list:gooseai.OrganizationPaymentInfo.grants)
  return _impl_.grants_;
}

// -------------------------------------------------------------------

// OrganizationAutoCharge

// bool enabled = 1 [json_name = "enabled"];
inline void OrganizationAutoCharge::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool OrganizationAutoCharge::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool OrganizationAutoCharge::enabled() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationAutoCharge.enabled)
  return _internal_enabled();
}
inline void OrganizationAutoCharge::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void OrganizationAutoCharge::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationAutoCharge.enabled)
}

// string id = 2 [json_name = "id"];
inline void OrganizationAutoCharge::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& OrganizationAutoCharge::id() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationAutoCharge.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrganizationAutoCharge::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.OrganizationAutoCharge.id)
}
inline std::string* OrganizationAutoCharge::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.OrganizationAutoCharge.id)
  return _s;
}
inline const std::string& OrganizationAutoCharge::_internal_id() const {
  return _impl_.id_.Get();
}
inline void OrganizationAutoCharge::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrganizationAutoCharge::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* OrganizationAutoCharge::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.OrganizationAutoCharge.id)
  return _impl_.id_.Release();
}
inline void OrganizationAutoCharge::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.OrganizationAutoCharge.id)
}

// uint64 created_at = 3 [json_name = "createdAt"];
inline void OrganizationAutoCharge::clear_created_at() {
  _impl_.created_at_ = uint64_t{0u};
}
inline uint64_t OrganizationAutoCharge::_internal_created_at() const {
  return _impl_.created_at_;
}
inline uint64_t OrganizationAutoCharge::created_at() const {
  // @@protoc_insertion_point(field_get:gooseai.OrganizationAutoCharge.created_at)
  return _internal_created_at();
}
inline void OrganizationAutoCharge::_internal_set_created_at(uint64_t value) {
  
  _impl_.created_at_ = value;
}
inline void OrganizationAutoCharge::set_created_at(uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:gooseai.OrganizationAutoCharge.created_at)
}

// -------------------------------------------------------------------

// Organization

// string id = 1 [json_name = "id"];
inline void Organization::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Organization::id() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Organization.id)
}
inline std::string* Organization::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.id)
  return _s;
}
inline const std::string& Organization::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Organization::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.id)
  return _impl_.id_.Release();
}
inline void Organization::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.id)
}

// string name = 2 [json_name = "name"];
inline void Organization::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Organization::name() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Organization.name)
}
inline std::string* Organization::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.name)
  return _s;
}
inline const std::string& Organization::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Organization::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_name() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.name)
  return _impl_.name_.Release();
}
inline void Organization::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.name)
}

// string description = 3 [json_name = "description"];
inline void Organization::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Organization::description() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Organization.description)
}
inline std::string* Organization::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.description)
  return _s;
}
inline const std::string& Organization::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Organization::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_description() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.description)
  return _impl_.description_.Release();
}
inline void Organization::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.description)
}

// repeated .gooseai.OrganizationMember members = 4 [json_name = "members"];
inline int Organization::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int Organization::members_size() const {
  return _internal_members_size();
}
inline void Organization::clear_members() {
  _impl_.members_.Clear();
}
inline ::gooseai::OrganizationMember* Organization::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >*
Organization::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Organization.members)
  return &_impl_.members_;
}
inline const ::gooseai::OrganizationMember& Organization::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::gooseai::OrganizationMember& Organization::members(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.members)
  return _internal_members(index);
}
inline ::gooseai::OrganizationMember* Organization::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::gooseai::OrganizationMember* Organization::add_members() {
  ::gooseai::OrganizationMember* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:gooseai.Organization.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >&
Organization::members() const {
  // @@protoc_insertion_point(field_list:gooseai.Organization.members)
  return _impl_.members_;
}

// optional .gooseai.OrganizationPaymentInfo payment_info = 5 [json_name = "paymentInfo"];
inline bool Organization::_internal_has_payment_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payment_info_ != nullptr);
  return value;
}
inline bool Organization::has_payment_info() const {
  return _internal_has_payment_info();
}
inline void Organization::clear_payment_info() {
  if (_impl_.payment_info_ != nullptr) _impl_.payment_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gooseai::OrganizationPaymentInfo& Organization::_internal_payment_info() const {
  const ::gooseai::OrganizationPaymentInfo* p = _impl_.payment_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::OrganizationPaymentInfo&>(
      ::gooseai::_OrganizationPaymentInfo_default_instance_);
}
inline const ::gooseai::OrganizationPaymentInfo& Organization::payment_info() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.payment_info)
  return _internal_payment_info();
}
inline void Organization::unsafe_arena_set_allocated_payment_info(
    ::gooseai::OrganizationPaymentInfo* payment_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payment_info_);
  }
  _impl_.payment_info_ = payment_info;
  if (payment_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Organization.payment_info)
}
inline ::gooseai::OrganizationPaymentInfo* Organization::release_payment_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::OrganizationPaymentInfo* temp = _impl_.payment_info_;
  _impl_.payment_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::OrganizationPaymentInfo* Organization::unsafe_arena_release_payment_info() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.payment_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::OrganizationPaymentInfo* temp = _impl_.payment_info_;
  _impl_.payment_info_ = nullptr;
  return temp;
}
inline ::gooseai::OrganizationPaymentInfo* Organization::_internal_mutable_payment_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.payment_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::OrganizationPaymentInfo>(GetArenaForAllocation());
    _impl_.payment_info_ = p;
  }
  return _impl_.payment_info_;
}
inline ::gooseai::OrganizationPaymentInfo* Organization::mutable_payment_info() {
  ::gooseai::OrganizationPaymentInfo* _msg = _internal_mutable_payment_info();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.payment_info)
  return _msg;
}
inline void Organization::set_allocated_payment_info(::gooseai::OrganizationPaymentInfo* payment_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payment_info_;
  }
  if (payment_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payment_info);
    if (message_arena != submessage_arena) {
      payment_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.payment_info_ = payment_info;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.payment_info)
}

// optional string stripe_customer_id = 6 [json_name = "stripeCustomerId"];
inline bool Organization::_internal_has_stripe_customer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Organization::has_stripe_customer_id() const {
  return _internal_has_stripe_customer_id();
}
inline void Organization::clear_stripe_customer_id() {
  _impl_.stripe_customer_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Organization::stripe_customer_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.stripe_customer_id)
  return _internal_stripe_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Organization::set_stripe_customer_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stripe_customer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Organization.stripe_customer_id)
}
inline std::string* Organization::mutable_stripe_customer_id() {
  std::string* _s = _internal_mutable_stripe_customer_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.stripe_customer_id)
  return _s;
}
inline const std::string& Organization::_internal_stripe_customer_id() const {
  return _impl_.stripe_customer_id_.Get();
}
inline void Organization::_internal_set_stripe_customer_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stripe_customer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Organization::_internal_mutable_stripe_customer_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stripe_customer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Organization::release_stripe_customer_id() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.stripe_customer_id)
  if (!_internal_has_stripe_customer_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stripe_customer_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stripe_customer_id_.IsDefault()) {
    _impl_.stripe_customer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Organization::set_allocated_stripe_customer_id(std::string* stripe_customer_id) {
  if (stripe_customer_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stripe_customer_id_.SetAllocated(stripe_customer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stripe_customer_id_.IsDefault()) {
    _impl_.stripe_customer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.stripe_customer_id)
}

// optional .gooseai.OrganizationAutoCharge auto_charge = 7 [json_name = "autoCharge"];
inline bool Organization::_internal_has_auto_charge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_charge_ != nullptr);
  return value;
}
inline bool Organization::has_auto_charge() const {
  return _internal_has_auto_charge();
}
inline void Organization::clear_auto_charge() {
  if (_impl_.auto_charge_ != nullptr) _impl_.auto_charge_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::gooseai::OrganizationAutoCharge& Organization::_internal_auto_charge() const {
  const ::gooseai::OrganizationAutoCharge* p = _impl_.auto_charge_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::OrganizationAutoCharge&>(
      ::gooseai::_OrganizationAutoCharge_default_instance_);
}
inline const ::gooseai::OrganizationAutoCharge& Organization::auto_charge() const {
  // @@protoc_insertion_point(field_get:gooseai.Organization.auto_charge)
  return _internal_auto_charge();
}
inline void Organization::unsafe_arena_set_allocated_auto_charge(
    ::gooseai::OrganizationAutoCharge* auto_charge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_charge_);
  }
  _impl_.auto_charge_ = auto_charge;
  if (auto_charge) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Organization.auto_charge)
}
inline ::gooseai::OrganizationAutoCharge* Organization::release_auto_charge() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gooseai::OrganizationAutoCharge* temp = _impl_.auto_charge_;
  _impl_.auto_charge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::OrganizationAutoCharge* Organization::unsafe_arena_release_auto_charge() {
  // @@protoc_insertion_point(field_release:gooseai.Organization.auto_charge)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gooseai::OrganizationAutoCharge* temp = _impl_.auto_charge_;
  _impl_.auto_charge_ = nullptr;
  return temp;
}
inline ::gooseai::OrganizationAutoCharge* Organization::_internal_mutable_auto_charge() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.auto_charge_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::OrganizationAutoCharge>(GetArenaForAllocation());
    _impl_.auto_charge_ = p;
  }
  return _impl_.auto_charge_;
}
inline ::gooseai::OrganizationAutoCharge* Organization::mutable_auto_charge() {
  ::gooseai::OrganizationAutoCharge* _msg = _internal_mutable_auto_charge();
  // @@protoc_insertion_point(field_mutable:gooseai.Organization.auto_charge)
  return _msg;
}
inline void Organization::set_allocated_auto_charge(::gooseai::OrganizationAutoCharge* auto_charge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_charge_;
  }
  if (auto_charge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_charge);
    if (message_arena != submessage_arena) {
      auto_charge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_charge, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.auto_charge_ = auto_charge;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Organization.auto_charge)
}

// -------------------------------------------------------------------

// APIKey

// string key = 1 [json_name = "key"];
inline void APIKey::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& APIKey::key() const {
  // @@protoc_insertion_point(field_get:gooseai.APIKey.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKey::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.APIKey.key)
}
inline std::string* APIKey::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:gooseai.APIKey.key)
  return _s;
}
inline const std::string& APIKey::_internal_key() const {
  return _impl_.key_.Get();
}
inline void APIKey::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKey::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKey::release_key() {
  // @@protoc_insertion_point(field_release:gooseai.APIKey.key)
  return _impl_.key_.Release();
}
inline void APIKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.APIKey.key)
}

// bool is_secret = 2 [json_name = "isSecret"];
inline void APIKey::clear_is_secret() {
  _impl_.is_secret_ = false;
}
inline bool APIKey::_internal_is_secret() const {
  return _impl_.is_secret_;
}
inline bool APIKey::is_secret() const {
  // @@protoc_insertion_point(field_get:gooseai.APIKey.is_secret)
  return _internal_is_secret();
}
inline void APIKey::_internal_set_is_secret(bool value) {
  
  _impl_.is_secret_ = value;
}
inline void APIKey::set_is_secret(bool value) {
  _internal_set_is_secret(value);
  // @@protoc_insertion_point(field_set:gooseai.APIKey.is_secret)
}

// uint64 created_at = 3 [json_name = "createdAt"];
inline void APIKey::clear_created_at() {
  _impl_.created_at_ = uint64_t{0u};
}
inline uint64_t APIKey::_internal_created_at() const {
  return _impl_.created_at_;
}
inline uint64_t APIKey::created_at() const {
  // @@protoc_insertion_point(field_get:gooseai.APIKey.created_at)
  return _internal_created_at();
}
inline void APIKey::_internal_set_created_at(uint64_t value) {
  
  _impl_.created_at_ = value;
}
inline void APIKey::set_created_at(uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:gooseai.APIKey.created_at)
}

// -------------------------------------------------------------------

// User

// string id = 1 [json_name = "id"];
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:gooseai.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.User.id)
}

// optional string auth_id = 2 [json_name = "authId"];
inline bool User::_internal_has_auth_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool User::has_auth_id() const {
  return _internal_has_auth_id();
}
inline void User::clear_auth_id() {
  _impl_.auth_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& User::auth_id() const {
  // @@protoc_insertion_point(field_get:gooseai.User.auth_id)
  return _internal_auth_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_auth_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.auth_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.User.auth_id)
}
inline std::string* User::mutable_auth_id() {
  std::string* _s = _internal_mutable_auth_id();
  // @@protoc_insertion_point(field_mutable:gooseai.User.auth_id)
  return _s;
}
inline const std::string& User::_internal_auth_id() const {
  return _impl_.auth_id_.Get();
}
inline void User::_internal_set_auth_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_auth_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_auth_id() {
  // @@protoc_insertion_point(field_release:gooseai.User.auth_id)
  if (!_internal_has_auth_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.auth_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_id_.IsDefault()) {
    _impl_.auth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_auth_id(std::string* auth_id) {
  if (auth_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_id_.SetAllocated(auth_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_id_.IsDefault()) {
    _impl_.auth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.User.auth_id)
}

// string profile_picture = 3 [json_name = "profilePicture"];
inline void User::clear_profile_picture() {
  _impl_.profile_picture_.ClearToEmpty();
}
inline const std::string& User::profile_picture() const {
  // @@protoc_insertion_point(field_get:gooseai.User.profile_picture)
  return _internal_profile_picture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_profile_picture(ArgT0&& arg0, ArgT... args) {
 
 _impl_.profile_picture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.User.profile_picture)
}
inline std::string* User::mutable_profile_picture() {
  std::string* _s = _internal_mutable_profile_picture();
  // @@protoc_insertion_point(field_mutable:gooseai.User.profile_picture)
  return _s;
}
inline const std::string& User::_internal_profile_picture() const {
  return _impl_.profile_picture_.Get();
}
inline void User::_internal_set_profile_picture(const std::string& value) {
  
  _impl_.profile_picture_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_profile_picture() {
  
  return _impl_.profile_picture_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_profile_picture() {
  // @@protoc_insertion_point(field_release:gooseai.User.profile_picture)
  return _impl_.profile_picture_.Release();
}
inline void User::set_allocated_profile_picture(std::string* profile_picture) {
  if (profile_picture != nullptr) {
    
  } else {
    
  }
  _impl_.profile_picture_.SetAllocated(profile_picture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profile_picture_.IsDefault()) {
    _impl_.profile_picture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.User.profile_picture)
}

// string email = 4 [json_name = "email"];
inline void User::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& User::email() const {
  // @@protoc_insertion_point(field_get:gooseai.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.User.email)
}
inline std::string* User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:gooseai.User.email)
  return _s;
}
inline const std::string& User::_internal_email() const {
  return _impl_.email_.Get();
}
inline void User::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_email() {
  // @@protoc_insertion_point(field_release:gooseai.User.email)
  return _impl_.email_.Release();
}
inline void User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.User.email)
}

// repeated .gooseai.OrganizationMember organizations = 5 [json_name = "organizations"];
inline int User::_internal_organizations_size() const {
  return _impl_.organizations_.size();
}
inline int User::organizations_size() const {
  return _internal_organizations_size();
}
inline void User::clear_organizations() {
  _impl_.organizations_.Clear();
}
inline ::gooseai::OrganizationMember* User::mutable_organizations(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.User.organizations)
  return _impl_.organizations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >*
User::mutable_organizations() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.User.organizations)
  return &_impl_.organizations_;
}
inline const ::gooseai::OrganizationMember& User::_internal_organizations(int index) const {
  return _impl_.organizations_.Get(index);
}
inline const ::gooseai::OrganizationMember& User::organizations(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.User.organizations)
  return _internal_organizations(index);
}
inline ::gooseai::OrganizationMember* User::_internal_add_organizations() {
  return _impl_.organizations_.Add();
}
inline ::gooseai::OrganizationMember* User::add_organizations() {
  ::gooseai::OrganizationMember* _add = _internal_add_organizations();
  // @@protoc_insertion_point(field_add:gooseai.User.organizations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OrganizationMember >&
User::organizations() const {
  // @@protoc_insertion_point(field_list:gooseai.User.organizations)
  return _impl_.organizations_;
}

// repeated .gooseai.APIKey api_keys = 7 [json_name = "apiKeys"];
inline int User::_internal_api_keys_size() const {
  return _impl_.api_keys_.size();
}
inline int User::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void User::clear_api_keys() {
  _impl_.api_keys_.Clear();
}
inline ::gooseai::APIKey* User::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.User.api_keys)
  return _impl_.api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::APIKey >*
User::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.User.api_keys)
  return &_impl_.api_keys_;
}
inline const ::gooseai::APIKey& User::_internal_api_keys(int index) const {
  return _impl_.api_keys_.Get(index);
}
inline const ::gooseai::APIKey& User::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.User.api_keys)
  return _internal_api_keys(index);
}
inline ::gooseai::APIKey* User::_internal_add_api_keys() {
  return _impl_.api_keys_.Add();
}
inline ::gooseai::APIKey* User::add_api_keys() {
  ::gooseai::APIKey* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:gooseai.User.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::APIKey >&
User::api_keys() const {
  // @@protoc_insertion_point(field_list:gooseai.User.api_keys)
  return _impl_.api_keys_;
}

// uint64 created_at = 8 [json_name = "createdAt"];
inline void User::clear_created_at() {
  _impl_.created_at_ = uint64_t{0u};
}
inline uint64_t User::_internal_created_at() const {
  return _impl_.created_at_;
}
inline uint64_t User::created_at() const {
  // @@protoc_insertion_point(field_get:gooseai.User.created_at)
  return _internal_created_at();
}
inline void User::_internal_set_created_at(uint64_t value) {
  
  _impl_.created_at_ = value;
}
inline void User::set_created_at(uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:gooseai.User.created_at)
}

// optional bool email_verified = 9 [json_name = "emailVerified"];
inline bool User::_internal_has_email_verified() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool User::has_email_verified() const {
  return _internal_has_email_verified();
}
inline void User::clear_email_verified() {
  _impl_.email_verified_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool User::_internal_email_verified() const {
  return _impl_.email_verified_;
}
inline bool User::email_verified() const {
  // @@protoc_insertion_point(field_get:gooseai.User.email_verified)
  return _internal_email_verified();
}
inline void User::_internal_set_email_verified(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.email_verified_ = value;
}
inline void User::set_email_verified(bool value) {
  _internal_set_email_verified(value);
  // @@protoc_insertion_point(field_set:gooseai.User.email_verified)
}

// -------------------------------------------------------------------

// CostData

// uint32 amount_tokens = 1 [json_name = "amountTokens"];
inline void CostData::clear_amount_tokens() {
  _impl_.amount_tokens_ = 0u;
}
inline uint32_t CostData::_internal_amount_tokens() const {
  return _impl_.amount_tokens_;
}
inline uint32_t CostData::amount_tokens() const {
  // @@protoc_insertion_point(field_get:gooseai.CostData.amount_tokens)
  return _internal_amount_tokens();
}
inline void CostData::_internal_set_amount_tokens(uint32_t value) {
  
  _impl_.amount_tokens_ = value;
}
inline void CostData::set_amount_tokens(uint32_t value) {
  _internal_set_amount_tokens(value);
  // @@protoc_insertion_point(field_set:gooseai.CostData.amount_tokens)
}

// double amount_credits = 2 [json_name = "amountCredits"];
inline void CostData::clear_amount_credits() {
  _impl_.amount_credits_ = 0;
}
inline double CostData::_internal_amount_credits() const {
  return _impl_.amount_credits_;
}
inline double CostData::amount_credits() const {
  // @@protoc_insertion_point(field_get:gooseai.CostData.amount_credits)
  return _internal_amount_credits();
}
inline void CostData::_internal_set_amount_credits(double value) {
  
  _impl_.amount_credits_ = value;
}
inline void CostData::set_amount_credits(double value) {
  _internal_set_amount_credits(value);
  // @@protoc_insertion_point(field_set:gooseai.CostData.amount_credits)
}

// -------------------------------------------------------------------

// UsageMetric

// string operation = 1 [json_name = "operation"];
inline void UsageMetric::clear_operation() {
  _impl_.operation_.ClearToEmpty();
}
inline const std::string& UsageMetric::operation() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsageMetric::set_operation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UsageMetric.operation)
}
inline std::string* UsageMetric::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:gooseai.UsageMetric.operation)
  return _s;
}
inline const std::string& UsageMetric::_internal_operation() const {
  return _impl_.operation_.Get();
}
inline void UsageMetric::_internal_set_operation(const std::string& value) {
  
  _impl_.operation_.Set(value, GetArenaForAllocation());
}
inline std::string* UsageMetric::_internal_mutable_operation() {
  
  return _impl_.operation_.Mutable(GetArenaForAllocation());
}
inline std::string* UsageMetric::release_operation() {
  // @@protoc_insertion_point(field_release:gooseai.UsageMetric.operation)
  return _impl_.operation_.Release();
}
inline void UsageMetric::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  _impl_.operation_.SetAllocated(operation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_.IsDefault()) {
    _impl_.operation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UsageMetric.operation)
}

// string engine = 2 [json_name = "engine"];
inline void UsageMetric::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& UsageMetric::engine() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsageMetric::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UsageMetric.engine)
}
inline std::string* UsageMetric::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:gooseai.UsageMetric.engine)
  return _s;
}
inline const std::string& UsageMetric::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void UsageMetric::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* UsageMetric::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* UsageMetric::release_engine() {
  // @@protoc_insertion_point(field_release:gooseai.UsageMetric.engine)
  return _impl_.engine_.Release();
}
inline void UsageMetric::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UsageMetric.engine)
}

// .gooseai.CostData input_cost = 3 [json_name = "inputCost"];
inline bool UsageMetric::_internal_has_input_cost() const {
  return this != internal_default_instance() && _impl_.input_cost_ != nullptr;
}
inline bool UsageMetric::has_input_cost() const {
  return _internal_has_input_cost();
}
inline void UsageMetric::clear_input_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_cost_ != nullptr) {
    delete _impl_.input_cost_;
  }
  _impl_.input_cost_ = nullptr;
}
inline const ::gooseai::CostData& UsageMetric::_internal_input_cost() const {
  const ::gooseai::CostData* p = _impl_.input_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::CostData&>(
      ::gooseai::_CostData_default_instance_);
}
inline const ::gooseai::CostData& UsageMetric::input_cost() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.input_cost)
  return _internal_input_cost();
}
inline void UsageMetric::unsafe_arena_set_allocated_input_cost(
    ::gooseai::CostData* input_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_cost_);
  }
  _impl_.input_cost_ = input_cost;
  if (input_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.UsageMetric.input_cost)
}
inline ::gooseai::CostData* UsageMetric::release_input_cost() {
  
  ::gooseai::CostData* temp = _impl_.input_cost_;
  _impl_.input_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::CostData* UsageMetric::unsafe_arena_release_input_cost() {
  // @@protoc_insertion_point(field_release:gooseai.UsageMetric.input_cost)
  
  ::gooseai::CostData* temp = _impl_.input_cost_;
  _impl_.input_cost_ = nullptr;
  return temp;
}
inline ::gooseai::CostData* UsageMetric::_internal_mutable_input_cost() {
  
  if (_impl_.input_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::CostData>(GetArenaForAllocation());
    _impl_.input_cost_ = p;
  }
  return _impl_.input_cost_;
}
inline ::gooseai::CostData* UsageMetric::mutable_input_cost() {
  ::gooseai::CostData* _msg = _internal_mutable_input_cost();
  // @@protoc_insertion_point(field_mutable:gooseai.UsageMetric.input_cost)
  return _msg;
}
inline void UsageMetric::set_allocated_input_cost(::gooseai::CostData* input_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_cost_;
  }
  if (input_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_cost);
    if (message_arena != submessage_arena) {
      input_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_cost_ = input_cost;
  // @@protoc_insertion_point(field_set_allocated:gooseai.UsageMetric.input_cost)
}

// .gooseai.CostData output_cost = 4 [json_name = "outputCost"];
inline bool UsageMetric::_internal_has_output_cost() const {
  return this != internal_default_instance() && _impl_.output_cost_ != nullptr;
}
inline bool UsageMetric::has_output_cost() const {
  return _internal_has_output_cost();
}
inline void UsageMetric::clear_output_cost() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_cost_ != nullptr) {
    delete _impl_.output_cost_;
  }
  _impl_.output_cost_ = nullptr;
}
inline const ::gooseai::CostData& UsageMetric::_internal_output_cost() const {
  const ::gooseai::CostData* p = _impl_.output_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::CostData&>(
      ::gooseai::_CostData_default_instance_);
}
inline const ::gooseai::CostData& UsageMetric::output_cost() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.output_cost)
  return _internal_output_cost();
}
inline void UsageMetric::unsafe_arena_set_allocated_output_cost(
    ::gooseai::CostData* output_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_cost_);
  }
  _impl_.output_cost_ = output_cost;
  if (output_cost) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.UsageMetric.output_cost)
}
inline ::gooseai::CostData* UsageMetric::release_output_cost() {
  
  ::gooseai::CostData* temp = _impl_.output_cost_;
  _impl_.output_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::CostData* UsageMetric::unsafe_arena_release_output_cost() {
  // @@protoc_insertion_point(field_release:gooseai.UsageMetric.output_cost)
  
  ::gooseai::CostData* temp = _impl_.output_cost_;
  _impl_.output_cost_ = nullptr;
  return temp;
}
inline ::gooseai::CostData* UsageMetric::_internal_mutable_output_cost() {
  
  if (_impl_.output_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::CostData>(GetArenaForAllocation());
    _impl_.output_cost_ = p;
  }
  return _impl_.output_cost_;
}
inline ::gooseai::CostData* UsageMetric::mutable_output_cost() {
  ::gooseai::CostData* _msg = _internal_mutable_output_cost();
  // @@protoc_insertion_point(field_mutable:gooseai.UsageMetric.output_cost)
  return _msg;
}
inline void UsageMetric::set_allocated_output_cost(::gooseai::CostData* output_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_cost_;
  }
  if (output_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_cost);
    if (message_arena != submessage_arena) {
      output_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_cost, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_cost_ = output_cost;
  // @@protoc_insertion_point(field_set_allocated:gooseai.UsageMetric.output_cost)
}

// optional string user = 5 [json_name = "user"];
inline bool UsageMetric::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsageMetric::has_user() const {
  return _internal_has_user();
}
inline void UsageMetric::clear_user() {
  _impl_.user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsageMetric::user() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsageMetric::set_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UsageMetric.user)
}
inline std::string* UsageMetric::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:gooseai.UsageMetric.user)
  return _s;
}
inline const std::string& UsageMetric::_internal_user() const {
  return _impl_.user_.Get();
}
inline void UsageMetric::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* UsageMetric::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* UsageMetric::release_user() {
  // @@protoc_insertion_point(field_release:gooseai.UsageMetric.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UsageMetric::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UsageMetric.user)
}

// uint64 aggregation_timestamp = 6 [json_name = "aggregationTimestamp"];
inline void UsageMetric::clear_aggregation_timestamp() {
  _impl_.aggregation_timestamp_ = uint64_t{0u};
}
inline uint64_t UsageMetric::_internal_aggregation_timestamp() const {
  return _impl_.aggregation_timestamp_;
}
inline uint64_t UsageMetric::aggregation_timestamp() const {
  // @@protoc_insertion_point(field_get:gooseai.UsageMetric.aggregation_timestamp)
  return _internal_aggregation_timestamp();
}
inline void UsageMetric::_internal_set_aggregation_timestamp(uint64_t value) {
  
  _impl_.aggregation_timestamp_ = value;
}
inline void UsageMetric::set_aggregation_timestamp(uint64_t value) {
  _internal_set_aggregation_timestamp(value);
  // @@protoc_insertion_point(field_set:gooseai.UsageMetric.aggregation_timestamp)
}

// -------------------------------------------------------------------

// CostTotal

// uint32 amount_tokens = 1 [json_name = "amountTokens"];
inline void CostTotal::clear_amount_tokens() {
  _impl_.amount_tokens_ = 0u;
}
inline uint32_t CostTotal::_internal_amount_tokens() const {
  return _impl_.amount_tokens_;
}
inline uint32_t CostTotal::amount_tokens() const {
  // @@protoc_insertion_point(field_get:gooseai.CostTotal.amount_tokens)
  return _internal_amount_tokens();
}
inline void CostTotal::_internal_set_amount_tokens(uint32_t value) {
  
  _impl_.amount_tokens_ = value;
}
inline void CostTotal::set_amount_tokens(uint32_t value) {
  _internal_set_amount_tokens(value);
  // @@protoc_insertion_point(field_set:gooseai.CostTotal.amount_tokens)
}

// double amount_credits = 2 [json_name = "amountCredits"];
inline void CostTotal::clear_amount_credits() {
  _impl_.amount_credits_ = 0;
}
inline double CostTotal::_internal_amount_credits() const {
  return _impl_.amount_credits_;
}
inline double CostTotal::amount_credits() const {
  // @@protoc_insertion_point(field_get:gooseai.CostTotal.amount_credits)
  return _internal_amount_credits();
}
inline void CostTotal::_internal_set_amount_credits(double value) {
  
  _impl_.amount_credits_ = value;
}
inline void CostTotal::set_amount_credits(double value) {
  _internal_set_amount_credits(value);
  // @@protoc_insertion_point(field_set:gooseai.CostTotal.amount_credits)
}

// -------------------------------------------------------------------

// TotalMetricsData

// .gooseai.CostTotal input_total = 1 [json_name = "inputTotal"];
inline bool TotalMetricsData::_internal_has_input_total() const {
  return this != internal_default_instance() && _impl_.input_total_ != nullptr;
}
inline bool TotalMetricsData::has_input_total() const {
  return _internal_has_input_total();
}
inline void TotalMetricsData::clear_input_total() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_total_ != nullptr) {
    delete _impl_.input_total_;
  }
  _impl_.input_total_ = nullptr;
}
inline const ::gooseai::CostTotal& TotalMetricsData::_internal_input_total() const {
  const ::gooseai::CostTotal* p = _impl_.input_total_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::CostTotal&>(
      ::gooseai::_CostTotal_default_instance_);
}
inline const ::gooseai::CostTotal& TotalMetricsData::input_total() const {
  // @@protoc_insertion_point(field_get:gooseai.TotalMetricsData.input_total)
  return _internal_input_total();
}
inline void TotalMetricsData::unsafe_arena_set_allocated_input_total(
    ::gooseai::CostTotal* input_total) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_total_);
  }
  _impl_.input_total_ = input_total;
  if (input_total) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.TotalMetricsData.input_total)
}
inline ::gooseai::CostTotal* TotalMetricsData::release_input_total() {
  
  ::gooseai::CostTotal* temp = _impl_.input_total_;
  _impl_.input_total_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::CostTotal* TotalMetricsData::unsafe_arena_release_input_total() {
  // @@protoc_insertion_point(field_release:gooseai.TotalMetricsData.input_total)
  
  ::gooseai::CostTotal* temp = _impl_.input_total_;
  _impl_.input_total_ = nullptr;
  return temp;
}
inline ::gooseai::CostTotal* TotalMetricsData::_internal_mutable_input_total() {
  
  if (_impl_.input_total_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::CostTotal>(GetArenaForAllocation());
    _impl_.input_total_ = p;
  }
  return _impl_.input_total_;
}
inline ::gooseai::CostTotal* TotalMetricsData::mutable_input_total() {
  ::gooseai::CostTotal* _msg = _internal_mutable_input_total();
  // @@protoc_insertion_point(field_mutable:gooseai.TotalMetricsData.input_total)
  return _msg;
}
inline void TotalMetricsData::set_allocated_input_total(::gooseai::CostTotal* input_total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_total_;
  }
  if (input_total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_total);
    if (message_arena != submessage_arena) {
      input_total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_total, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_total_ = input_total;
  // @@protoc_insertion_point(field_set_allocated:gooseai.TotalMetricsData.input_total)
}

// .gooseai.CostTotal output_total = 2 [json_name = "outputTotal"];
inline bool TotalMetricsData::_internal_has_output_total() const {
  return this != internal_default_instance() && _impl_.output_total_ != nullptr;
}
inline bool TotalMetricsData::has_output_total() const {
  return _internal_has_output_total();
}
inline void TotalMetricsData::clear_output_total() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_total_ != nullptr) {
    delete _impl_.output_total_;
  }
  _impl_.output_total_ = nullptr;
}
inline const ::gooseai::CostTotal& TotalMetricsData::_internal_output_total() const {
  const ::gooseai::CostTotal* p = _impl_.output_total_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::CostTotal&>(
      ::gooseai::_CostTotal_default_instance_);
}
inline const ::gooseai::CostTotal& TotalMetricsData::output_total() const {
  // @@protoc_insertion_point(field_get:gooseai.TotalMetricsData.output_total)
  return _internal_output_total();
}
inline void TotalMetricsData::unsafe_arena_set_allocated_output_total(
    ::gooseai::CostTotal* output_total) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_total_);
  }
  _impl_.output_total_ = output_total;
  if (output_total) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.TotalMetricsData.output_total)
}
inline ::gooseai::CostTotal* TotalMetricsData::release_output_total() {
  
  ::gooseai::CostTotal* temp = _impl_.output_total_;
  _impl_.output_total_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::CostTotal* TotalMetricsData::unsafe_arena_release_output_total() {
  // @@protoc_insertion_point(field_release:gooseai.TotalMetricsData.output_total)
  
  ::gooseai::CostTotal* temp = _impl_.output_total_;
  _impl_.output_total_ = nullptr;
  return temp;
}
inline ::gooseai::CostTotal* TotalMetricsData::_internal_mutable_output_total() {
  
  if (_impl_.output_total_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::CostTotal>(GetArenaForAllocation());
    _impl_.output_total_ = p;
  }
  return _impl_.output_total_;
}
inline ::gooseai::CostTotal* TotalMetricsData::mutable_output_total() {
  ::gooseai::CostTotal* _msg = _internal_mutable_output_total();
  // @@protoc_insertion_point(field_mutable:gooseai.TotalMetricsData.output_total)
  return _msg;
}
inline void TotalMetricsData::set_allocated_output_total(::gooseai::CostTotal* output_total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_total_;
  }
  if (output_total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_total);
    if (message_arena != submessage_arena) {
      output_total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_total, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_total_ = output_total;
  // @@protoc_insertion_point(field_set_allocated:gooseai.TotalMetricsData.output_total)
}

// -------------------------------------------------------------------

// Metrics

// repeated .gooseai.UsageMetric metrics = 1 [json_name = "metrics"];
inline int Metrics::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int Metrics::metrics_size() const {
  return _internal_metrics_size();
}
inline void Metrics::clear_metrics() {
  _impl_.metrics_.Clear();
}
inline ::gooseai::UsageMetric* Metrics::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Metrics.metrics)
  return _impl_.metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::UsageMetric >*
Metrics::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Metrics.metrics)
  return &_impl_.metrics_;
}
inline const ::gooseai::UsageMetric& Metrics::_internal_metrics(int index) const {
  return _impl_.metrics_.Get(index);
}
inline const ::gooseai::UsageMetric& Metrics::metrics(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Metrics.metrics)
  return _internal_metrics(index);
}
inline ::gooseai::UsageMetric* Metrics::_internal_add_metrics() {
  return _impl_.metrics_.Add();
}
inline ::gooseai::UsageMetric* Metrics::add_metrics() {
  ::gooseai::UsageMetric* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:gooseai.Metrics.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::UsageMetric >&
Metrics::metrics() const {
  // @@protoc_insertion_point(field_list:gooseai.Metrics.metrics)
  return _impl_.metrics_;
}

// .gooseai.TotalMetricsData total = 2 [json_name = "total"];
inline bool Metrics::_internal_has_total() const {
  return this != internal_default_instance() && _impl_.total_ != nullptr;
}
inline bool Metrics::has_total() const {
  return _internal_has_total();
}
inline void Metrics::clear_total() {
  if (GetArenaForAllocation() == nullptr && _impl_.total_ != nullptr) {
    delete _impl_.total_;
  }
  _impl_.total_ = nullptr;
}
inline const ::gooseai::TotalMetricsData& Metrics::_internal_total() const {
  const ::gooseai::TotalMetricsData* p = _impl_.total_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::TotalMetricsData&>(
      ::gooseai::_TotalMetricsData_default_instance_);
}
inline const ::gooseai::TotalMetricsData& Metrics::total() const {
  // @@protoc_insertion_point(field_get:gooseai.Metrics.total)
  return _internal_total();
}
inline void Metrics::unsafe_arena_set_allocated_total(
    ::gooseai::TotalMetricsData* total) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.total_);
  }
  _impl_.total_ = total;
  if (total) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Metrics.total)
}
inline ::gooseai::TotalMetricsData* Metrics::release_total() {
  
  ::gooseai::TotalMetricsData* temp = _impl_.total_;
  _impl_.total_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::TotalMetricsData* Metrics::unsafe_arena_release_total() {
  // @@protoc_insertion_point(field_release:gooseai.Metrics.total)
  
  ::gooseai::TotalMetricsData* temp = _impl_.total_;
  _impl_.total_ = nullptr;
  return temp;
}
inline ::gooseai::TotalMetricsData* Metrics::_internal_mutable_total() {
  
  if (_impl_.total_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::TotalMetricsData>(GetArenaForAllocation());
    _impl_.total_ = p;
  }
  return _impl_.total_;
}
inline ::gooseai::TotalMetricsData* Metrics::mutable_total() {
  ::gooseai::TotalMetricsData* _msg = _internal_mutable_total();
  // @@protoc_insertion_point(field_mutable:gooseai.Metrics.total)
  return _msg;
}
inline void Metrics::set_allocated_total(::gooseai::TotalMetricsData* total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.total_;
  }
  if (total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(total);
    if (message_arena != submessage_arena) {
      total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.total_ = total;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Metrics.total)
}

// -------------------------------------------------------------------

// EmptyRequest

// -------------------------------------------------------------------

// GetOrganizationRequest

// string id = 1 [json_name = "id"];
inline void GetOrganizationRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetOrganizationRequest::id() const {
  // @@protoc_insertion_point(field_get:gooseai.GetOrganizationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.GetOrganizationRequest.id)
}
inline std::string* GetOrganizationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.GetOrganizationRequest.id)
  return _s;
}
inline const std::string& GetOrganizationRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetOrganizationRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOrganizationRequest::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.GetOrganizationRequest.id)
  return _impl_.id_.Release();
}
inline void GetOrganizationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.GetOrganizationRequest.id)
}

// -------------------------------------------------------------------

// GetMetricsRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetMetricsRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& GetMetricsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.GetMetricsRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMetricsRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.GetMetricsRequest.organization_id)
}
inline std::string* GetMetricsRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.GetMetricsRequest.organization_id)
  return _s;
}
inline const std::string& GetMetricsRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void GetMetricsRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.GetMetricsRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void GetMetricsRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.GetMetricsRequest.organization_id)
}

// optional string user_id = 2 [json_name = "userId"];
inline bool GetMetricsRequest::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetMetricsRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetMetricsRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetMetricsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:gooseai.GetMetricsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMetricsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.GetMetricsRequest.user_id)
}
inline std::string* GetMetricsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:gooseai.GetMetricsRequest.user_id)
  return _s;
}
inline const std::string& GetMetricsRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetMetricsRequest::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:gooseai.GetMetricsRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetMetricsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.GetMetricsRequest.user_id)
}

// uint64 range_from = 3 [json_name = "rangeFrom"];
inline void GetMetricsRequest::clear_range_from() {
  _impl_.range_from_ = uint64_t{0u};
}
inline uint64_t GetMetricsRequest::_internal_range_from() const {
  return _impl_.range_from_;
}
inline uint64_t GetMetricsRequest::range_from() const {
  // @@protoc_insertion_point(field_get:gooseai.GetMetricsRequest.range_from)
  return _internal_range_from();
}
inline void GetMetricsRequest::_internal_set_range_from(uint64_t value) {
  
  _impl_.range_from_ = value;
}
inline void GetMetricsRequest::set_range_from(uint64_t value) {
  _internal_set_range_from(value);
  // @@protoc_insertion_point(field_set:gooseai.GetMetricsRequest.range_from)
}

// uint64 range_to = 4 [json_name = "rangeTo"];
inline void GetMetricsRequest::clear_range_to() {
  _impl_.range_to_ = uint64_t{0u};
}
inline uint64_t GetMetricsRequest::_internal_range_to() const {
  return _impl_.range_to_;
}
inline uint64_t GetMetricsRequest::range_to() const {
  // @@protoc_insertion_point(field_get:gooseai.GetMetricsRequest.range_to)
  return _internal_range_to();
}
inline void GetMetricsRequest::_internal_set_range_to(uint64_t value) {
  
  _impl_.range_to_ = value;
}
inline void GetMetricsRequest::set_range_to(uint64_t value) {
  _internal_set_range_to(value);
  // @@protoc_insertion_point(field_set:gooseai.GetMetricsRequest.range_to)
}

// bool include_per_request_metrics = 5 [json_name = "includePerRequestMetrics"];
inline void GetMetricsRequest::clear_include_per_request_metrics() {
  _impl_.include_per_request_metrics_ = false;
}
inline bool GetMetricsRequest::_internal_include_per_request_metrics() const {
  return _impl_.include_per_request_metrics_;
}
inline bool GetMetricsRequest::include_per_request_metrics() const {
  // @@protoc_insertion_point(field_get:gooseai.GetMetricsRequest.include_per_request_metrics)
  return _internal_include_per_request_metrics();
}
inline void GetMetricsRequest::_internal_set_include_per_request_metrics(bool value) {
  
  _impl_.include_per_request_metrics_ = value;
}
inline void GetMetricsRequest::set_include_per_request_metrics(bool value) {
  _internal_set_include_per_request_metrics(value);
  // @@protoc_insertion_point(field_set:gooseai.GetMetricsRequest.include_per_request_metrics)
}

// -------------------------------------------------------------------

// APIKeyRequest

// bool is_secret = 1 [json_name = "isSecret"];
inline void APIKeyRequest::clear_is_secret() {
  _impl_.is_secret_ = false;
}
inline bool APIKeyRequest::_internal_is_secret() const {
  return _impl_.is_secret_;
}
inline bool APIKeyRequest::is_secret() const {
  // @@protoc_insertion_point(field_get:gooseai.APIKeyRequest.is_secret)
  return _internal_is_secret();
}
inline void APIKeyRequest::_internal_set_is_secret(bool value) {
  
  _impl_.is_secret_ = value;
}
inline void APIKeyRequest::set_is_secret(bool value) {
  _internal_set_is_secret(value);
  // @@protoc_insertion_point(field_set:gooseai.APIKeyRequest.is_secret)
}

// -------------------------------------------------------------------

// APIKeyFindRequest

// string id = 1 [json_name = "id"];
inline void APIKeyFindRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& APIKeyFindRequest::id() const {
  // @@protoc_insertion_point(field_get:gooseai.APIKeyFindRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIKeyFindRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.APIKeyFindRequest.id)
}
inline std::string* APIKeyFindRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.APIKeyFindRequest.id)
  return _s;
}
inline const std::string& APIKeyFindRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void APIKeyFindRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* APIKeyFindRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* APIKeyFindRequest::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.APIKeyFindRequest.id)
  return _impl_.id_.Release();
}
inline void APIKeyFindRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.APIKeyFindRequest.id)
}

// -------------------------------------------------------------------

// UpdateDefaultOrganizationRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void UpdateDefaultOrganizationRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& UpdateDefaultOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.UpdateDefaultOrganizationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateDefaultOrganizationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UpdateDefaultOrganizationRequest.organization_id)
}
inline std::string* UpdateDefaultOrganizationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.UpdateDefaultOrganizationRequest.organization_id)
  return _s;
}
inline const std::string& UpdateDefaultOrganizationRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void UpdateDefaultOrganizationRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDefaultOrganizationRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateDefaultOrganizationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.UpdateDefaultOrganizationRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void UpdateDefaultOrganizationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UpdateDefaultOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// ClientSettings

// bytes settings = 1 [json_name = "settings"];
inline void ClientSettings::clear_settings() {
  _impl_.settings_.ClearToEmpty();
}
inline const std::string& ClientSettings::settings() const {
  // @@protoc_insertion_point(field_get:gooseai.ClientSettings.settings)
  return _internal_settings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettings::set_settings(ArgT0&& arg0, ArgT... args) {
 
 _impl_.settings_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.ClientSettings.settings)
}
inline std::string* ClientSettings::mutable_settings() {
  std::string* _s = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:gooseai.ClientSettings.settings)
  return _s;
}
inline const std::string& ClientSettings::_internal_settings() const {
  return _impl_.settings_.Get();
}
inline void ClientSettings::_internal_set_settings(const std::string& value) {
  
  _impl_.settings_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettings::_internal_mutable_settings() {
  
  return _impl_.settings_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettings::release_settings() {
  // @@protoc_insertion_point(field_release:gooseai.ClientSettings.settings)
  return _impl_.settings_.Release();
}
inline void ClientSettings::set_allocated_settings(std::string* settings) {
  if (settings != nullptr) {
    
  } else {
    
  }
  _impl_.settings_.SetAllocated(settings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.settings_.IsDefault()) {
    _impl_.settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.ClientSettings.settings)
}

// -------------------------------------------------------------------

// CreateAutoChargeIntentRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void CreateAutoChargeIntentRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& CreateAutoChargeIntentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateAutoChargeIntentRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAutoChargeIntentRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.CreateAutoChargeIntentRequest.organization_id)
}
inline std::string* CreateAutoChargeIntentRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.CreateAutoChargeIntentRequest.organization_id)
  return _s;
}
inline const std::string& CreateAutoChargeIntentRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void CreateAutoChargeIntentRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAutoChargeIntentRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAutoChargeIntentRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.CreateAutoChargeIntentRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void CreateAutoChargeIntentRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.CreateAutoChargeIntentRequest.organization_id)
}

// uint64 monthly_maximum = 2 [json_name = "monthlyMaximum"];
inline void CreateAutoChargeIntentRequest::clear_monthly_maximum() {
  _impl_.monthly_maximum_ = uint64_t{0u};
}
inline uint64_t CreateAutoChargeIntentRequest::_internal_monthly_maximum() const {
  return _impl_.monthly_maximum_;
}
inline uint64_t CreateAutoChargeIntentRequest::monthly_maximum() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateAutoChargeIntentRequest.monthly_maximum)
  return _internal_monthly_maximum();
}
inline void CreateAutoChargeIntentRequest::_internal_set_monthly_maximum(uint64_t value) {
  
  _impl_.monthly_maximum_ = value;
}
inline void CreateAutoChargeIntentRequest::set_monthly_maximum(uint64_t value) {
  _internal_set_monthly_maximum(value);
  // @@protoc_insertion_point(field_set:gooseai.CreateAutoChargeIntentRequest.monthly_maximum)
}

// uint64 minimum_value = 3 [json_name = "minimumValue"];
inline void CreateAutoChargeIntentRequest::clear_minimum_value() {
  _impl_.minimum_value_ = uint64_t{0u};
}
inline uint64_t CreateAutoChargeIntentRequest::_internal_minimum_value() const {
  return _impl_.minimum_value_;
}
inline uint64_t CreateAutoChargeIntentRequest::minimum_value() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateAutoChargeIntentRequest.minimum_value)
  return _internal_minimum_value();
}
inline void CreateAutoChargeIntentRequest::_internal_set_minimum_value(uint64_t value) {
  
  _impl_.minimum_value_ = value;
}
inline void CreateAutoChargeIntentRequest::set_minimum_value(uint64_t value) {
  _internal_set_minimum_value(value);
  // @@protoc_insertion_point(field_set:gooseai.CreateAutoChargeIntentRequest.minimum_value)
}

// uint64 amount_credits = 4 [json_name = "amountCredits"];
inline void CreateAutoChargeIntentRequest::clear_amount_credits() {
  _impl_.amount_credits_ = uint64_t{0u};
}
inline uint64_t CreateAutoChargeIntentRequest::_internal_amount_credits() const {
  return _impl_.amount_credits_;
}
inline uint64_t CreateAutoChargeIntentRequest::amount_credits() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateAutoChargeIntentRequest.amount_credits)
  return _internal_amount_credits();
}
inline void CreateAutoChargeIntentRequest::_internal_set_amount_credits(uint64_t value) {
  
  _impl_.amount_credits_ = value;
}
inline void CreateAutoChargeIntentRequest::set_amount_credits(uint64_t value) {
  _internal_set_amount_credits(value);
  // @@protoc_insertion_point(field_set:gooseai.CreateAutoChargeIntentRequest.amount_credits)
}

// -------------------------------------------------------------------

// CreateChargeRequest

// uint64 amount = 1 [json_name = "amount"];
inline void CreateChargeRequest::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t CreateChargeRequest::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t CreateChargeRequest::amount() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateChargeRequest.amount)
  return _internal_amount();
}
inline void CreateChargeRequest::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void CreateChargeRequest::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:gooseai.CreateChargeRequest.amount)
}

// string organization_id = 2 [json_name = "organizationId"];
inline void CreateChargeRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& CreateChargeRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.CreateChargeRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChargeRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.CreateChargeRequest.organization_id)
}
inline std::string* CreateChargeRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.CreateChargeRequest.organization_id)
  return _s;
}
inline const std::string& CreateChargeRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void CreateChargeRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateChargeRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateChargeRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.CreateChargeRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void CreateChargeRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.CreateChargeRequest.organization_id)
}

// -------------------------------------------------------------------

// GetChargesRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetChargesRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& GetChargesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.GetChargesRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetChargesRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.GetChargesRequest.organization_id)
}
inline std::string* GetChargesRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.GetChargesRequest.organization_id)
  return _s;
}
inline const std::string& GetChargesRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void GetChargesRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetChargesRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetChargesRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.GetChargesRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void GetChargesRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.GetChargesRequest.organization_id)
}

// uint64 range_from = 2 [json_name = "rangeFrom"];
inline void GetChargesRequest::clear_range_from() {
  _impl_.range_from_ = uint64_t{0u};
}
inline uint64_t GetChargesRequest::_internal_range_from() const {
  return _impl_.range_from_;
}
inline uint64_t GetChargesRequest::range_from() const {
  // @@protoc_insertion_point(field_get:gooseai.GetChargesRequest.range_from)
  return _internal_range_from();
}
inline void GetChargesRequest::_internal_set_range_from(uint64_t value) {
  
  _impl_.range_from_ = value;
}
inline void GetChargesRequest::set_range_from(uint64_t value) {
  _internal_set_range_from(value);
  // @@protoc_insertion_point(field_set:gooseai.GetChargesRequest.range_from)
}

// uint64 range_to = 3 [json_name = "rangeTo"];
inline void GetChargesRequest::clear_range_to() {
  _impl_.range_to_ = uint64_t{0u};
}
inline uint64_t GetChargesRequest::_internal_range_to() const {
  return _impl_.range_to_;
}
inline uint64_t GetChargesRequest::range_to() const {
  // @@protoc_insertion_point(field_get:gooseai.GetChargesRequest.range_to)
  return _internal_range_to();
}
inline void GetChargesRequest::_internal_set_range_to(uint64_t value) {
  
  _impl_.range_to_ = value;
}
inline void GetChargesRequest::set_range_to(uint64_t value) {
  _internal_set_range_to(value);
  // @@protoc_insertion_point(field_set:gooseai.GetChargesRequest.range_to)
}

// -------------------------------------------------------------------

// Charge

// string id = 1 [json_name = "id"];
inline void Charge::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Charge::id() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Charge::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Charge.id)
}
inline std::string* Charge::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Charge.id)
  return _s;
}
inline const std::string& Charge::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Charge::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Charge::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Charge::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.Charge.id)
  return _impl_.id_.Release();
}
inline void Charge::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Charge.id)
}

// bool paid = 2 [json_name = "paid"];
inline void Charge::clear_paid() {
  _impl_.paid_ = false;
}
inline bool Charge::_internal_paid() const {
  return _impl_.paid_;
}
inline bool Charge::paid() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.paid)
  return _internal_paid();
}
inline void Charge::_internal_set_paid(bool value) {
  
  _impl_.paid_ = value;
}
inline void Charge::set_paid(bool value) {
  _internal_set_paid(value);
  // @@protoc_insertion_point(field_set:gooseai.Charge.paid)
}

// string receipt_link = 3 [json_name = "receiptLink"];
inline void Charge::clear_receipt_link() {
  _impl_.receipt_link_.ClearToEmpty();
}
inline const std::string& Charge::receipt_link() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.receipt_link)
  return _internal_receipt_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Charge::set_receipt_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receipt_link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Charge.receipt_link)
}
inline std::string* Charge::mutable_receipt_link() {
  std::string* _s = _internal_mutable_receipt_link();
  // @@protoc_insertion_point(field_mutable:gooseai.Charge.receipt_link)
  return _s;
}
inline const std::string& Charge::_internal_receipt_link() const {
  return _impl_.receipt_link_.Get();
}
inline void Charge::_internal_set_receipt_link(const std::string& value) {
  
  _impl_.receipt_link_.Set(value, GetArenaForAllocation());
}
inline std::string* Charge::_internal_mutable_receipt_link() {
  
  return _impl_.receipt_link_.Mutable(GetArenaForAllocation());
}
inline std::string* Charge::release_receipt_link() {
  // @@protoc_insertion_point(field_release:gooseai.Charge.receipt_link)
  return _impl_.receipt_link_.Release();
}
inline void Charge::set_allocated_receipt_link(std::string* receipt_link) {
  if (receipt_link != nullptr) {
    
  } else {
    
  }
  _impl_.receipt_link_.SetAllocated(receipt_link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receipt_link_.IsDefault()) {
    _impl_.receipt_link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Charge.receipt_link)
}

// string payment_link = 4 [json_name = "paymentLink"];
inline void Charge::clear_payment_link() {
  _impl_.payment_link_.ClearToEmpty();
}
inline const std::string& Charge::payment_link() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.payment_link)
  return _internal_payment_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Charge::set_payment_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payment_link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Charge.payment_link)
}
inline std::string* Charge::mutable_payment_link() {
  std::string* _s = _internal_mutable_payment_link();
  // @@protoc_insertion_point(field_mutable:gooseai.Charge.payment_link)
  return _s;
}
inline const std::string& Charge::_internal_payment_link() const {
  return _impl_.payment_link_.Get();
}
inline void Charge::_internal_set_payment_link(const std::string& value) {
  
  _impl_.payment_link_.Set(value, GetArenaForAllocation());
}
inline std::string* Charge::_internal_mutable_payment_link() {
  
  return _impl_.payment_link_.Mutable(GetArenaForAllocation());
}
inline std::string* Charge::release_payment_link() {
  // @@protoc_insertion_point(field_release:gooseai.Charge.payment_link)
  return _impl_.payment_link_.Release();
}
inline void Charge::set_allocated_payment_link(std::string* payment_link) {
  if (payment_link != nullptr) {
    
  } else {
    
  }
  _impl_.payment_link_.SetAllocated(payment_link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_link_.IsDefault()) {
    _impl_.payment_link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Charge.payment_link)
}

// uint64 created_at = 5 [json_name = "createdAt"];
inline void Charge::clear_created_at() {
  _impl_.created_at_ = uint64_t{0u};
}
inline uint64_t Charge::_internal_created_at() const {
  return _impl_.created_at_;
}
inline uint64_t Charge::created_at() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.created_at)
  return _internal_created_at();
}
inline void Charge::_internal_set_created_at(uint64_t value) {
  
  _impl_.created_at_ = value;
}
inline void Charge::set_created_at(uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:gooseai.Charge.created_at)
}

// uint64 amount_credits = 6 [json_name = "amountCredits"];
inline void Charge::clear_amount_credits() {
  _impl_.amount_credits_ = uint64_t{0u};
}
inline uint64_t Charge::_internal_amount_credits() const {
  return _impl_.amount_credits_;
}
inline uint64_t Charge::amount_credits() const {
  // @@protoc_insertion_point(field_get:gooseai.Charge.amount_credits)
  return _internal_amount_credits();
}
inline void Charge::_internal_set_amount_credits(uint64_t value) {
  
  _impl_.amount_credits_ = value;
}
inline void Charge::set_amount_credits(uint64_t value) {
  _internal_set_amount_credits(value);
  // @@protoc_insertion_point(field_set:gooseai.Charge.amount_credits)
}

// -------------------------------------------------------------------

// Charges

// repeated .gooseai.Charge charges = 1 [json_name = "charges"];
inline int Charges::_internal_charges_size() const {
  return _impl_.charges_.size();
}
inline int Charges::charges_size() const {
  return _internal_charges_size();
}
inline void Charges::clear_charges() {
  _impl_.charges_.Clear();
}
inline ::gooseai::Charge* Charges::mutable_charges(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Charges.charges)
  return _impl_.charges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Charge >*
Charges::mutable_charges() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Charges.charges)
  return &_impl_.charges_;
}
inline const ::gooseai::Charge& Charges::_internal_charges(int index) const {
  return _impl_.charges_.Get(index);
}
inline const ::gooseai::Charge& Charges::charges(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Charges.charges)
  return _internal_charges(index);
}
inline ::gooseai::Charge* Charges::_internal_add_charges() {
  return _impl_.charges_.Add();
}
inline ::gooseai::Charge* Charges::add_charges() {
  ::gooseai::Charge* _add = _internal_add_charges();
  // @@protoc_insertion_point(field_add:gooseai.Charges.charges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Charge >&
Charges::charges() const {
  // @@protoc_insertion_point(field_list:gooseai.Charges.charges)
  return _impl_.charges_;
}

// -------------------------------------------------------------------

// GetAutoChargeRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetAutoChargeRequest::clear_organization_id() {
  _impl_.organization_id_.ClearToEmpty();
}
inline const std::string& GetAutoChargeRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:gooseai.GetAutoChargeRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAutoChargeRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.organization_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.GetAutoChargeRequest.organization_id)
}
inline std::string* GetAutoChargeRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:gooseai.GetAutoChargeRequest.organization_id)
  return _s;
}
inline const std::string& GetAutoChargeRequest::_internal_organization_id() const {
  return _impl_.organization_id_.Get();
}
inline void GetAutoChargeRequest::_internal_set_organization_id(const std::string& value) {
  
  _impl_.organization_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAutoChargeRequest::_internal_mutable_organization_id() {
  
  return _impl_.organization_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAutoChargeRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:gooseai.GetAutoChargeRequest.organization_id)
  return _impl_.organization_id_.Release();
}
inline void GetAutoChargeRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  _impl_.organization_id_.SetAllocated(organization_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.organization_id_.IsDefault()) {
    _impl_.organization_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.GetAutoChargeRequest.organization_id)
}

// -------------------------------------------------------------------

// AutoChargeIntent

// string id = 1 [json_name = "id"];
inline void AutoChargeIntent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AutoChargeIntent::id() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoChargeIntent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.id)
}
inline std::string* AutoChargeIntent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AutoChargeIntent.id)
  return _s;
}
inline const std::string& AutoChargeIntent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AutoChargeIntent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoChargeIntent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoChargeIntent::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.AutoChargeIntent.id)
  return _impl_.id_.Release();
}
inline void AutoChargeIntent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AutoChargeIntent.id)
}

// string payment_link = 2 [json_name = "paymentLink"];
inline void AutoChargeIntent::clear_payment_link() {
  _impl_.payment_link_.ClearToEmpty();
}
inline const std::string& AutoChargeIntent::payment_link() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.payment_link)
  return _internal_payment_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoChargeIntent::set_payment_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payment_link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.payment_link)
}
inline std::string* AutoChargeIntent::mutable_payment_link() {
  std::string* _s = _internal_mutable_payment_link();
  // @@protoc_insertion_point(field_mutable:gooseai.AutoChargeIntent.payment_link)
  return _s;
}
inline const std::string& AutoChargeIntent::_internal_payment_link() const {
  return _impl_.payment_link_.Get();
}
inline void AutoChargeIntent::_internal_set_payment_link(const std::string& value) {
  
  _impl_.payment_link_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoChargeIntent::_internal_mutable_payment_link() {
  
  return _impl_.payment_link_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoChargeIntent::release_payment_link() {
  // @@protoc_insertion_point(field_release:gooseai.AutoChargeIntent.payment_link)
  return _impl_.payment_link_.Release();
}
inline void AutoChargeIntent::set_allocated_payment_link(std::string* payment_link) {
  if (payment_link != nullptr) {
    
  } else {
    
  }
  _impl_.payment_link_.SetAllocated(payment_link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_link_.IsDefault()) {
    _impl_.payment_link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AutoChargeIntent.payment_link)
}

// uint64 created_at = 3 [json_name = "createdAt"];
inline void AutoChargeIntent::clear_created_at() {
  _impl_.created_at_ = uint64_t{0u};
}
inline uint64_t AutoChargeIntent::_internal_created_at() const {
  return _impl_.created_at_;
}
inline uint64_t AutoChargeIntent::created_at() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.created_at)
  return _internal_created_at();
}
inline void AutoChargeIntent::_internal_set_created_at(uint64_t value) {
  
  _impl_.created_at_ = value;
}
inline void AutoChargeIntent::set_created_at(uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.created_at)
}

// uint64 monthly_maximum = 4 [json_name = "monthlyMaximum"];
inline void AutoChargeIntent::clear_monthly_maximum() {
  _impl_.monthly_maximum_ = uint64_t{0u};
}
inline uint64_t AutoChargeIntent::_internal_monthly_maximum() const {
  return _impl_.monthly_maximum_;
}
inline uint64_t AutoChargeIntent::monthly_maximum() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.monthly_maximum)
  return _internal_monthly_maximum();
}
inline void AutoChargeIntent::_internal_set_monthly_maximum(uint64_t value) {
  
  _impl_.monthly_maximum_ = value;
}
inline void AutoChargeIntent::set_monthly_maximum(uint64_t value) {
  _internal_set_monthly_maximum(value);
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.monthly_maximum)
}

// uint64 minimum_value = 5 [json_name = "minimumValue"];
inline void AutoChargeIntent::clear_minimum_value() {
  _impl_.minimum_value_ = uint64_t{0u};
}
inline uint64_t AutoChargeIntent::_internal_minimum_value() const {
  return _impl_.minimum_value_;
}
inline uint64_t AutoChargeIntent::minimum_value() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.minimum_value)
  return _internal_minimum_value();
}
inline void AutoChargeIntent::_internal_set_minimum_value(uint64_t value) {
  
  _impl_.minimum_value_ = value;
}
inline void AutoChargeIntent::set_minimum_value(uint64_t value) {
  _internal_set_minimum_value(value);
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.minimum_value)
}

// uint64 amount_credits = 6 [json_name = "amountCredits"];
inline void AutoChargeIntent::clear_amount_credits() {
  _impl_.amount_credits_ = uint64_t{0u};
}
inline uint64_t AutoChargeIntent::_internal_amount_credits() const {
  return _impl_.amount_credits_;
}
inline uint64_t AutoChargeIntent::amount_credits() const {
  // @@protoc_insertion_point(field_get:gooseai.AutoChargeIntent.amount_credits)
  return _internal_amount_credits();
}
inline void AutoChargeIntent::_internal_set_amount_credits(uint64_t value) {
  
  _impl_.amount_credits_ = value;
}
inline void AutoChargeIntent::set_amount_credits(uint64_t value) {
  _internal_set_amount_credits(value);
  // @@protoc_insertion_point(field_set:gooseai.AutoChargeIntent.amount_credits)
}

// -------------------------------------------------------------------

// UpdateUserInfoRequest

// optional string email = 1 [json_name = "email"];
inline bool UpdateUserInfoRequest::_internal_has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateUserInfoRequest::has_email() const {
  return _internal_has_email();
}
inline void UpdateUserInfoRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateUserInfoRequest::email() const {
  // @@protoc_insertion_point(field_get:gooseai.UpdateUserInfoRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserInfoRequest::set_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UpdateUserInfoRequest.email)
}
inline std::string* UpdateUserInfoRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:gooseai.UpdateUserInfoRequest.email)
  return _s;
}
inline const std::string& UpdateUserInfoRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UpdateUserInfoRequest::_internal_set_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateUserInfoRequest::_internal_mutable_email() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateUserInfoRequest::release_email() {
  // @@protoc_insertion_point(field_release:gooseai.UpdateUserInfoRequest.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateUserInfoRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UpdateUserInfoRequest.email)
}

// -------------------------------------------------------------------

// UserPasswordChangeTicket

// string ticket = 1 [json_name = "ticket"];
inline void UserPasswordChangeTicket::clear_ticket() {
  _impl_.ticket_.ClearToEmpty();
}
inline const std::string& UserPasswordChangeTicket::ticket() const {
  // @@protoc_insertion_point(field_get:gooseai.UserPasswordChangeTicket.ticket)
  return _internal_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPasswordChangeTicket::set_ticket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ticket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.UserPasswordChangeTicket.ticket)
}
inline std::string* UserPasswordChangeTicket::mutable_ticket() {
  std::string* _s = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:gooseai.UserPasswordChangeTicket.ticket)
  return _s;
}
inline const std::string& UserPasswordChangeTicket::_internal_ticket() const {
  return _impl_.ticket_.Get();
}
inline void UserPasswordChangeTicket::_internal_set_ticket(const std::string& value) {
  
  _impl_.ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPasswordChangeTicket::_internal_mutable_ticket() {
  
  return _impl_.ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPasswordChangeTicket::release_ticket() {
  // @@protoc_insertion_point(field_release:gooseai.UserPasswordChangeTicket.ticket)
  return _impl_.ticket_.Release();
}
inline void UserPasswordChangeTicket::set_allocated_ticket(std::string* ticket) {
  if (ticket != nullptr) {
    
  } else {
    
  }
  _impl_.ticket_.SetAllocated(ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ticket_.IsDefault()) {
    _impl_.ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.UserPasswordChangeTicket.ticket)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gooseai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gooseai::OrganizationRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::OrganizationRole>() {
  return ::gooseai::OrganizationRole_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dashboard_2eproto
