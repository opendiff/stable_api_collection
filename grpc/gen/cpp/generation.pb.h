// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: generation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_generation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_generation_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensors.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_generation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_generation_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_generation_2eproto;
namespace gooseai {
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class AnswerMeta;
struct AnswerMetaDefaultTypeInternal;
extern AnswerMetaDefaultTypeInternal _AnswerMeta_default_instance_;
class Artifact;
struct ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class AssetParameters;
struct AssetParametersDefaultTypeInternal;
extern AssetParametersDefaultTypeInternal _AssetParameters_default_instance_;
class ChainRequest;
struct ChainRequestDefaultTypeInternal;
extern ChainRequestDefaultTypeInternal _ChainRequest_default_instance_;
class ClassifierCategory;
struct ClassifierCategoryDefaultTypeInternal;
extern ClassifierCategoryDefaultTypeInternal _ClassifierCategory_default_instance_;
class ClassifierConcept;
struct ClassifierConceptDefaultTypeInternal;
extern ClassifierConceptDefaultTypeInternal _ClassifierConcept_default_instance_;
class ClassifierParameters;
struct ClassifierParametersDefaultTypeInternal;
extern ClassifierParametersDefaultTypeInternal _ClassifierParameters_default_instance_;
class ConditionerParameters;
struct ConditionerParametersDefaultTypeInternal;
extern ConditionerParametersDefaultTypeInternal _ConditionerParameters_default_instance_;
class CutoutParameters;
struct CutoutParametersDefaultTypeInternal;
extern CutoutParametersDefaultTypeInternal _CutoutParameters_default_instance_;
class GuidanceInstanceParameters;
struct GuidanceInstanceParametersDefaultTypeInternal;
extern GuidanceInstanceParametersDefaultTypeInternal _GuidanceInstanceParameters_default_instance_;
class GuidanceParameters;
struct GuidanceParametersDefaultTypeInternal;
extern GuidanceParametersDefaultTypeInternal _GuidanceParameters_default_instance_;
class GuidanceScheduleParameters;
struct GuidanceScheduleParametersDefaultTypeInternal;
extern GuidanceScheduleParametersDefaultTypeInternal _GuidanceScheduleParameters_default_instance_;
class ImageParameters;
struct ImageParametersDefaultTypeInternal;
extern ImageParametersDefaultTypeInternal _ImageParameters_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class OnStatus;
struct OnStatusDefaultTypeInternal;
extern OnStatusDefaultTypeInternal _OnStatus_default_instance_;
class Prompt;
struct PromptDefaultTypeInternal;
extern PromptDefaultTypeInternal _Prompt_default_instance_;
class PromptParameters;
struct PromptParametersDefaultTypeInternal;
extern PromptParametersDefaultTypeInternal _PromptParameters_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SamplerParameters;
struct SamplerParametersDefaultTypeInternal;
extern SamplerParametersDefaultTypeInternal _SamplerParameters_default_instance_;
class ScheduleParameters;
struct ScheduleParametersDefaultTypeInternal;
extern ScheduleParametersDefaultTypeInternal _ScheduleParameters_default_instance_;
class Stage;
struct StageDefaultTypeInternal;
extern StageDefaultTypeInternal _Stage_default_instance_;
class StepParameter;
struct StepParameterDefaultTypeInternal;
extern StepParameterDefaultTypeInternal _StepParameter_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Tokens;
struct TokensDefaultTypeInternal;
extern TokensDefaultTypeInternal _Tokens_default_instance_;
class TransformType;
struct TransformTypeDefaultTypeInternal;
extern TransformTypeDefaultTypeInternal _TransformType_default_instance_;
}  // namespace gooseai
PROTOBUF_NAMESPACE_OPEN
template<> ::gooseai::Answer* Arena::CreateMaybeMessage<::gooseai::Answer>(Arena*);
template<> ::gooseai::AnswerMeta* Arena::CreateMaybeMessage<::gooseai::AnswerMeta>(Arena*);
template<> ::gooseai::Artifact* Arena::CreateMaybeMessage<::gooseai::Artifact>(Arena*);
template<> ::gooseai::AssetParameters* Arena::CreateMaybeMessage<::gooseai::AssetParameters>(Arena*);
template<> ::gooseai::ChainRequest* Arena::CreateMaybeMessage<::gooseai::ChainRequest>(Arena*);
template<> ::gooseai::ClassifierCategory* Arena::CreateMaybeMessage<::gooseai::ClassifierCategory>(Arena*);
template<> ::gooseai::ClassifierConcept* Arena::CreateMaybeMessage<::gooseai::ClassifierConcept>(Arena*);
template<> ::gooseai::ClassifierParameters* Arena::CreateMaybeMessage<::gooseai::ClassifierParameters>(Arena*);
template<> ::gooseai::ConditionerParameters* Arena::CreateMaybeMessage<::gooseai::ConditionerParameters>(Arena*);
template<> ::gooseai::CutoutParameters* Arena::CreateMaybeMessage<::gooseai::CutoutParameters>(Arena*);
template<> ::gooseai::GuidanceInstanceParameters* Arena::CreateMaybeMessage<::gooseai::GuidanceInstanceParameters>(Arena*);
template<> ::gooseai::GuidanceParameters* Arena::CreateMaybeMessage<::gooseai::GuidanceParameters>(Arena*);
template<> ::gooseai::GuidanceScheduleParameters* Arena::CreateMaybeMessage<::gooseai::GuidanceScheduleParameters>(Arena*);
template<> ::gooseai::ImageParameters* Arena::CreateMaybeMessage<::gooseai::ImageParameters>(Arena*);
template<> ::gooseai::Model* Arena::CreateMaybeMessage<::gooseai::Model>(Arena*);
template<> ::gooseai::OnStatus* Arena::CreateMaybeMessage<::gooseai::OnStatus>(Arena*);
template<> ::gooseai::Prompt* Arena::CreateMaybeMessage<::gooseai::Prompt>(Arena*);
template<> ::gooseai::PromptParameters* Arena::CreateMaybeMessage<::gooseai::PromptParameters>(Arena*);
template<> ::gooseai::Request* Arena::CreateMaybeMessage<::gooseai::Request>(Arena*);
template<> ::gooseai::SamplerParameters* Arena::CreateMaybeMessage<::gooseai::SamplerParameters>(Arena*);
template<> ::gooseai::ScheduleParameters* Arena::CreateMaybeMessage<::gooseai::ScheduleParameters>(Arena*);
template<> ::gooseai::Stage* Arena::CreateMaybeMessage<::gooseai::Stage>(Arena*);
template<> ::gooseai::StepParameter* Arena::CreateMaybeMessage<::gooseai::StepParameter>(Arena*);
template<> ::gooseai::Token* Arena::CreateMaybeMessage<::gooseai::Token>(Arena*);
template<> ::gooseai::Tokens* Arena::CreateMaybeMessage<::gooseai::Tokens>(Arena*);
template<> ::gooseai::TransformType* Arena::CreateMaybeMessage<::gooseai::TransformType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gooseai {

enum FinishReason : int {
  NULL_ = 0,
  LENGTH = 1,
  STOP = 2,
  ERROR = 3,
  FILTER = 4,
  FinishReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FinishReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FinishReason_IsValid(int value);
constexpr FinishReason FinishReason_MIN = NULL_;
constexpr FinishReason FinishReason_MAX = FILTER;
constexpr int FinishReason_ARRAYSIZE = FinishReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FinishReason_descriptor();
template<typename T>
inline const std::string& FinishReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FinishReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FinishReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FinishReason_descriptor(), enum_t_value);
}
inline bool FinishReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FinishReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FinishReason>(
    FinishReason_descriptor(), name, value);
}
enum ArtifactType : int {
  ARTIFACT_NONE = 0,
  ARTIFACT_IMAGE = 1,
  ARTIFACT_VIDEO = 2,
  ARTIFACT_TEXT = 3,
  ARTIFACT_TOKENS = 4,
  ARTIFACT_EMBEDDING = 5,
  ARTIFACT_CLASSIFICATIONS = 6,
  ARTIFACT_MASK = 7,
  ARTIFACT_LATENT = 8,
  ARTIFACT_TENSOR = 9,
  ArtifactType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArtifactType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArtifactType_IsValid(int value);
constexpr ArtifactType ArtifactType_MIN = ARTIFACT_NONE;
constexpr ArtifactType ArtifactType_MAX = ARTIFACT_TENSOR;
constexpr int ArtifactType_ARRAYSIZE = ArtifactType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactType_descriptor();
template<typename T>
inline const std::string& ArtifactType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactType_descriptor(), enum_t_value);
}
inline bool ArtifactType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactType>(
    ArtifactType_descriptor(), name, value);
}
enum MaskedAreaInit : int {
  MASKED_AREA_INIT_ZERO = 0,
  MASKED_AREA_INIT_RANDOM = 1,
  MASKED_AREA_INIT_ORIGINAL = 2,
  MaskedAreaInit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MaskedAreaInit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MaskedAreaInit_IsValid(int value);
constexpr MaskedAreaInit MaskedAreaInit_MIN = MASKED_AREA_INIT_ZERO;
constexpr MaskedAreaInit MaskedAreaInit_MAX = MASKED_AREA_INIT_ORIGINAL;
constexpr int MaskedAreaInit_ARRAYSIZE = MaskedAreaInit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MaskedAreaInit_descriptor();
template<typename T>
inline const std::string& MaskedAreaInit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MaskedAreaInit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MaskedAreaInit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MaskedAreaInit_descriptor(), enum_t_value);
}
inline bool MaskedAreaInit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MaskedAreaInit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MaskedAreaInit>(
    MaskedAreaInit_descriptor(), name, value);
}
enum WeightMethod : int {
  TEXT_ENCODER = 0,
  CROSS_ATTENTION = 1,
  WeightMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeightMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeightMethod_IsValid(int value);
constexpr WeightMethod WeightMethod_MIN = TEXT_ENCODER;
constexpr WeightMethod WeightMethod_MAX = CROSS_ATTENTION;
constexpr int WeightMethod_ARRAYSIZE = WeightMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeightMethod_descriptor();
template<typename T>
inline const std::string& WeightMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeightMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeightMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeightMethod_descriptor(), enum_t_value);
}
inline bool WeightMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeightMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeightMethod>(
    WeightMethod_descriptor(), name, value);
}
enum DiffusionSampler : int {
  SAMPLER_DDIM = 0,
  SAMPLER_DDPM = 1,
  SAMPLER_K_EULER = 2,
  SAMPLER_K_EULER_ANCESTRAL = 3,
  SAMPLER_K_HEUN = 4,
  SAMPLER_K_DPM_2 = 5,
  SAMPLER_K_DPM_2_ANCESTRAL = 6,
  SAMPLER_K_LMS = 7,
  SAMPLER_K_DPMPP_2S_ANCESTRAL = 8,
  SAMPLER_K_DPMPP_2M = 9,
  SAMPLER_K_DPMPP_SDE = 10,
  DiffusionSampler_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DiffusionSampler_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DiffusionSampler_IsValid(int value);
constexpr DiffusionSampler DiffusionSampler_MIN = SAMPLER_DDIM;
constexpr DiffusionSampler DiffusionSampler_MAX = SAMPLER_K_DPMPP_SDE;
constexpr int DiffusionSampler_ARRAYSIZE = DiffusionSampler_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DiffusionSampler_descriptor();
template<typename T>
inline const std::string& DiffusionSampler_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DiffusionSampler>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DiffusionSampler_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DiffusionSampler_descriptor(), enum_t_value);
}
inline bool DiffusionSampler_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DiffusionSampler* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DiffusionSampler>(
    DiffusionSampler_descriptor(), name, value);
}
enum Upscaler : int {
  UPSCALER_RGB = 0,
  UPSCALER_GFPGAN = 1,
  UPSCALER_ESRGAN = 2,
  Upscaler_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Upscaler_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Upscaler_IsValid(int value);
constexpr Upscaler Upscaler_MIN = UPSCALER_RGB;
constexpr Upscaler Upscaler_MAX = UPSCALER_ESRGAN;
constexpr int Upscaler_ARRAYSIZE = Upscaler_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Upscaler_descriptor();
template<typename T>
inline const std::string& Upscaler_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Upscaler>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Upscaler_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Upscaler_descriptor(), enum_t_value);
}
inline bool Upscaler_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Upscaler* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Upscaler>(
    Upscaler_descriptor(), name, value);
}
enum GuidancePreset : int {
  GUIDANCE_PRESET_NONE = 0,
  GUIDANCE_PRESET_SIMPLE = 1,
  GUIDANCE_PRESET_FAST_BLUE = 2,
  GUIDANCE_PRESET_FAST_GREEN = 3,
  GUIDANCE_PRESET_SLOW = 4,
  GUIDANCE_PRESET_SLOWER = 5,
  GUIDANCE_PRESET_SLOWEST = 6,
  GuidancePreset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GuidancePreset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GuidancePreset_IsValid(int value);
constexpr GuidancePreset GuidancePreset_MIN = GUIDANCE_PRESET_NONE;
constexpr GuidancePreset GuidancePreset_MAX = GUIDANCE_PRESET_SLOWEST;
constexpr int GuidancePreset_ARRAYSIZE = GuidancePreset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuidancePreset_descriptor();
template<typename T>
inline const std::string& GuidancePreset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuidancePreset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuidancePreset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GuidancePreset_descriptor(), enum_t_value);
}
inline bool GuidancePreset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GuidancePreset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GuidancePreset>(
    GuidancePreset_descriptor(), name, value);
}
enum ModelArchitecture : int {
  MODEL_ARCHITECTURE_NONE = 0,
  MODEL_ARCHITECTURE_CLIP_VIT = 1,
  MODEL_ARCHITECTURE_CLIP_RESNET = 2,
  MODEL_ARCHITECTURE_LDM = 3,
  ModelArchitecture_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelArchitecture_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModelArchitecture_IsValid(int value);
constexpr ModelArchitecture ModelArchitecture_MIN = MODEL_ARCHITECTURE_NONE;
constexpr ModelArchitecture ModelArchitecture_MAX = MODEL_ARCHITECTURE_LDM;
constexpr int ModelArchitecture_ARRAYSIZE = ModelArchitecture_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelArchitecture_descriptor();
template<typename T>
inline const std::string& ModelArchitecture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelArchitecture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelArchitecture_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelArchitecture_descriptor(), enum_t_value);
}
inline bool ModelArchitecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelArchitecture* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelArchitecture>(
    ModelArchitecture_descriptor(), name, value);
}
enum Action : int {
  ACTION_PASSTHROUGH = 0,
  ACTION_REGENERATE_DUPLICATE = 1,
  ACTION_REGENERATE = 2,
  ACTION_OBFUSCATE_DUPLICATE = 3,
  ACTION_OBFUSCATE = 4,
  ACTION_DISCARD = 5,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = ACTION_PASSTHROUGH;
constexpr Action Action_MAX = ACTION_DISCARD;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
enum ClassifierMode : int {
  CLSFR_MODE_ZEROSHOT = 0,
  CLSFR_MODE_MULTICLASS = 1,
  ClassifierMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClassifierMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClassifierMode_IsValid(int value);
constexpr ClassifierMode ClassifierMode_MIN = CLSFR_MODE_ZEROSHOT;
constexpr ClassifierMode ClassifierMode_MAX = CLSFR_MODE_MULTICLASS;
constexpr int ClassifierMode_ARRAYSIZE = ClassifierMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClassifierMode_descriptor();
template<typename T>
inline const std::string& ClassifierMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClassifierMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClassifierMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClassifierMode_descriptor(), enum_t_value);
}
inline bool ClassifierMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClassifierMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClassifierMode>(
    ClassifierMode_descriptor(), name, value);
}
enum AssetAction : int {
  ASSET_PUT = 0,
  ASSET_GET = 1,
  ASSET_DELETE = 2,
  AssetAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AssetAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AssetAction_IsValid(int value);
constexpr AssetAction AssetAction_MIN = ASSET_PUT;
constexpr AssetAction AssetAction_MAX = ASSET_DELETE;
constexpr int AssetAction_ARRAYSIZE = AssetAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AssetAction_descriptor();
template<typename T>
inline const std::string& AssetAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AssetAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AssetAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AssetAction_descriptor(), enum_t_value);
}
inline bool AssetAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AssetAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AssetAction>(
    AssetAction_descriptor(), name, value);
}
enum AssetUse : int {
  ASSET_USE_UNDEFINED = 0,
  ASSET_USE_INPUT = 1,
  ASSET_USE_OUTPUT = 2,
  ASSET_USE_INTERMEDIATE = 3,
  ASSET_USE_PROJECT = 4,
  AssetUse_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AssetUse_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AssetUse_IsValid(int value);
constexpr AssetUse AssetUse_MIN = ASSET_USE_UNDEFINED;
constexpr AssetUse AssetUse_MAX = ASSET_USE_PROJECT;
constexpr int AssetUse_ARRAYSIZE = AssetUse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AssetUse_descriptor();
template<typename T>
inline const std::string& AssetUse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AssetUse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AssetUse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AssetUse_descriptor(), enum_t_value);
}
inline bool AssetUse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AssetUse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AssetUse>(
    AssetUse_descriptor(), name, value);
}
enum StageAction : int {
  STAGE_ACTION_PASS = 0,
  STAGE_ACTION_DISCARD = 1,
  STAGE_ACTION_RETURN = 2,
  StageAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StageAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StageAction_IsValid(int value);
constexpr StageAction StageAction_MIN = STAGE_ACTION_PASS;
constexpr StageAction StageAction_MAX = STAGE_ACTION_RETURN;
constexpr int StageAction_ARRAYSIZE = StageAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StageAction_descriptor();
template<typename T>
inline const std::string& StageAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StageAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StageAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StageAction_descriptor(), enum_t_value);
}
inline bool StageAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StageAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StageAction>(
    StageAction_descriptor(), name, value);
}
// ===================================================================

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string text = 1 [json_name = "text"];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // uint32 id = 2 [json_name = "id"];
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    uint32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Tokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Tokens) */ {
 public:
  inline Tokens() : Tokens(nullptr) {}
  ~Tokens() override;
  explicit PROTOBUF_CONSTEXPR Tokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tokens(const Tokens& from);
  Tokens(Tokens&& from) noexcept
    : Tokens() {
    *this = ::std::move(from);
  }

  inline Tokens& operator=(const Tokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tokens& operator=(Tokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tokens* internal_default_instance() {
    return reinterpret_cast<const Tokens*>(
               &_Tokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Tokens& a, Tokens& b) {
    a.Swap(&b);
  }
  inline void Swap(Tokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tokens& from) {
    Tokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Tokens";
  }
  protected:
  explicit Tokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
    kTokenizerIdFieldNumber = 2,
  };
  // repeated .gooseai.Token tokens = 1 [json_name = "tokens"];
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::gooseai::Token* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Token >*
      mutable_tokens();
  private:
  const ::gooseai::Token& _internal_tokens(int index) const;
  ::gooseai::Token* _internal_add_tokens();
  public:
  const ::gooseai::Token& tokens(int index) const;
  ::gooseai::Token* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Token >&
      tokens() const;

  // optional string tokenizer_id = 2 [json_name = "tokenizerId"];
  bool has_tokenizer_id() const;
  private:
  bool _internal_has_tokenizer_id() const;
  public:
  void clear_tokenizer_id();
  const std::string& tokenizer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokenizer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokenizer_id();
  PROTOBUF_NODISCARD std::string* release_tokenizer_id();
  void set_allocated_tokenizer_id(std::string* tokenizer_id);
  private:
  const std::string& _internal_tokenizer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenizer_id(const std::string& value);
  std::string* _internal_mutable_tokenizer_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.Tokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Token > tokens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenizer_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Artifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Artifact) */ {
 public:
  inline Artifact() : Artifact(nullptr) {}
  ~Artifact() override;
  explicit PROTOBUF_CONSTEXPR Artifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Artifact(const Artifact& from);
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Artifact& operator=(Artifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Artifact& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kBinary = 5,
    kText = 6,
    kTokens = 7,
    kClassifier = 11,
    kTensor = 14,
    DATA_NOT_SET = 0,
  };

  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }
  inline void Swap(Artifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Artifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Artifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Artifact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Artifact& from) {
    Artifact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Artifact";
  }
  protected:
  explicit Artifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeFieldNumber = 3,
    kMagicFieldNumber = 4,
    kUuidFieldNumber = 12,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIndexFieldNumber = 8,
    kFinishReasonFieldNumber = 9,
    kSeedFieldNumber = 10,
    kSizeFieldNumber = 13,
    kBinaryFieldNumber = 5,
    kTextFieldNumber = 6,
    kTokensFieldNumber = 7,
    kClassifierFieldNumber = 11,
    kTensorFieldNumber = 14,
  };
  // string mime = 3 [json_name = "mime"];
  void clear_mime();
  const std::string& mime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime();
  PROTOBUF_NODISCARD std::string* release_mime();
  void set_allocated_mime(std::string* mime);
  private:
  const std::string& _internal_mime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime(const std::string& value);
  std::string* _internal_mutable_mime();
  public:

  // optional string magic = 4 [json_name = "magic"];
  bool has_magic() const;
  private:
  bool _internal_has_magic() const;
  public:
  void clear_magic();
  const std::string& magic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_magic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_magic();
  PROTOBUF_NODISCARD std::string* release_magic();
  void set_allocated_magic(std::string* magic);
  private:
  const std::string& _internal_magic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_magic(const std::string& value);
  std::string* _internal_mutable_magic();
  public:

  // string uuid = 12 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // uint64 id = 1 [json_name = "id"];
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .gooseai.ArtifactType type = 2 [json_name = "type"];
  void clear_type();
  ::gooseai::ArtifactType type() const;
  void set_type(::gooseai::ArtifactType value);
  private:
  ::gooseai::ArtifactType _internal_type() const;
  void _internal_set_type(::gooseai::ArtifactType value);
  public:

  // uint32 index = 8 [json_name = "index"];
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .gooseai.FinishReason finish_reason = 9 [json_name = "finishReason"];
  void clear_finish_reason();
  ::gooseai::FinishReason finish_reason() const;
  void set_finish_reason(::gooseai::FinishReason value);
  private:
  ::gooseai::FinishReason _internal_finish_reason() const;
  void _internal_set_finish_reason(::gooseai::FinishReason value);
  public:

  // uint32 seed = 10 [json_name = "seed"];
  void clear_seed();
  uint32_t seed() const;
  void set_seed(uint32_t value);
  private:
  uint32_t _internal_seed() const;
  void _internal_set_seed(uint32_t value);
  public:

  // uint64 size = 13 [json_name = "size"];
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // bytes binary = 5 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  // string text = 6 [json_name = "text"];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .gooseai.Tokens tokens = 7 [json_name = "tokens"];
  bool has_tokens() const;
  private:
  bool _internal_has_tokens() const;
  public:
  void clear_tokens();
  const ::gooseai::Tokens& tokens() const;
  PROTOBUF_NODISCARD ::gooseai::Tokens* release_tokens();
  ::gooseai::Tokens* mutable_tokens();
  void set_allocated_tokens(::gooseai::Tokens* tokens);
  private:
  const ::gooseai::Tokens& _internal_tokens() const;
  ::gooseai::Tokens* _internal_mutable_tokens();
  public:
  void unsafe_arena_set_allocated_tokens(
      ::gooseai::Tokens* tokens);
  ::gooseai::Tokens* unsafe_arena_release_tokens();

  // .gooseai.ClassifierParameters classifier = 11 [json_name = "classifier"];
  bool has_classifier() const;
  private:
  bool _internal_has_classifier() const;
  public:
  void clear_classifier();
  const ::gooseai::ClassifierParameters& classifier() const;
  PROTOBUF_NODISCARD ::gooseai::ClassifierParameters* release_classifier();
  ::gooseai::ClassifierParameters* mutable_classifier();
  void set_allocated_classifier(::gooseai::ClassifierParameters* classifier);
  private:
  const ::gooseai::ClassifierParameters& _internal_classifier() const;
  ::gooseai::ClassifierParameters* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::gooseai::ClassifierParameters* classifier);
  ::gooseai::ClassifierParameters* unsafe_arena_release_classifier();

  // .tensors.Tensor tensor = 14 [json_name = "tensor"];
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::tensors::Tensor& tensor() const;
  PROTOBUF_NODISCARD ::tensors::Tensor* release_tensor();
  ::tensors::Tensor* mutable_tensor();
  void set_allocated_tensor(::tensors::Tensor* tensor);
  private:
  const ::tensors::Tensor& _internal_tensor() const;
  ::tensors::Tensor* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::tensors::Tensor* tensor);
  ::tensors::Tensor* unsafe_arena_release_tensor();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:gooseai.Artifact)
 private:
  class _Internal;
  void set_has_binary();
  void set_has_text();
  void set_has_tokens();
  void set_has_classifier();
  void set_has_tensor();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr magic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    uint64_t id_;
    int type_;
    uint32_t index_;
    int finish_reason_;
    uint32_t seed_;
    uint64_t size_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      ::gooseai::Tokens* tokens_;
      ::gooseai::ClassifierParameters* classifier_;
      ::tensors::Tensor* tensor_;
    } data_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class PromptParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.PromptParameters) */ {
 public:
  inline PromptParameters() : PromptParameters(nullptr) {}
  ~PromptParameters() override;
  explicit PROTOBUF_CONSTEXPR PromptParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptParameters(const PromptParameters& from);
  PromptParameters(PromptParameters&& from) noexcept
    : PromptParameters() {
    *this = ::std::move(from);
  }

  inline PromptParameters& operator=(const PromptParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptParameters& operator=(PromptParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PromptParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptParameters* internal_default_instance() {
    return reinterpret_cast<const PromptParameters*>(
               &_PromptParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PromptParameters& a, PromptParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(PromptParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PromptParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PromptParameters& from) {
    PromptParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromptParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.PromptParameters";
  }
  protected:
  explicit PromptParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // optional bool init = 1 [json_name = "init"];
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  bool init() const;
  void set_init(bool value);
  private:
  bool _internal_init() const;
  void _internal_set_init(bool value);
  public:

  // optional float weight = 2 [json_name = "weight"];
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.PromptParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool init_;
    float weight_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Prompt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Prompt) */ {
 public:
  inline Prompt() : Prompt(nullptr) {}
  ~Prompt() override;
  explicit PROTOBUF_CONSTEXPR Prompt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Prompt(const Prompt& from);
  Prompt(Prompt&& from) noexcept
    : Prompt() {
    *this = ::std::move(from);
  }

  inline Prompt& operator=(const Prompt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt& operator=(Prompt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Prompt& default_instance() {
    return *internal_default_instance();
  }
  enum PromptCase {
    kText = 2,
    kTokens = 3,
    kArtifact = 4,
    PROMPT_NOT_SET = 0,
  };

  static inline const Prompt* internal_default_instance() {
    return reinterpret_cast<const Prompt*>(
               &_Prompt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Prompt& a, Prompt& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Prompt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Prompt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Prompt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Prompt& from) {
    Prompt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Prompt";
  }
  protected:
  explicit Prompt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 1,
    kTextFieldNumber = 2,
    kTokensFieldNumber = 3,
    kArtifactFieldNumber = 4,
  };
  // optional .gooseai.PromptParameters parameters = 1 [json_name = "parameters"];
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::gooseai::PromptParameters& parameters() const;
  PROTOBUF_NODISCARD ::gooseai::PromptParameters* release_parameters();
  ::gooseai::PromptParameters* mutable_parameters();
  void set_allocated_parameters(::gooseai::PromptParameters* parameters);
  private:
  const ::gooseai::PromptParameters& _internal_parameters() const;
  ::gooseai::PromptParameters* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::gooseai::PromptParameters* parameters);
  ::gooseai::PromptParameters* unsafe_arena_release_parameters();

  // string text = 2 [json_name = "text"];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .gooseai.Tokens tokens = 3 [json_name = "tokens"];
  bool has_tokens() const;
  private:
  bool _internal_has_tokens() const;
  public:
  void clear_tokens();
  const ::gooseai::Tokens& tokens() const;
  PROTOBUF_NODISCARD ::gooseai::Tokens* release_tokens();
  ::gooseai::Tokens* mutable_tokens();
  void set_allocated_tokens(::gooseai::Tokens* tokens);
  private:
  const ::gooseai::Tokens& _internal_tokens() const;
  ::gooseai::Tokens* _internal_mutable_tokens();
  public:
  void unsafe_arena_set_allocated_tokens(
      ::gooseai::Tokens* tokens);
  ::gooseai::Tokens* unsafe_arena_release_tokens();

  // .gooseai.Artifact artifact = 4 [json_name = "artifact"];
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::gooseai::Artifact& artifact() const;
  PROTOBUF_NODISCARD ::gooseai::Artifact* release_artifact();
  ::gooseai::Artifact* mutable_artifact();
  void set_allocated_artifact(::gooseai::Artifact* artifact);
  private:
  const ::gooseai::Artifact& _internal_artifact() const;
  ::gooseai::Artifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::gooseai::Artifact* artifact);
  ::gooseai::Artifact* unsafe_arena_release_artifact();

  void clear_prompt();
  PromptCase prompt_case() const;
  // @@protoc_insertion_point(class_scope:gooseai.Prompt)
 private:
  class _Internal;
  void set_has_text();
  void set_has_tokens();
  void set_has_artifact();

  inline bool has_prompt() const;
  inline void clear_has_prompt();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::gooseai::PromptParameters* parameters_;
    union PromptUnion {
      constexpr PromptUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      ::gooseai::Tokens* tokens_;
      ::gooseai::Artifact* artifact_;
    } prompt_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class SamplerParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.SamplerParameters) */ {
 public:
  inline SamplerParameters() : SamplerParameters(nullptr) {}
  ~SamplerParameters() override;
  explicit PROTOBUF_CONSTEXPR SamplerParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SamplerParameters(const SamplerParameters& from);
  SamplerParameters(SamplerParameters&& from) noexcept
    : SamplerParameters() {
    *this = ::std::move(from);
  }

  inline SamplerParameters& operator=(const SamplerParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamplerParameters& operator=(SamplerParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SamplerParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamplerParameters* internal_default_instance() {
    return reinterpret_cast<const SamplerParameters*>(
               &_SamplerParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SamplerParameters& a, SamplerParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(SamplerParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamplerParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamplerParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SamplerParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SamplerParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SamplerParameters& from) {
    SamplerParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SamplerParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.SamplerParameters";
  }
  protected:
  explicit SamplerParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplingStepsFieldNumber = 2,
    kLatentChannelsFieldNumber = 3,
    kEtaFieldNumber = 1,
    kCfgScaleFieldNumber = 5,
    kDownsamplingFactorFieldNumber = 4,
    kInitNoiseScaleFieldNumber = 6,
    kStepNoiseScaleFieldNumber = 7,
  };
  // optional uint64 sampling_steps = 2 [json_name = "samplingSteps"];
  bool has_sampling_steps() const;
  private:
  bool _internal_has_sampling_steps() const;
  public:
  void clear_sampling_steps();
  uint64_t sampling_steps() const;
  void set_sampling_steps(uint64_t value);
  private:
  uint64_t _internal_sampling_steps() const;
  void _internal_set_sampling_steps(uint64_t value);
  public:

  // optional uint64 latent_channels = 3 [json_name = "latentChannels"];
  bool has_latent_channels() const;
  private:
  bool _internal_has_latent_channels() const;
  public:
  void clear_latent_channels();
  uint64_t latent_channels() const;
  void set_latent_channels(uint64_t value);
  private:
  uint64_t _internal_latent_channels() const;
  void _internal_set_latent_channels(uint64_t value);
  public:

  // optional float eta = 1 [json_name = "eta"];
  bool has_eta() const;
  private:
  bool _internal_has_eta() const;
  public:
  void clear_eta();
  float eta() const;
  void set_eta(float value);
  private:
  float _internal_eta() const;
  void _internal_set_eta(float value);
  public:

  // optional float cfg_scale = 5 [json_name = "cfgScale"];
  bool has_cfg_scale() const;
  private:
  bool _internal_has_cfg_scale() const;
  public:
  void clear_cfg_scale();
  float cfg_scale() const;
  void set_cfg_scale(float value);
  private:
  float _internal_cfg_scale() const;
  void _internal_set_cfg_scale(float value);
  public:

  // optional uint64 downsampling_factor = 4 [json_name = "downsamplingFactor"];
  bool has_downsampling_factor() const;
  private:
  bool _internal_has_downsampling_factor() const;
  public:
  void clear_downsampling_factor();
  uint64_t downsampling_factor() const;
  void set_downsampling_factor(uint64_t value);
  private:
  uint64_t _internal_downsampling_factor() const;
  void _internal_set_downsampling_factor(uint64_t value);
  public:

  // optional float init_noise_scale = 6 [json_name = "initNoiseScale"];
  bool has_init_noise_scale() const;
  private:
  bool _internal_has_init_noise_scale() const;
  public:
  void clear_init_noise_scale();
  float init_noise_scale() const;
  void set_init_noise_scale(float value);
  private:
  float _internal_init_noise_scale() const;
  void _internal_set_init_noise_scale(float value);
  public:

  // optional float step_noise_scale = 7 [json_name = "stepNoiseScale"];
  bool has_step_noise_scale() const;
  private:
  bool _internal_has_step_noise_scale() const;
  public:
  void clear_step_noise_scale();
  float step_noise_scale() const;
  void set_step_noise_scale(float value);
  private:
  float _internal_step_noise_scale() const;
  void _internal_set_step_noise_scale(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.SamplerParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t sampling_steps_;
    uint64_t latent_channels_;
    float eta_;
    float cfg_scale_;
    uint64_t downsampling_factor_;
    float init_noise_scale_;
    float step_noise_scale_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ConditionerParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ConditionerParameters) */ {
 public:
  inline ConditionerParameters() : ConditionerParameters(nullptr) {}
  ~ConditionerParameters() override;
  explicit PROTOBUF_CONSTEXPR ConditionerParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConditionerParameters(const ConditionerParameters& from);
  ConditionerParameters(ConditionerParameters&& from) noexcept
    : ConditionerParameters() {
    *this = ::std::move(from);
  }

  inline ConditionerParameters& operator=(const ConditionerParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionerParameters& operator=(ConditionerParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionerParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionerParameters* internal_default_instance() {
    return reinterpret_cast<const ConditionerParameters*>(
               &_ConditionerParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConditionerParameters& a, ConditionerParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionerParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionerParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionerParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConditionerParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConditionerParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConditionerParameters& from) {
    ConditionerParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionerParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ConditionerParameters";
  }
  protected:
  explicit ConditionerParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorAdjustPriorFieldNumber = 1,
    kConditionerFieldNumber = 2,
  };
  // optional string vector_adjust_prior = 1 [json_name = "vectorAdjustPrior"];
  bool has_vector_adjust_prior() const;
  private:
  bool _internal_has_vector_adjust_prior() const;
  public:
  void clear_vector_adjust_prior();
  const std::string& vector_adjust_prior() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vector_adjust_prior(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vector_adjust_prior();
  PROTOBUF_NODISCARD std::string* release_vector_adjust_prior();
  void set_allocated_vector_adjust_prior(std::string* vector_adjust_prior);
  private:
  const std::string& _internal_vector_adjust_prior() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vector_adjust_prior(const std::string& value);
  std::string* _internal_mutable_vector_adjust_prior();
  public:

  // optional .gooseai.Model conditioner = 2 [json_name = "conditioner"];
  bool has_conditioner() const;
  private:
  bool _internal_has_conditioner() const;
  public:
  void clear_conditioner();
  const ::gooseai::Model& conditioner() const;
  PROTOBUF_NODISCARD ::gooseai::Model* release_conditioner();
  ::gooseai::Model* mutable_conditioner();
  void set_allocated_conditioner(::gooseai::Model* conditioner);
  private:
  const ::gooseai::Model& _internal_conditioner() const;
  ::gooseai::Model* _internal_mutable_conditioner();
  public:
  void unsafe_arena_set_allocated_conditioner(
      ::gooseai::Model* conditioner);
  ::gooseai::Model* unsafe_arena_release_conditioner();

  // @@protoc_insertion_point(class_scope:gooseai.ConditionerParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vector_adjust_prior_;
    ::gooseai::Model* conditioner_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ScheduleParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ScheduleParameters) */ {
 public:
  inline ScheduleParameters() : ScheduleParameters(nullptr) {}
  ~ScheduleParameters() override;
  explicit PROTOBUF_CONSTEXPR ScheduleParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleParameters(const ScheduleParameters& from);
  ScheduleParameters(ScheduleParameters&& from) noexcept
    : ScheduleParameters() {
    *this = ::std::move(from);
  }

  inline ScheduleParameters& operator=(const ScheduleParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleParameters& operator=(ScheduleParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleParameters* internal_default_instance() {
    return reinterpret_cast<const ScheduleParameters*>(
               &_ScheduleParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ScheduleParameters& a, ScheduleParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleParameters& from) {
    ScheduleParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ScheduleParameters";
  }
  protected:
  explicit ScheduleParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // optional float start = 1 [json_name = "start"];
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  float start() const;
  void set_start(float value);
  private:
  float _internal_start() const;
  void _internal_set_start(float value);
  public:

  // optional float end = 2 [json_name = "end"];
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  float end() const;
  void set_end(float value);
  private:
  float _internal_end() const;
  void _internal_set_end(float value);
  public:

  // optional float value = 3 [json_name = "value"];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ScheduleParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float start_;
    float end_;
    float value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class StepParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.StepParameter) */ {
 public:
  inline StepParameter() : StepParameter(nullptr) {}
  ~StepParameter() override;
  explicit PROTOBUF_CONSTEXPR StepParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepParameter(const StepParameter& from);
  StepParameter(StepParameter&& from) noexcept
    : StepParameter() {
    *this = ::std::move(from);
  }

  inline StepParameter& operator=(const StepParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepParameter& operator=(StepParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepParameter* internal_default_instance() {
    return reinterpret_cast<const StepParameter*>(
               &_StepParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StepParameter& a, StepParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(StepParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepParameter& from) {
    StepParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.StepParameter";
  }
  protected:
  explicit StepParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplerFieldNumber = 2,
    kScheduleFieldNumber = 3,
    kGuidanceFieldNumber = 4,
    kScaledStepFieldNumber = 1,
  };
  // optional .gooseai.SamplerParameters sampler = 2 [json_name = "sampler"];
  bool has_sampler() const;
  private:
  bool _internal_has_sampler() const;
  public:
  void clear_sampler();
  const ::gooseai::SamplerParameters& sampler() const;
  PROTOBUF_NODISCARD ::gooseai::SamplerParameters* release_sampler();
  ::gooseai::SamplerParameters* mutable_sampler();
  void set_allocated_sampler(::gooseai::SamplerParameters* sampler);
  private:
  const ::gooseai::SamplerParameters& _internal_sampler() const;
  ::gooseai::SamplerParameters* _internal_mutable_sampler();
  public:
  void unsafe_arena_set_allocated_sampler(
      ::gooseai::SamplerParameters* sampler);
  ::gooseai::SamplerParameters* unsafe_arena_release_sampler();

  // optional .gooseai.ScheduleParameters schedule = 3 [json_name = "schedule"];
  bool has_schedule() const;
  private:
  bool _internal_has_schedule() const;
  public:
  void clear_schedule();
  const ::gooseai::ScheduleParameters& schedule() const;
  PROTOBUF_NODISCARD ::gooseai::ScheduleParameters* release_schedule();
  ::gooseai::ScheduleParameters* mutable_schedule();
  void set_allocated_schedule(::gooseai::ScheduleParameters* schedule);
  private:
  const ::gooseai::ScheduleParameters& _internal_schedule() const;
  ::gooseai::ScheduleParameters* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::gooseai::ScheduleParameters* schedule);
  ::gooseai::ScheduleParameters* unsafe_arena_release_schedule();

  // optional .gooseai.GuidanceParameters guidance = 4 [json_name = "guidance"];
  bool has_guidance() const;
  private:
  bool _internal_has_guidance() const;
  public:
  void clear_guidance();
  const ::gooseai::GuidanceParameters& guidance() const;
  PROTOBUF_NODISCARD ::gooseai::GuidanceParameters* release_guidance();
  ::gooseai::GuidanceParameters* mutable_guidance();
  void set_allocated_guidance(::gooseai::GuidanceParameters* guidance);
  private:
  const ::gooseai::GuidanceParameters& _internal_guidance() const;
  ::gooseai::GuidanceParameters* _internal_mutable_guidance();
  public:
  void unsafe_arena_set_allocated_guidance(
      ::gooseai::GuidanceParameters* guidance);
  ::gooseai::GuidanceParameters* unsafe_arena_release_guidance();

  // float scaled_step = 1 [json_name = "scaledStep"];
  void clear_scaled_step();
  float scaled_step() const;
  void set_scaled_step(float value);
  private:
  float _internal_scaled_step() const;
  void _internal_set_scaled_step(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.StepParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::gooseai::SamplerParameters* sampler_;
    ::gooseai::ScheduleParameters* schedule_;
    ::gooseai::GuidanceParameters* guidance_;
    float scaled_step_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherFieldNumber = 2,
    kDatasetFieldNumber = 3,
    kSemanticVersionFieldNumber = 5,
    kAliasFieldNumber = 6,
    kArchitectureFieldNumber = 1,
    kVersionFieldNumber = 4,
  };
  // string publisher = 2 [json_name = "publisher"];
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // string dataset = 3 [json_name = "dataset"];
  void clear_dataset();
  const std::string& dataset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset();
  PROTOBUF_NODISCARD std::string* release_dataset();
  void set_allocated_dataset(std::string* dataset);
  private:
  const std::string& _internal_dataset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset(const std::string& value);
  std::string* _internal_mutable_dataset();
  public:

  // string semantic_version = 5 [json_name = "semanticVersion"];
  void clear_semantic_version();
  const std::string& semantic_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_semantic_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_semantic_version();
  PROTOBUF_NODISCARD std::string* release_semantic_version();
  void set_allocated_semantic_version(std::string* semantic_version);
  private:
  const std::string& _internal_semantic_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_semantic_version(const std::string& value);
  std::string* _internal_mutable_semantic_version();
  public:

  // string alias = 6 [json_name = "alias"];
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // .gooseai.ModelArchitecture architecture = 1 [json_name = "architecture"];
  void clear_architecture();
  ::gooseai::ModelArchitecture architecture() const;
  void set_architecture(::gooseai::ModelArchitecture value);
  private:
  ::gooseai::ModelArchitecture _internal_architecture() const;
  void _internal_set_architecture(::gooseai::ModelArchitecture value);
  public:

  // float version = 4 [json_name = "version"];
  void clear_version();
  float version() const;
  void set_version(float value);
  private:
  float _internal_version() const;
  void _internal_set_version(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr semantic_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    int architecture_;
    float version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class CutoutParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.CutoutParameters) */ {
 public:
  inline CutoutParameters() : CutoutParameters(nullptr) {}
  ~CutoutParameters() override;
  explicit PROTOBUF_CONSTEXPR CutoutParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CutoutParameters(const CutoutParameters& from);
  CutoutParameters(CutoutParameters&& from) noexcept
    : CutoutParameters() {
    *this = ::std::move(from);
  }

  inline CutoutParameters& operator=(const CutoutParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline CutoutParameters& operator=(CutoutParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CutoutParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const CutoutParameters* internal_default_instance() {
    return reinterpret_cast<const CutoutParameters*>(
               &_CutoutParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CutoutParameters& a, CutoutParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(CutoutParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CutoutParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CutoutParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CutoutParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CutoutParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CutoutParameters& from) {
    CutoutParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CutoutParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.CutoutParameters";
  }
  protected:
  explicit CutoutParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCutoutsFieldNumber = 1,
    kCountFieldNumber = 2,
    kGrayFieldNumber = 3,
    kBlurFieldNumber = 4,
    kSizePowerFieldNumber = 5,
  };
  // repeated .gooseai.CutoutParameters cutouts = 1 [json_name = "cutouts"];
  int cutouts_size() const;
  private:
  int _internal_cutouts_size() const;
  public:
  void clear_cutouts();
  ::gooseai::CutoutParameters* mutable_cutouts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::CutoutParameters >*
      mutable_cutouts();
  private:
  const ::gooseai::CutoutParameters& _internal_cutouts(int index) const;
  ::gooseai::CutoutParameters* _internal_add_cutouts();
  public:
  const ::gooseai::CutoutParameters& cutouts(int index) const;
  ::gooseai::CutoutParameters* add_cutouts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::CutoutParameters >&
      cutouts() const;

  // optional uint32 count = 2 [json_name = "count"];
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional float gray = 3 [json_name = "gray"];
  bool has_gray() const;
  private:
  bool _internal_has_gray() const;
  public:
  void clear_gray();
  float gray() const;
  void set_gray(float value);
  private:
  float _internal_gray() const;
  void _internal_set_gray(float value);
  public:

  // optional float blur = 4 [json_name = "blur"];
  bool has_blur() const;
  private:
  bool _internal_has_blur() const;
  public:
  void clear_blur();
  float blur() const;
  void set_blur(float value);
  private:
  float _internal_blur() const;
  void _internal_set_blur(float value);
  public:

  // optional float size_power = 5 [json_name = "sizePower"];
  bool has_size_power() const;
  private:
  bool _internal_has_size_power() const;
  public:
  void clear_size_power();
  float size_power() const;
  void set_size_power(float value);
  private:
  float _internal_size_power() const;
  void _internal_set_size_power(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.CutoutParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::CutoutParameters > cutouts_;
    uint32_t count_;
    float gray_;
    float blur_;
    float size_power_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class GuidanceScheduleParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GuidanceScheduleParameters) */ {
 public:
  inline GuidanceScheduleParameters() : GuidanceScheduleParameters(nullptr) {}
  ~GuidanceScheduleParameters() override;
  explicit PROTOBUF_CONSTEXPR GuidanceScheduleParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuidanceScheduleParameters(const GuidanceScheduleParameters& from);
  GuidanceScheduleParameters(GuidanceScheduleParameters&& from) noexcept
    : GuidanceScheduleParameters() {
    *this = ::std::move(from);
  }

  inline GuidanceScheduleParameters& operator=(const GuidanceScheduleParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuidanceScheduleParameters& operator=(GuidanceScheduleParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuidanceScheduleParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuidanceScheduleParameters* internal_default_instance() {
    return reinterpret_cast<const GuidanceScheduleParameters*>(
               &_GuidanceScheduleParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GuidanceScheduleParameters& a, GuidanceScheduleParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GuidanceScheduleParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuidanceScheduleParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuidanceScheduleParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuidanceScheduleParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuidanceScheduleParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuidanceScheduleParameters& from) {
    GuidanceScheduleParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuidanceScheduleParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GuidanceScheduleParameters";
  }
  protected:
  explicit GuidanceScheduleParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // float duration = 1 [json_name = "duration"];
  void clear_duration();
  float duration() const;
  void set_duration(float value);
  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);
  public:

  // float value = 2 [json_name = "value"];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GuidanceScheduleParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float duration_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class GuidanceInstanceParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GuidanceInstanceParameters) */ {
 public:
  inline GuidanceInstanceParameters() : GuidanceInstanceParameters(nullptr) {}
  ~GuidanceInstanceParameters() override;
  explicit PROTOBUF_CONSTEXPR GuidanceInstanceParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuidanceInstanceParameters(const GuidanceInstanceParameters& from);
  GuidanceInstanceParameters(GuidanceInstanceParameters&& from) noexcept
    : GuidanceInstanceParameters() {
    *this = ::std::move(from);
  }

  inline GuidanceInstanceParameters& operator=(const GuidanceInstanceParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuidanceInstanceParameters& operator=(GuidanceInstanceParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuidanceInstanceParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuidanceInstanceParameters* internal_default_instance() {
    return reinterpret_cast<const GuidanceInstanceParameters*>(
               &_GuidanceInstanceParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GuidanceInstanceParameters& a, GuidanceInstanceParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GuidanceInstanceParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuidanceInstanceParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuidanceInstanceParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuidanceInstanceParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuidanceInstanceParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuidanceInstanceParameters& from) {
    GuidanceInstanceParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuidanceInstanceParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GuidanceInstanceParameters";
  }
  protected:
  explicit GuidanceInstanceParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 2,
    kScheduleFieldNumber = 4,
    kCutoutsFieldNumber = 5,
    kPromptFieldNumber = 6,
    kGuidanceStrengthFieldNumber = 3,
  };
  // repeated .gooseai.Model models = 2 [json_name = "models"];
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::gooseai::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Model >*
      mutable_models();
  private:
  const ::gooseai::Model& _internal_models(int index) const;
  ::gooseai::Model* _internal_add_models();
  public:
  const ::gooseai::Model& models(int index) const;
  ::gooseai::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Model >&
      models() const;

  // repeated .gooseai.GuidanceScheduleParameters schedule = 4 [json_name = "schedule"];
  int schedule_size() const;
  private:
  int _internal_schedule_size() const;
  public:
  void clear_schedule();
  ::gooseai::GuidanceScheduleParameters* mutable_schedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceScheduleParameters >*
      mutable_schedule();
  private:
  const ::gooseai::GuidanceScheduleParameters& _internal_schedule(int index) const;
  ::gooseai::GuidanceScheduleParameters* _internal_add_schedule();
  public:
  const ::gooseai::GuidanceScheduleParameters& schedule(int index) const;
  ::gooseai::GuidanceScheduleParameters* add_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceScheduleParameters >&
      schedule() const;

  // optional .gooseai.CutoutParameters cutouts = 5 [json_name = "cutouts"];
  bool has_cutouts() const;
  private:
  bool _internal_has_cutouts() const;
  public:
  void clear_cutouts();
  const ::gooseai::CutoutParameters& cutouts() const;
  PROTOBUF_NODISCARD ::gooseai::CutoutParameters* release_cutouts();
  ::gooseai::CutoutParameters* mutable_cutouts();
  void set_allocated_cutouts(::gooseai::CutoutParameters* cutouts);
  private:
  const ::gooseai::CutoutParameters& _internal_cutouts() const;
  ::gooseai::CutoutParameters* _internal_mutable_cutouts();
  public:
  void unsafe_arena_set_allocated_cutouts(
      ::gooseai::CutoutParameters* cutouts);
  ::gooseai::CutoutParameters* unsafe_arena_release_cutouts();

  // optional .gooseai.Prompt prompt = 6 [json_name = "prompt"];
  bool has_prompt() const;
  private:
  bool _internal_has_prompt() const;
  public:
  void clear_prompt();
  const ::gooseai::Prompt& prompt() const;
  PROTOBUF_NODISCARD ::gooseai::Prompt* release_prompt();
  ::gooseai::Prompt* mutable_prompt();
  void set_allocated_prompt(::gooseai::Prompt* prompt);
  private:
  const ::gooseai::Prompt& _internal_prompt() const;
  ::gooseai::Prompt* _internal_mutable_prompt();
  public:
  void unsafe_arena_set_allocated_prompt(
      ::gooseai::Prompt* prompt);
  ::gooseai::Prompt* unsafe_arena_release_prompt();

  // optional float guidance_strength = 3 [json_name = "guidanceStrength"];
  bool has_guidance_strength() const;
  private:
  bool _internal_has_guidance_strength() const;
  public:
  void clear_guidance_strength();
  float guidance_strength() const;
  void set_guidance_strength(float value);
  private:
  float _internal_guidance_strength() const;
  void _internal_set_guidance_strength(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GuidanceInstanceParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Model > models_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceScheduleParameters > schedule_;
    ::gooseai::CutoutParameters* cutouts_;
    ::gooseai::Prompt* prompt_;
    float guidance_strength_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class GuidanceParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.GuidanceParameters) */ {
 public:
  inline GuidanceParameters() : GuidanceParameters(nullptr) {}
  ~GuidanceParameters() override;
  explicit PROTOBUF_CONSTEXPR GuidanceParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuidanceParameters(const GuidanceParameters& from);
  GuidanceParameters(GuidanceParameters&& from) noexcept
    : GuidanceParameters() {
    *this = ::std::move(from);
  }

  inline GuidanceParameters& operator=(const GuidanceParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuidanceParameters& operator=(GuidanceParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuidanceParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuidanceParameters* internal_default_instance() {
    return reinterpret_cast<const GuidanceParameters*>(
               &_GuidanceParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GuidanceParameters& a, GuidanceParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GuidanceParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuidanceParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuidanceParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuidanceParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuidanceParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuidanceParameters& from) {
    GuidanceParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuidanceParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.GuidanceParameters";
  }
  protected:
  explicit GuidanceParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 2,
    kGuidancePresetFieldNumber = 1,
  };
  // repeated .gooseai.GuidanceInstanceParameters instances = 2 [json_name = "instances"];
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::gooseai::GuidanceInstanceParameters* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceInstanceParameters >*
      mutable_instances();
  private:
  const ::gooseai::GuidanceInstanceParameters& _internal_instances(int index) const;
  ::gooseai::GuidanceInstanceParameters* _internal_add_instances();
  public:
  const ::gooseai::GuidanceInstanceParameters& instances(int index) const;
  ::gooseai::GuidanceInstanceParameters* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceInstanceParameters >&
      instances() const;

  // .gooseai.GuidancePreset guidance_preset = 1 [json_name = "guidancePreset"];
  void clear_guidance_preset();
  ::gooseai::GuidancePreset guidance_preset() const;
  void set_guidance_preset(::gooseai::GuidancePreset value);
  private:
  ::gooseai::GuidancePreset _internal_guidance_preset() const;
  void _internal_set_guidance_preset(::gooseai::GuidancePreset value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.GuidanceParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceInstanceParameters > instances_;
    int guidance_preset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class TransformType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.TransformType) */ {
 public:
  inline TransformType() : TransformType(nullptr) {}
  ~TransformType() override;
  explicit PROTOBUF_CONSTEXPR TransformType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformType(const TransformType& from);
  TransformType(TransformType&& from) noexcept
    : TransformType() {
    *this = ::std::move(from);
  }

  inline TransformType& operator=(const TransformType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformType& operator=(TransformType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformType& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kDiffusion = 1,
    kUpscaler = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const TransformType* internal_default_instance() {
    return reinterpret_cast<const TransformType*>(
               &_TransformType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransformType& a, TransformType& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformType& from) {
    TransformType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.TransformType";
  }
  protected:
  explicit TransformType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffusionFieldNumber = 1,
    kUpscalerFieldNumber = 2,
  };
  // .gooseai.DiffusionSampler diffusion = 1 [json_name = "diffusion"];
  bool has_diffusion() const;
  private:
  bool _internal_has_diffusion() const;
  public:
  void clear_diffusion();
  ::gooseai::DiffusionSampler diffusion() const;
  void set_diffusion(::gooseai::DiffusionSampler value);
  private:
  ::gooseai::DiffusionSampler _internal_diffusion() const;
  void _internal_set_diffusion(::gooseai::DiffusionSampler value);
  public:

  // .gooseai.Upscaler upscaler = 2 [json_name = "upscaler"];
  bool has_upscaler() const;
  private:
  bool _internal_has_upscaler() const;
  public:
  void clear_upscaler();
  ::gooseai::Upscaler upscaler() const;
  void set_upscaler(::gooseai::Upscaler value);
  private:
  ::gooseai::Upscaler _internal_upscaler() const;
  void _internal_set_upscaler(::gooseai::Upscaler value);
  public:

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:gooseai.TransformType)
 private:
  class _Internal;
  void set_has_diffusion();
  void set_has_upscaler();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int diffusion_;
      int upscaler_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ImageParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ImageParameters) */ {
 public:
  inline ImageParameters() : ImageParameters(nullptr) {}
  ~ImageParameters() override;
  explicit PROTOBUF_CONSTEXPR ImageParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageParameters(const ImageParameters& from);
  ImageParameters(ImageParameters&& from) noexcept
    : ImageParameters() {
    *this = ::std::move(from);
  }

  inline ImageParameters& operator=(const ImageParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageParameters& operator=(ImageParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageParameters* internal_default_instance() {
    return reinterpret_cast<const ImageParameters*>(
               &_ImageParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImageParameters& a, ImageParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageParameters& from) {
    ImageParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ImageParameters";
  }
  protected:
  explicit ImageParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 3,
    kParametersFieldNumber = 7,
    kTransformFieldNumber = 6,
    kHeightFieldNumber = 1,
    kWidthFieldNumber = 2,
    kSamplesFieldNumber = 4,
    kStepsFieldNumber = 5,
    kMaskedAreaInitFieldNumber = 8,
    kWeightMethodFieldNumber = 9,
    kQuantizeFieldNumber = 10,
  };
  // repeated uint32 seed = 3 [json_name = "seed"];
  int seed_size() const;
  private:
  int _internal_seed_size() const;
  public:
  void clear_seed();
  private:
  uint32_t _internal_seed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_seed() const;
  void _internal_add_seed(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_seed();
  public:
  uint32_t seed(int index) const;
  void set_seed(int index, uint32_t value);
  void add_seed(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      seed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_seed();

  // repeated .gooseai.StepParameter parameters = 7 [json_name = "parameters"];
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::gooseai::StepParameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::StepParameter >*
      mutable_parameters();
  private:
  const ::gooseai::StepParameter& _internal_parameters(int index) const;
  ::gooseai::StepParameter* _internal_add_parameters();
  public:
  const ::gooseai::StepParameter& parameters(int index) const;
  ::gooseai::StepParameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::StepParameter >&
      parameters() const;

  // optional .gooseai.TransformType transform = 6 [json_name = "transform"];
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::gooseai::TransformType& transform() const;
  PROTOBUF_NODISCARD ::gooseai::TransformType* release_transform();
  ::gooseai::TransformType* mutable_transform();
  void set_allocated_transform(::gooseai::TransformType* transform);
  private:
  const ::gooseai::TransformType& _internal_transform() const;
  ::gooseai::TransformType* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::gooseai::TransformType* transform);
  ::gooseai::TransformType* unsafe_arena_release_transform();

  // optional uint64 height = 1 [json_name = "height"];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // optional uint64 width = 2 [json_name = "width"];
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint64_t width() const;
  void set_width(uint64_t value);
  private:
  uint64_t _internal_width() const;
  void _internal_set_width(uint64_t value);
  public:

  // optional uint64 samples = 4 [json_name = "samples"];
  bool has_samples() const;
  private:
  bool _internal_has_samples() const;
  public:
  void clear_samples();
  uint64_t samples() const;
  void set_samples(uint64_t value);
  private:
  uint64_t _internal_samples() const;
  void _internal_set_samples(uint64_t value);
  public:

  // optional uint64 steps = 5 [json_name = "steps"];
  bool has_steps() const;
  private:
  bool _internal_has_steps() const;
  public:
  void clear_steps();
  uint64_t steps() const;
  void set_steps(uint64_t value);
  private:
  uint64_t _internal_steps() const;
  void _internal_set_steps(uint64_t value);
  public:

  // optional .gooseai.MaskedAreaInit masked_area_init = 8 [json_name = "maskedAreaInit"];
  bool has_masked_area_init() const;
  private:
  bool _internal_has_masked_area_init() const;
  public:
  void clear_masked_area_init();
  ::gooseai::MaskedAreaInit masked_area_init() const;
  void set_masked_area_init(::gooseai::MaskedAreaInit value);
  private:
  ::gooseai::MaskedAreaInit _internal_masked_area_init() const;
  void _internal_set_masked_area_init(::gooseai::MaskedAreaInit value);
  public:

  // optional .gooseai.WeightMethod weight_method = 9 [json_name = "weightMethod"];
  bool has_weight_method() const;
  private:
  bool _internal_has_weight_method() const;
  public:
  void clear_weight_method();
  ::gooseai::WeightMethod weight_method() const;
  void set_weight_method(::gooseai::WeightMethod value);
  private:
  ::gooseai::WeightMethod _internal_weight_method() const;
  void _internal_set_weight_method(::gooseai::WeightMethod value);
  public:

  // optional bool quantize = 10 [json_name = "quantize"];
  bool has_quantize() const;
  private:
  bool _internal_has_quantize() const;
  public:
  void clear_quantize();
  bool quantize() const;
  void set_quantize(bool value);
  private:
  bool _internal_quantize() const;
  void _internal_set_quantize(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ImageParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > seed_;
    mutable std::atomic<int> _seed_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::StepParameter > parameters_;
    ::gooseai::TransformType* transform_;
    uint64_t height_;
    uint64_t width_;
    uint64_t samples_;
    uint64_t steps_;
    int masked_area_init_;
    int weight_method_;
    bool quantize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ClassifierConcept final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ClassifierConcept) */ {
 public:
  inline ClassifierConcept() : ClassifierConcept(nullptr) {}
  ~ClassifierConcept() override;
  explicit PROTOBUF_CONSTEXPR ClassifierConcept(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassifierConcept(const ClassifierConcept& from);
  ClassifierConcept(ClassifierConcept&& from) noexcept
    : ClassifierConcept() {
    *this = ::std::move(from);
  }

  inline ClassifierConcept& operator=(const ClassifierConcept& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifierConcept& operator=(ClassifierConcept&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassifierConcept& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassifierConcept* internal_default_instance() {
    return reinterpret_cast<const ClassifierConcept*>(
               &_ClassifierConcept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ClassifierConcept& a, ClassifierConcept& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassifierConcept* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifierConcept* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassifierConcept* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassifierConcept>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassifierConcept& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassifierConcept& from) {
    ClassifierConcept::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassifierConcept* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ClassifierConcept";
  }
  protected:
  explicit ClassifierConcept(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptFieldNumber = 1,
    kThresholdFieldNumber = 2,
  };
  // string concept = 1 [json_name = "concept"];
  void clear_concept();
  const std::string& concept() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_concept(ArgT0&& arg0, ArgT... args);
  std::string* mutable_concept();
  PROTOBUF_NODISCARD std::string* release_concept();
  void set_allocated_concept(std::string* concept);
  private:
  const std::string& _internal_concept() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concept(const std::string& value);
  std::string* _internal_mutable_concept();
  public:

  // optional float threshold = 2 [json_name = "threshold"];
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);
  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ClassifierConcept)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr concept_;
    float threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ClassifierCategory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ClassifierCategory) */ {
 public:
  inline ClassifierCategory() : ClassifierCategory(nullptr) {}
  ~ClassifierCategory() override;
  explicit PROTOBUF_CONSTEXPR ClassifierCategory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassifierCategory(const ClassifierCategory& from);
  ClassifierCategory(ClassifierCategory&& from) noexcept
    : ClassifierCategory() {
    *this = ::std::move(from);
  }

  inline ClassifierCategory& operator=(const ClassifierCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifierCategory& operator=(ClassifierCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassifierCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassifierCategory* internal_default_instance() {
    return reinterpret_cast<const ClassifierCategory*>(
               &_ClassifierCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ClassifierCategory& a, ClassifierCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassifierCategory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifierCategory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassifierCategory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassifierCategory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassifierCategory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassifierCategory& from) {
    ClassifierCategory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassifierCategory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ClassifierCategory";
  }
  protected:
  explicit ClassifierCategory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConceptsFieldNumber = 2,
    kNameFieldNumber = 1,
    kAdjustmentFieldNumber = 3,
    kActionFieldNumber = 4,
    kClassifierModeFieldNumber = 5,
  };
  // repeated .gooseai.ClassifierConcept concepts = 2 [json_name = "concepts"];
  int concepts_size() const;
  private:
  int _internal_concepts_size() const;
  public:
  void clear_concepts();
  ::gooseai::ClassifierConcept* mutable_concepts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierConcept >*
      mutable_concepts();
  private:
  const ::gooseai::ClassifierConcept& _internal_concepts(int index) const;
  ::gooseai::ClassifierConcept* _internal_add_concepts();
  public:
  const ::gooseai::ClassifierConcept& concepts(int index) const;
  ::gooseai::ClassifierConcept* add_concepts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierConcept >&
      concepts() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional float adjustment = 3 [json_name = "adjustment"];
  bool has_adjustment() const;
  private:
  bool _internal_has_adjustment() const;
  public:
  void clear_adjustment();
  float adjustment() const;
  void set_adjustment(float value);
  private:
  float _internal_adjustment() const;
  void _internal_set_adjustment(float value);
  public:

  // optional .gooseai.Action action = 4 [json_name = "action"];
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::gooseai::Action action() const;
  void set_action(::gooseai::Action value);
  private:
  ::gooseai::Action _internal_action() const;
  void _internal_set_action(::gooseai::Action value);
  public:

  // optional .gooseai.ClassifierMode classifier_mode = 5 [json_name = "classifierMode"];
  bool has_classifier_mode() const;
  private:
  bool _internal_has_classifier_mode() const;
  public:
  void clear_classifier_mode();
  ::gooseai::ClassifierMode classifier_mode() const;
  void set_classifier_mode(::gooseai::ClassifierMode value);
  private:
  ::gooseai::ClassifierMode _internal_classifier_mode() const;
  void _internal_set_classifier_mode(::gooseai::ClassifierMode value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ClassifierCategory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierConcept > concepts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    float adjustment_;
    int action_;
    int classifier_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ClassifierParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ClassifierParameters) */ {
 public:
  inline ClassifierParameters() : ClassifierParameters(nullptr) {}
  ~ClassifierParameters() override;
  explicit PROTOBUF_CONSTEXPR ClassifierParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassifierParameters(const ClassifierParameters& from);
  ClassifierParameters(ClassifierParameters&& from) noexcept
    : ClassifierParameters() {
    *this = ::std::move(from);
  }

  inline ClassifierParameters& operator=(const ClassifierParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifierParameters& operator=(ClassifierParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassifierParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassifierParameters* internal_default_instance() {
    return reinterpret_cast<const ClassifierParameters*>(
               &_ClassifierParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ClassifierParameters& a, ClassifierParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassifierParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifierParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassifierParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassifierParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassifierParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassifierParameters& from) {
    ClassifierParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassifierParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ClassifierParameters";
  }
  protected:
  explicit ClassifierParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 1,
    kExceedsFieldNumber = 2,
    kRealizedActionFieldNumber = 3,
  };
  // repeated .gooseai.ClassifierCategory categories = 1 [json_name = "categories"];
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  ::gooseai::ClassifierCategory* mutable_categories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >*
      mutable_categories();
  private:
  const ::gooseai::ClassifierCategory& _internal_categories(int index) const;
  ::gooseai::ClassifierCategory* _internal_add_categories();
  public:
  const ::gooseai::ClassifierCategory& categories(int index) const;
  ::gooseai::ClassifierCategory* add_categories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >&
      categories() const;

  // repeated .gooseai.ClassifierCategory exceeds = 2 [json_name = "exceeds"];
  int exceeds_size() const;
  private:
  int _internal_exceeds_size() const;
  public:
  void clear_exceeds();
  ::gooseai::ClassifierCategory* mutable_exceeds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >*
      mutable_exceeds();
  private:
  const ::gooseai::ClassifierCategory& _internal_exceeds(int index) const;
  ::gooseai::ClassifierCategory* _internal_add_exceeds();
  public:
  const ::gooseai::ClassifierCategory& exceeds(int index) const;
  ::gooseai::ClassifierCategory* add_exceeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >&
      exceeds() const;

  // optional .gooseai.Action realized_action = 3 [json_name = "realizedAction"];
  bool has_realized_action() const;
  private:
  bool _internal_has_realized_action() const;
  public:
  void clear_realized_action();
  ::gooseai::Action realized_action() const;
  void set_realized_action(::gooseai::Action value);
  private:
  ::gooseai::Action _internal_realized_action() const;
  void _internal_set_realized_action(::gooseai::Action value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ClassifierParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory > categories_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory > exceeds_;
    int realized_action_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class AssetParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.AssetParameters) */ {
 public:
  inline AssetParameters() : AssetParameters(nullptr) {}
  ~AssetParameters() override;
  explicit PROTOBUF_CONSTEXPR AssetParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetParameters(const AssetParameters& from);
  AssetParameters(AssetParameters&& from) noexcept
    : AssetParameters() {
    *this = ::std::move(from);
  }

  inline AssetParameters& operator=(const AssetParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetParameters& operator=(AssetParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetParameters* internal_default_instance() {
    return reinterpret_cast<const AssetParameters*>(
               &_AssetParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AssetParameters& a, AssetParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetParameters& from) {
    AssetParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.AssetParameters";
  }
  protected:
  explicit AssetParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 2,
    kActionFieldNumber = 1,
    kUseFieldNumber = 3,
  };
  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // .gooseai.AssetAction action = 1 [json_name = "action"];
  void clear_action();
  ::gooseai::AssetAction action() const;
  void set_action(::gooseai::AssetAction value);
  private:
  ::gooseai::AssetAction _internal_action() const;
  void _internal_set_action(::gooseai::AssetAction value);
  public:

  // .gooseai.AssetUse use = 3 [json_name = "use"];
  void clear_use();
  ::gooseai::AssetUse use() const;
  void set_use(::gooseai::AssetUse value);
  private:
  ::gooseai::AssetUse _internal_use() const;
  void _internal_set_use(::gooseai::AssetUse value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.AssetParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
    int action_;
    int use_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class AnswerMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.AnswerMeta) */ {
 public:
  inline AnswerMeta() : AnswerMeta(nullptr) {}
  ~AnswerMeta() override;
  explicit PROTOBUF_CONSTEXPR AnswerMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerMeta(const AnswerMeta& from);
  AnswerMeta(AnswerMeta&& from) noexcept
    : AnswerMeta() {
    *this = ::std::move(from);
  }

  inline AnswerMeta& operator=(const AnswerMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerMeta& operator=(AnswerMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerMeta* internal_default_instance() {
    return reinterpret_cast<const AnswerMeta*>(
               &_AnswerMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AnswerMeta& a, AnswerMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerMeta& from) {
    AnswerMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.AnswerMeta";
  }
  protected:
  explicit AnswerMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGpuIdFieldNumber = 1,
    kCpuIdFieldNumber = 2,
    kNodeIdFieldNumber = 3,
    kEngineIdFieldNumber = 4,
  };
  // optional string gpu_id = 1 [json_name = "gpuId"];
  bool has_gpu_id() const;
  private:
  bool _internal_has_gpu_id() const;
  public:
  void clear_gpu_id();
  const std::string& gpu_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpu_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpu_id();
  PROTOBUF_NODISCARD std::string* release_gpu_id();
  void set_allocated_gpu_id(std::string* gpu_id);
  private:
  const std::string& _internal_gpu_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpu_id(const std::string& value);
  std::string* _internal_mutable_gpu_id();
  public:

  // optional string cpu_id = 2 [json_name = "cpuId"];
  bool has_cpu_id() const;
  private:
  bool _internal_has_cpu_id() const;
  public:
  void clear_cpu_id();
  const std::string& cpu_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpu_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpu_id();
  PROTOBUF_NODISCARD std::string* release_cpu_id();
  void set_allocated_cpu_id(std::string* cpu_id);
  private:
  const std::string& _internal_cpu_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpu_id(const std::string& value);
  std::string* _internal_mutable_cpu_id();
  public:

  // optional string node_id = 3 [json_name = "nodeId"];
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // optional string engine_id = 4 [json_name = "engineId"];
  bool has_engine_id() const;
  private:
  bool _internal_has_engine_id() const;
  public:
  void clear_engine_id();
  const std::string& engine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine_id();
  PROTOBUF_NODISCARD std::string* release_engine_id();
  void set_allocated_engine_id(std::string* engine_id);
  private:
  const std::string& _internal_engine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine_id(const std::string& value);
  std::string* _internal_mutable_engine_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.AnswerMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpu_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit PROTOBUF_CONSTEXPR Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Answer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Answer& from) {
    Answer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsFieldNumber = 7,
    kAnswerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kMetaFieldNumber = 6,
    kReceivedFieldNumber = 3,
    kCreatedFieldNumber = 4,
  };
  // repeated .gooseai.Artifact artifacts = 7 [json_name = "artifacts"];
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  ::gooseai::Artifact* mutable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Artifact >*
      mutable_artifacts();
  private:
  const ::gooseai::Artifact& _internal_artifacts(int index) const;
  ::gooseai::Artifact* _internal_add_artifacts();
  public:
  const ::gooseai::Artifact& artifacts(int index) const;
  ::gooseai::Artifact* add_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Artifact >&
      artifacts() const;

  // string answer_id = 1 [json_name = "answerId"];
  void clear_answer_id();
  const std::string& answer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_answer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_answer_id();
  PROTOBUF_NODISCARD std::string* release_answer_id();
  void set_allocated_answer_id(std::string* answer_id);
  private:
  const std::string& _internal_answer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer_id(const std::string& value);
  std::string* _internal_mutable_answer_id();
  public:

  // string request_id = 2 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional .gooseai.AnswerMeta meta = 6 [json_name = "meta"];
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::gooseai::AnswerMeta& meta() const;
  PROTOBUF_NODISCARD ::gooseai::AnswerMeta* release_meta();
  ::gooseai::AnswerMeta* mutable_meta();
  void set_allocated_meta(::gooseai::AnswerMeta* meta);
  private:
  const ::gooseai::AnswerMeta& _internal_meta() const;
  ::gooseai::AnswerMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::gooseai::AnswerMeta* meta);
  ::gooseai::AnswerMeta* unsafe_arena_release_meta();

  // uint64 received = 3 [json_name = "received"];
  void clear_received();
  uint64_t received() const;
  void set_received(uint64_t value);
  private:
  uint64_t _internal_received() const;
  void _internal_set_received(uint64_t value);
  public:

  // uint64 created = 4 [json_name = "created"];
  void clear_created();
  uint64_t created() const;
  void set_created(uint64_t value);
  private:
  uint64_t _internal_created() const;
  void _internal_set_created(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gooseai.Answer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Artifact > artifacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::gooseai::AnswerMeta* meta_;
    uint64_t received_;
    uint64_t created_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum ParamsCase {
    kImage = 5,
    kClassifier = 7,
    kAsset = 8,
    PARAMS_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPromptFieldNumber = 4,
    kEngineIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kConditionerFieldNumber = 6,
    kRequestedTypeFieldNumber = 3,
    kImageFieldNumber = 5,
    kClassifierFieldNumber = 7,
    kAssetFieldNumber = 8,
  };
  // repeated .gooseai.Prompt prompt = 4 [json_name = "prompt"];
  int prompt_size() const;
  private:
  int _internal_prompt_size() const;
  public:
  void clear_prompt();
  ::gooseai::Prompt* mutable_prompt(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Prompt >*
      mutable_prompt();
  private:
  const ::gooseai::Prompt& _internal_prompt(int index) const;
  ::gooseai::Prompt* _internal_add_prompt();
  public:
  const ::gooseai::Prompt& prompt(int index) const;
  ::gooseai::Prompt* add_prompt();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Prompt >&
      prompt() const;

  // string engine_id = 1 [json_name = "engineId"];
  void clear_engine_id();
  const std::string& engine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine_id();
  PROTOBUF_NODISCARD std::string* release_engine_id();
  void set_allocated_engine_id(std::string* engine_id);
  private:
  const std::string& _internal_engine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine_id(const std::string& value);
  std::string* _internal_mutable_engine_id();
  public:

  // string request_id = 2 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional .gooseai.ConditionerParameters conditioner = 6 [json_name = "conditioner"];
  bool has_conditioner() const;
  private:
  bool _internal_has_conditioner() const;
  public:
  void clear_conditioner();
  const ::gooseai::ConditionerParameters& conditioner() const;
  PROTOBUF_NODISCARD ::gooseai::ConditionerParameters* release_conditioner();
  ::gooseai::ConditionerParameters* mutable_conditioner();
  void set_allocated_conditioner(::gooseai::ConditionerParameters* conditioner);
  private:
  const ::gooseai::ConditionerParameters& _internal_conditioner() const;
  ::gooseai::ConditionerParameters* _internal_mutable_conditioner();
  public:
  void unsafe_arena_set_allocated_conditioner(
      ::gooseai::ConditionerParameters* conditioner);
  ::gooseai::ConditionerParameters* unsafe_arena_release_conditioner();

  // .gooseai.ArtifactType requested_type = 3 [json_name = "requestedType"];
  void clear_requested_type();
  ::gooseai::ArtifactType requested_type() const;
  void set_requested_type(::gooseai::ArtifactType value);
  private:
  ::gooseai::ArtifactType _internal_requested_type() const;
  void _internal_set_requested_type(::gooseai::ArtifactType value);
  public:

  // .gooseai.ImageParameters image = 5 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::gooseai::ImageParameters& image() const;
  PROTOBUF_NODISCARD ::gooseai::ImageParameters* release_image();
  ::gooseai::ImageParameters* mutable_image();
  void set_allocated_image(::gooseai::ImageParameters* image);
  private:
  const ::gooseai::ImageParameters& _internal_image() const;
  ::gooseai::ImageParameters* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::gooseai::ImageParameters* image);
  ::gooseai::ImageParameters* unsafe_arena_release_image();

  // .gooseai.ClassifierParameters classifier = 7 [json_name = "classifier"];
  bool has_classifier() const;
  private:
  bool _internal_has_classifier() const;
  public:
  void clear_classifier();
  const ::gooseai::ClassifierParameters& classifier() const;
  PROTOBUF_NODISCARD ::gooseai::ClassifierParameters* release_classifier();
  ::gooseai::ClassifierParameters* mutable_classifier();
  void set_allocated_classifier(::gooseai::ClassifierParameters* classifier);
  private:
  const ::gooseai::ClassifierParameters& _internal_classifier() const;
  ::gooseai::ClassifierParameters* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::gooseai::ClassifierParameters* classifier);
  ::gooseai::ClassifierParameters* unsafe_arena_release_classifier();

  // .gooseai.AssetParameters asset = 8 [json_name = "asset"];
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::gooseai::AssetParameters& asset() const;
  PROTOBUF_NODISCARD ::gooseai::AssetParameters* release_asset();
  ::gooseai::AssetParameters* mutable_asset();
  void set_allocated_asset(::gooseai::AssetParameters* asset);
  private:
  const ::gooseai::AssetParameters& _internal_asset() const;
  ::gooseai::AssetParameters* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::gooseai::AssetParameters* asset);
  ::gooseai::AssetParameters* unsafe_arena_release_asset();

  void clear_params();
  ParamsCase params_case() const;
  // @@protoc_insertion_point(class_scope:gooseai.Request)
 private:
  class _Internal;
  void set_has_image();
  void set_has_classifier();
  void set_has_asset();

  inline bool has_params() const;
  inline void clear_has_params();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Prompt > prompt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::gooseai::ConditionerParameters* conditioner_;
    int requested_type_;
    union ParamsUnion {
      constexpr ParamsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gooseai::ImageParameters* image_;
      ::gooseai::ClassifierParameters* classifier_;
      ::gooseai::AssetParameters* asset_;
    } params_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class OnStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.OnStatus) */ {
 public:
  inline OnStatus() : OnStatus(nullptr) {}
  ~OnStatus() override;
  explicit PROTOBUF_CONSTEXPR OnStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnStatus(const OnStatus& from);
  OnStatus(OnStatus&& from) noexcept
    : OnStatus() {
    *this = ::std::move(from);
  }

  inline OnStatus& operator=(const OnStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnStatus& operator=(OnStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnStatus* internal_default_instance() {
    return reinterpret_cast<const OnStatus*>(
               &_OnStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(OnStatus& a, OnStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OnStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnStatus& from) {
    OnStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.OnStatus";
  }
  protected:
  explicit OnStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kActionFieldNumber = 3,
    kTargetFieldNumber = 2,
  };
  // repeated .gooseai.FinishReason reason = 1 [json_name = "reason"];
  int reason_size() const;
  private:
  int _internal_reason_size() const;
  public:
  void clear_reason();
  private:
  ::gooseai::FinishReason _internal_reason(int index) const;
  void _internal_add_reason(::gooseai::FinishReason value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_reason();
  public:
  ::gooseai::FinishReason reason(int index) const;
  void set_reason(int index, ::gooseai::FinishReason value);
  void add_reason(::gooseai::FinishReason value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& reason() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_reason();

  // repeated .gooseai.StageAction action = 3 [json_name = "action"];
  int action_size() const;
  private:
  int _internal_action_size() const;
  public:
  void clear_action();
  private:
  ::gooseai::StageAction _internal_action(int index) const;
  void _internal_add_action(::gooseai::StageAction value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_action();
  public:
  ::gooseai::StageAction action(int index) const;
  void set_action(int index, ::gooseai::StageAction value);
  void add_action(::gooseai::StageAction value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_action();

  // optional string target = 2 [json_name = "target"];
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const std::string& target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.OnStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> reason_;
    mutable std::atomic<int> _reason_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> action_;
    mutable std::atomic<int> _action_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class Stage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.Stage) */ {
 public:
  inline Stage() : Stage(nullptr) {}
  ~Stage() override;
  explicit PROTOBUF_CONSTEXPR Stage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stage(const Stage& from);
  Stage(Stage&& from) noexcept
    : Stage() {
    *this = ::std::move(from);
  }

  inline Stage& operator=(const Stage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stage& operator=(Stage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stage* internal_default_instance() {
    return reinterpret_cast<const Stage*>(
               &_Stage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Stage& a, Stage& b) {
    a.Swap(&b);
  }
  inline void Swap(Stage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stage& from) {
    Stage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.Stage";
  }
  protected:
  explicit Stage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnStatusFieldNumber = 3,
    kIdFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // repeated .gooseai.OnStatus on_status = 3 [json_name = "onStatus"];
  int on_status_size() const;
  private:
  int _internal_on_status_size() const;
  public:
  void clear_on_status();
  ::gooseai::OnStatus* mutable_on_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OnStatus >*
      mutable_on_status();
  private:
  const ::gooseai::OnStatus& _internal_on_status(int index) const;
  ::gooseai::OnStatus* _internal_add_on_status();
  public:
  const ::gooseai::OnStatus& on_status(int index) const;
  ::gooseai::OnStatus* add_on_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OnStatus >&
      on_status() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .gooseai.Request request = 2 [json_name = "request"];
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::gooseai::Request& request() const;
  PROTOBUF_NODISCARD ::gooseai::Request* release_request();
  ::gooseai::Request* mutable_request();
  void set_allocated_request(::gooseai::Request* request);
  private:
  const ::gooseai::Request& _internal_request() const;
  ::gooseai::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::gooseai::Request* request);
  ::gooseai::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:gooseai.Stage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OnStatus > on_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::gooseai::Request* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// -------------------------------------------------------------------

class ChainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gooseai.ChainRequest) */ {
 public:
  inline ChainRequest() : ChainRequest(nullptr) {}
  ~ChainRequest() override;
  explicit PROTOBUF_CONSTEXPR ChainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainRequest(const ChainRequest& from);
  ChainRequest(ChainRequest&& from) noexcept
    : ChainRequest() {
    *this = ::std::move(from);
  }

  inline ChainRequest& operator=(const ChainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainRequest& operator=(ChainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainRequest* internal_default_instance() {
    return reinterpret_cast<const ChainRequest*>(
               &_ChainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ChainRequest& a, ChainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChainRequest& from) {
    ChainRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gooseai.ChainRequest";
  }
  protected:
  explicit ChainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStageFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // repeated .gooseai.Stage stage = 2 [json_name = "stage"];
  int stage_size() const;
  private:
  int _internal_stage_size() const;
  public:
  void clear_stage();
  ::gooseai::Stage* mutable_stage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Stage >*
      mutable_stage();
  private:
  const ::gooseai::Stage& _internal_stage(int index) const;
  ::gooseai::Stage* _internal_add_stage();
  public:
  const ::gooseai::Stage& stage(int index) const;
  ::gooseai::Stage* add_stage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Stage >&
      stage() const;

  // string request_id = 1 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // @@protoc_insertion_point(class_scope:gooseai.ChainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Stage > stage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_generation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Token

// optional string text = 1 [json_name = "text"];
inline bool Token::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Token::has_text() const {
  return _internal_has_text();
}
inline void Token::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Token::text() const {
  // @@protoc_insertion_point(field_get:gooseai.Token.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Token.text)
}
inline std::string* Token::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:gooseai.Token.text)
  return _s;
}
inline const std::string& Token::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Token::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_text() {
  // @@protoc_insertion_point(field_release:gooseai.Token.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Token::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Token.text)
}

// uint32 id = 2 [json_name = "id"];
inline void Token::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Token::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Token::id() const {
  // @@protoc_insertion_point(field_get:gooseai.Token.id)
  return _internal_id();
}
inline void Token::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Token::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gooseai.Token.id)
}

// -------------------------------------------------------------------

// Tokens

// repeated .gooseai.Token tokens = 1 [json_name = "tokens"];
inline int Tokens::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int Tokens::tokens_size() const {
  return _internal_tokens_size();
}
inline void Tokens::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::gooseai::Token* Tokens::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Tokens.tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Token >*
Tokens::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Tokens.tokens)
  return &_impl_.tokens_;
}
inline const ::gooseai::Token& Tokens::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::gooseai::Token& Tokens::tokens(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Tokens.tokens)
  return _internal_tokens(index);
}
inline ::gooseai::Token* Tokens::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::gooseai::Token* Tokens::add_tokens() {
  ::gooseai::Token* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:gooseai.Tokens.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Token >&
Tokens::tokens() const {
  // @@protoc_insertion_point(field_list:gooseai.Tokens.tokens)
  return _impl_.tokens_;
}

// optional string tokenizer_id = 2 [json_name = "tokenizerId"];
inline bool Tokens::_internal_has_tokenizer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Tokens::has_tokenizer_id() const {
  return _internal_has_tokenizer_id();
}
inline void Tokens::clear_tokenizer_id() {
  _impl_.tokenizer_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Tokens::tokenizer_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Tokens.tokenizer_id)
  return _internal_tokenizer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tokens::set_tokenizer_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tokenizer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Tokens.tokenizer_id)
}
inline std::string* Tokens::mutable_tokenizer_id() {
  std::string* _s = _internal_mutable_tokenizer_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Tokens.tokenizer_id)
  return _s;
}
inline const std::string& Tokens::_internal_tokenizer_id() const {
  return _impl_.tokenizer_id_.Get();
}
inline void Tokens::_internal_set_tokenizer_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tokenizer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Tokens::_internal_mutable_tokenizer_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tokenizer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Tokens::release_tokenizer_id() {
  // @@protoc_insertion_point(field_release:gooseai.Tokens.tokenizer_id)
  if (!_internal_has_tokenizer_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tokenizer_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tokenizer_id_.IsDefault()) {
    _impl_.tokenizer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Tokens::set_allocated_tokenizer_id(std::string* tokenizer_id) {
  if (tokenizer_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tokenizer_id_.SetAllocated(tokenizer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tokenizer_id_.IsDefault()) {
    _impl_.tokenizer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Tokens.tokenizer_id)
}

// -------------------------------------------------------------------

// Artifact

// uint64 id = 1 [json_name = "id"];
inline void Artifact::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Artifact::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Artifact::id() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.id)
  return _internal_id();
}
inline void Artifact::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Artifact::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.id)
}

// .gooseai.ArtifactType type = 2 [json_name = "type"];
inline void Artifact::clear_type() {
  _impl_.type_ = 0;
}
inline ::gooseai::ArtifactType Artifact::_internal_type() const {
  return static_cast< ::gooseai::ArtifactType >(_impl_.type_);
}
inline ::gooseai::ArtifactType Artifact::type() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.type)
  return _internal_type();
}
inline void Artifact::_internal_set_type(::gooseai::ArtifactType value) {
  
  _impl_.type_ = value;
}
inline void Artifact::set_type(::gooseai::ArtifactType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.type)
}

// string mime = 3 [json_name = "mime"];
inline void Artifact::clear_mime() {
  _impl_.mime_.ClearToEmpty();
}
inline const std::string& Artifact::mime() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.mime)
  return _internal_mime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_mime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Artifact.mime)
}
inline std::string* Artifact::mutable_mime() {
  std::string* _s = _internal_mutable_mime();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.mime)
  return _s;
}
inline const std::string& Artifact::_internal_mime() const {
  return _impl_.mime_.Get();
}
inline void Artifact::_internal_set_mime(const std::string& value) {
  
  _impl_.mime_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_mime() {
  
  return _impl_.mime_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_mime() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.mime)
  return _impl_.mime_.Release();
}
inline void Artifact::set_allocated_mime(std::string* mime) {
  if (mime != nullptr) {
    
  } else {
    
  }
  _impl_.mime_.SetAllocated(mime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_.IsDefault()) {
    _impl_.mime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.mime)
}

// optional string magic = 4 [json_name = "magic"];
inline bool Artifact::_internal_has_magic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Artifact::has_magic() const {
  return _internal_has_magic();
}
inline void Artifact::clear_magic() {
  _impl_.magic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Artifact::magic() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.magic)
  return _internal_magic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_magic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.magic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Artifact.magic)
}
inline std::string* Artifact::mutable_magic() {
  std::string* _s = _internal_mutable_magic();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.magic)
  return _s;
}
inline const std::string& Artifact::_internal_magic() const {
  return _impl_.magic_.Get();
}
inline void Artifact::_internal_set_magic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.magic_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_magic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.magic_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_magic() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.magic)
  if (!_internal_has_magic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.magic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.magic_.IsDefault()) {
    _impl_.magic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Artifact::set_allocated_magic(std::string* magic) {
  if (magic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.magic_.SetAllocated(magic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.magic_.IsDefault()) {
    _impl_.magic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.magic)
}

// bytes binary = 5 [json_name = "binary"];
inline bool Artifact::_internal_has_binary() const {
  return data_case() == kBinary;
}
inline bool Artifact::has_binary() const {
  return _internal_has_binary();
}
inline void Artifact::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void Artifact::clear_binary() {
  if (_internal_has_binary()) {
    _impl_.data_.binary_.Destroy();
    clear_has_data();
  }
}
inline const std::string& Artifact::binary() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline void Artifact::set_binary(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  _impl_.data_.binary_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Artifact.binary)
}
inline std::string* Artifact::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.binary)
  return _s;
}
inline const std::string& Artifact::_internal_binary() const {
  if (_internal_has_binary()) {
    return _impl_.data_.binary_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Artifact::_internal_set_binary(const std::string& value) {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  _impl_.data_.binary_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_binary() {
  if (!_internal_has_binary()) {
    clear_data();
    set_has_binary();
    _impl_.data_.binary_.InitDefault();
  }
  return _impl_.data_.binary_.Mutable(      GetArenaForAllocation());
}
inline std::string* Artifact::release_binary() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.binary)
  if (_internal_has_binary()) {
    clear_has_data();
    return _impl_.data_.binary_.Release();
  } else {
    return nullptr;
  }
}
inline void Artifact::set_allocated_binary(std::string* binary) {
  if (has_data()) {
    clear_data();
  }
  if (binary != nullptr) {
    set_has_binary();
    _impl_.data_.binary_.InitAllocated(binary, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.binary)
}

// string text = 6 [json_name = "text"];
inline bool Artifact::_internal_has_text() const {
  return data_case() == kText;
}
inline bool Artifact::has_text() const {
  return _internal_has_text();
}
inline void Artifact::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Artifact::clear_text() {
  if (_internal_has_text()) {
    _impl_.data_.text_.Destroy();
    clear_has_data();
  }
}
inline const std::string& Artifact::text() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void Artifact::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  _impl_.data_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Artifact.text)
}
inline std::string* Artifact::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.text)
  return _s;
}
inline const std::string& Artifact::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.data_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Artifact::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  _impl_.data_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  return _impl_.data_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* Artifact::release_text() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.text)
  if (_internal_has_text()) {
    clear_has_data();
    return _impl_.data_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void Artifact::set_allocated_text(std::string* text) {
  if (has_data()) {
    clear_data();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.data_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.text)
}

// .gooseai.Tokens tokens = 7 [json_name = "tokens"];
inline bool Artifact::_internal_has_tokens() const {
  return data_case() == kTokens;
}
inline bool Artifact::has_tokens() const {
  return _internal_has_tokens();
}
inline void Artifact::set_has_tokens() {
  _impl_._oneof_case_[0] = kTokens;
}
inline void Artifact::clear_tokens() {
  if (_internal_has_tokens()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.tokens_;
    }
    clear_has_data();
  }
}
inline ::gooseai::Tokens* Artifact::release_tokens() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.tokens)
  if (_internal_has_tokens()) {
    clear_has_data();
    ::gooseai::Tokens* temp = _impl_.data_.tokens_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::Tokens& Artifact::_internal_tokens() const {
  return _internal_has_tokens()
      ? *_impl_.data_.tokens_
      : reinterpret_cast< ::gooseai::Tokens&>(::gooseai::_Tokens_default_instance_);
}
inline const ::gooseai::Tokens& Artifact::tokens() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.tokens)
  return _internal_tokens();
}
inline ::gooseai::Tokens* Artifact::unsafe_arena_release_tokens() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Artifact.tokens)
  if (_internal_has_tokens()) {
    clear_has_data();
    ::gooseai::Tokens* temp = _impl_.data_.tokens_;
    _impl_.data_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Artifact::unsafe_arena_set_allocated_tokens(::gooseai::Tokens* tokens) {
  clear_data();
  if (tokens) {
    set_has_tokens();
    _impl_.data_.tokens_ = tokens;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Artifact.tokens)
}
inline ::gooseai::Tokens* Artifact::_internal_mutable_tokens() {
  if (!_internal_has_tokens()) {
    clear_data();
    set_has_tokens();
    _impl_.data_.tokens_ = CreateMaybeMessage< ::gooseai::Tokens >(GetArenaForAllocation());
  }
  return _impl_.data_.tokens_;
}
inline ::gooseai::Tokens* Artifact::mutable_tokens() {
  ::gooseai::Tokens* _msg = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.tokens)
  return _msg;
}

// .gooseai.ClassifierParameters classifier = 11 [json_name = "classifier"];
inline bool Artifact::_internal_has_classifier() const {
  return data_case() == kClassifier;
}
inline bool Artifact::has_classifier() const {
  return _internal_has_classifier();
}
inline void Artifact::set_has_classifier() {
  _impl_._oneof_case_[0] = kClassifier;
}
inline void Artifact::clear_classifier() {
  if (_internal_has_classifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.classifier_;
    }
    clear_has_data();
  }
}
inline ::gooseai::ClassifierParameters* Artifact::release_classifier() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.classifier)
  if (_internal_has_classifier()) {
    clear_has_data();
    ::gooseai::ClassifierParameters* temp = _impl_.data_.classifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.classifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::ClassifierParameters& Artifact::_internal_classifier() const {
  return _internal_has_classifier()
      ? *_impl_.data_.classifier_
      : reinterpret_cast< ::gooseai::ClassifierParameters&>(::gooseai::_ClassifierParameters_default_instance_);
}
inline const ::gooseai::ClassifierParameters& Artifact::classifier() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.classifier)
  return _internal_classifier();
}
inline ::gooseai::ClassifierParameters* Artifact::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Artifact.classifier)
  if (_internal_has_classifier()) {
    clear_has_data();
    ::gooseai::ClassifierParameters* temp = _impl_.data_.classifier_;
    _impl_.data_.classifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Artifact::unsafe_arena_set_allocated_classifier(::gooseai::ClassifierParameters* classifier) {
  clear_data();
  if (classifier) {
    set_has_classifier();
    _impl_.data_.classifier_ = classifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Artifact.classifier)
}
inline ::gooseai::ClassifierParameters* Artifact::_internal_mutable_classifier() {
  if (!_internal_has_classifier()) {
    clear_data();
    set_has_classifier();
    _impl_.data_.classifier_ = CreateMaybeMessage< ::gooseai::ClassifierParameters >(GetArenaForAllocation());
  }
  return _impl_.data_.classifier_;
}
inline ::gooseai::ClassifierParameters* Artifact::mutable_classifier() {
  ::gooseai::ClassifierParameters* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.classifier)
  return _msg;
}

// .tensors.Tensor tensor = 14 [json_name = "tensor"];
inline bool Artifact::_internal_has_tensor() const {
  return data_case() == kTensor;
}
inline bool Artifact::has_tensor() const {
  return _internal_has_tensor();
}
inline void Artifact::set_has_tensor() {
  _impl_._oneof_case_[0] = kTensor;
}
inline ::tensors::Tensor* Artifact::release_tensor() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.tensor)
  if (_internal_has_tensor()) {
    clear_has_data();
    ::tensors::Tensor* temp = _impl_.data_.tensor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensors::Tensor& Artifact::_internal_tensor() const {
  return _internal_has_tensor()
      ? *_impl_.data_.tensor_
      : reinterpret_cast< ::tensors::Tensor&>(::tensors::_Tensor_default_instance_);
}
inline const ::tensors::Tensor& Artifact::tensor() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.tensor)
  return _internal_tensor();
}
inline ::tensors::Tensor* Artifact::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Artifact.tensor)
  if (_internal_has_tensor()) {
    clear_has_data();
    ::tensors::Tensor* temp = _impl_.data_.tensor_;
    _impl_.data_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Artifact::unsafe_arena_set_allocated_tensor(::tensors::Tensor* tensor) {
  clear_data();
  if (tensor) {
    set_has_tensor();
    _impl_.data_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Artifact.tensor)
}
inline ::tensors::Tensor* Artifact::_internal_mutable_tensor() {
  if (!_internal_has_tensor()) {
    clear_data();
    set_has_tensor();
    _impl_.data_.tensor_ = CreateMaybeMessage< ::tensors::Tensor >(GetArenaForAllocation());
  }
  return _impl_.data_.tensor_;
}
inline ::tensors::Tensor* Artifact::mutable_tensor() {
  ::tensors::Tensor* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.tensor)
  return _msg;
}

// uint32 index = 8 [json_name = "index"];
inline void Artifact::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t Artifact::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t Artifact::index() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.index)
  return _internal_index();
}
inline void Artifact::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void Artifact::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.index)
}

// .gooseai.FinishReason finish_reason = 9 [json_name = "finishReason"];
inline void Artifact::clear_finish_reason() {
  _impl_.finish_reason_ = 0;
}
inline ::gooseai::FinishReason Artifact::_internal_finish_reason() const {
  return static_cast< ::gooseai::FinishReason >(_impl_.finish_reason_);
}
inline ::gooseai::FinishReason Artifact::finish_reason() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.finish_reason)
  return _internal_finish_reason();
}
inline void Artifact::_internal_set_finish_reason(::gooseai::FinishReason value) {
  
  _impl_.finish_reason_ = value;
}
inline void Artifact::set_finish_reason(::gooseai::FinishReason value) {
  _internal_set_finish_reason(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.finish_reason)
}

// uint32 seed = 10 [json_name = "seed"];
inline void Artifact::clear_seed() {
  _impl_.seed_ = 0u;
}
inline uint32_t Artifact::_internal_seed() const {
  return _impl_.seed_;
}
inline uint32_t Artifact::seed() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.seed)
  return _internal_seed();
}
inline void Artifact::_internal_set_seed(uint32_t value) {
  
  _impl_.seed_ = value;
}
inline void Artifact::set_seed(uint32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.seed)
}

// string uuid = 12 [json_name = "uuid"];
inline void Artifact::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& Artifact::uuid() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Artifact.uuid)
}
inline std::string* Artifact::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:gooseai.Artifact.uuid)
  return _s;
}
inline const std::string& Artifact::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void Artifact::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_uuid() {
  // @@protoc_insertion_point(field_release:gooseai.Artifact.uuid)
  return _impl_.uuid_.Release();
}
inline void Artifact::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.uuid)
}

// uint64 size = 13 [json_name = "size"];
inline void Artifact::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t Artifact::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t Artifact::size() const {
  // @@protoc_insertion_point(field_get:gooseai.Artifact.size)
  return _internal_size();
}
inline void Artifact::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void Artifact::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:gooseai.Artifact.size)
}

inline bool Artifact::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Artifact::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Artifact::DataCase Artifact::data_case() const {
  return Artifact::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PromptParameters

// optional bool init = 1 [json_name = "init"];
inline bool PromptParameters::_internal_has_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptParameters::has_init() const {
  return _internal_has_init();
}
inline void PromptParameters::clear_init() {
  _impl_.init_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PromptParameters::_internal_init() const {
  return _impl_.init_;
}
inline bool PromptParameters::init() const {
  // @@protoc_insertion_point(field_get:gooseai.PromptParameters.init)
  return _internal_init();
}
inline void PromptParameters::_internal_set_init(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.init_ = value;
}
inline void PromptParameters::set_init(bool value) {
  _internal_set_init(value);
  // @@protoc_insertion_point(field_set:gooseai.PromptParameters.init)
}

// optional float weight = 2 [json_name = "weight"];
inline bool PromptParameters::_internal_has_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptParameters::has_weight() const {
  return _internal_has_weight();
}
inline void PromptParameters::clear_weight() {
  _impl_.weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float PromptParameters::_internal_weight() const {
  return _impl_.weight_;
}
inline float PromptParameters::weight() const {
  // @@protoc_insertion_point(field_get:gooseai.PromptParameters.weight)
  return _internal_weight();
}
inline void PromptParameters::_internal_set_weight(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.weight_ = value;
}
inline void PromptParameters::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:gooseai.PromptParameters.weight)
}

// -------------------------------------------------------------------

// Prompt

// optional .gooseai.PromptParameters parameters = 1 [json_name = "parameters"];
inline bool Prompt::_internal_has_parameters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parameters_ != nullptr);
  return value;
}
inline bool Prompt::has_parameters() const {
  return _internal_has_parameters();
}
inline void Prompt::clear_parameters() {
  if (_impl_.parameters_ != nullptr) _impl_.parameters_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::PromptParameters& Prompt::_internal_parameters() const {
  const ::gooseai::PromptParameters* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::PromptParameters&>(
      ::gooseai::_PromptParameters_default_instance_);
}
inline const ::gooseai::PromptParameters& Prompt::parameters() const {
  // @@protoc_insertion_point(field_get:gooseai.Prompt.parameters)
  return _internal_parameters();
}
inline void Prompt::unsafe_arena_set_allocated_parameters(
    ::gooseai::PromptParameters* parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = parameters;
  if (parameters) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Prompt.parameters)
}
inline ::gooseai::PromptParameters* Prompt::release_parameters() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::PromptParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::PromptParameters* Prompt::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:gooseai.Prompt.parameters)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::PromptParameters* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::gooseai::PromptParameters* Prompt::_internal_mutable_parameters() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::PromptParameters>(GetArenaForAllocation());
    _impl_.parameters_ = p;
  }
  return _impl_.parameters_;
}
inline ::gooseai::PromptParameters* Prompt::mutable_parameters() {
  ::gooseai::PromptParameters* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:gooseai.Prompt.parameters)
  return _msg;
}
inline void Prompt::set_allocated_parameters(::gooseai::PromptParameters* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Prompt.parameters)
}

// string text = 2 [json_name = "text"];
inline bool Prompt::_internal_has_text() const {
  return prompt_case() == kText;
}
inline bool Prompt::has_text() const {
  return _internal_has_text();
}
inline void Prompt::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Prompt::clear_text() {
  if (_internal_has_text()) {
    _impl_.prompt_.text_.Destroy();
    clear_has_prompt();
  }
}
inline const std::string& Prompt::text() const {
  // @@protoc_insertion_point(field_get:gooseai.Prompt.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void Prompt::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_prompt();
    set_has_text();
    _impl_.prompt_.text_.InitDefault();
  }
  _impl_.prompt_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Prompt.text)
}
inline std::string* Prompt::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:gooseai.Prompt.text)
  return _s;
}
inline const std::string& Prompt::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.prompt_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Prompt::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_prompt();
    set_has_text();
    _impl_.prompt_.text_.InitDefault();
  }
  _impl_.prompt_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Prompt::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_prompt();
    set_has_text();
    _impl_.prompt_.text_.InitDefault();
  }
  return _impl_.prompt_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* Prompt::release_text() {
  // @@protoc_insertion_point(field_release:gooseai.Prompt.text)
  if (_internal_has_text()) {
    clear_has_prompt();
    return _impl_.prompt_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void Prompt::set_allocated_text(std::string* text) {
  if (has_prompt()) {
    clear_prompt();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.prompt_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Prompt.text)
}

// .gooseai.Tokens tokens = 3 [json_name = "tokens"];
inline bool Prompt::_internal_has_tokens() const {
  return prompt_case() == kTokens;
}
inline bool Prompt::has_tokens() const {
  return _internal_has_tokens();
}
inline void Prompt::set_has_tokens() {
  _impl_._oneof_case_[0] = kTokens;
}
inline void Prompt::clear_tokens() {
  if (_internal_has_tokens()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.prompt_.tokens_;
    }
    clear_has_prompt();
  }
}
inline ::gooseai::Tokens* Prompt::release_tokens() {
  // @@protoc_insertion_point(field_release:gooseai.Prompt.tokens)
  if (_internal_has_tokens()) {
    clear_has_prompt();
    ::gooseai::Tokens* temp = _impl_.prompt_.tokens_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.prompt_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::Tokens& Prompt::_internal_tokens() const {
  return _internal_has_tokens()
      ? *_impl_.prompt_.tokens_
      : reinterpret_cast< ::gooseai::Tokens&>(::gooseai::_Tokens_default_instance_);
}
inline const ::gooseai::Tokens& Prompt::tokens() const {
  // @@protoc_insertion_point(field_get:gooseai.Prompt.tokens)
  return _internal_tokens();
}
inline ::gooseai::Tokens* Prompt::unsafe_arena_release_tokens() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Prompt.tokens)
  if (_internal_has_tokens()) {
    clear_has_prompt();
    ::gooseai::Tokens* temp = _impl_.prompt_.tokens_;
    _impl_.prompt_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Prompt::unsafe_arena_set_allocated_tokens(::gooseai::Tokens* tokens) {
  clear_prompt();
  if (tokens) {
    set_has_tokens();
    _impl_.prompt_.tokens_ = tokens;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Prompt.tokens)
}
inline ::gooseai::Tokens* Prompt::_internal_mutable_tokens() {
  if (!_internal_has_tokens()) {
    clear_prompt();
    set_has_tokens();
    _impl_.prompt_.tokens_ = CreateMaybeMessage< ::gooseai::Tokens >(GetArenaForAllocation());
  }
  return _impl_.prompt_.tokens_;
}
inline ::gooseai::Tokens* Prompt::mutable_tokens() {
  ::gooseai::Tokens* _msg = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:gooseai.Prompt.tokens)
  return _msg;
}

// .gooseai.Artifact artifact = 4 [json_name = "artifact"];
inline bool Prompt::_internal_has_artifact() const {
  return prompt_case() == kArtifact;
}
inline bool Prompt::has_artifact() const {
  return _internal_has_artifact();
}
inline void Prompt::set_has_artifact() {
  _impl_._oneof_case_[0] = kArtifact;
}
inline void Prompt::clear_artifact() {
  if (_internal_has_artifact()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.prompt_.artifact_;
    }
    clear_has_prompt();
  }
}
inline ::gooseai::Artifact* Prompt::release_artifact() {
  // @@protoc_insertion_point(field_release:gooseai.Prompt.artifact)
  if (_internal_has_artifact()) {
    clear_has_prompt();
    ::gooseai::Artifact* temp = _impl_.prompt_.artifact_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.prompt_.artifact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::Artifact& Prompt::_internal_artifact() const {
  return _internal_has_artifact()
      ? *_impl_.prompt_.artifact_
      : reinterpret_cast< ::gooseai::Artifact&>(::gooseai::_Artifact_default_instance_);
}
inline const ::gooseai::Artifact& Prompt::artifact() const {
  // @@protoc_insertion_point(field_get:gooseai.Prompt.artifact)
  return _internal_artifact();
}
inline ::gooseai::Artifact* Prompt::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Prompt.artifact)
  if (_internal_has_artifact()) {
    clear_has_prompt();
    ::gooseai::Artifact* temp = _impl_.prompt_.artifact_;
    _impl_.prompt_.artifact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Prompt::unsafe_arena_set_allocated_artifact(::gooseai::Artifact* artifact) {
  clear_prompt();
  if (artifact) {
    set_has_artifact();
    _impl_.prompt_.artifact_ = artifact;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Prompt.artifact)
}
inline ::gooseai::Artifact* Prompt::_internal_mutable_artifact() {
  if (!_internal_has_artifact()) {
    clear_prompt();
    set_has_artifact();
    _impl_.prompt_.artifact_ = CreateMaybeMessage< ::gooseai::Artifact >(GetArenaForAllocation());
  }
  return _impl_.prompt_.artifact_;
}
inline ::gooseai::Artifact* Prompt::mutable_artifact() {
  ::gooseai::Artifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:gooseai.Prompt.artifact)
  return _msg;
}

inline bool Prompt::has_prompt() const {
  return prompt_case() != PROMPT_NOT_SET;
}
inline void Prompt::clear_has_prompt() {
  _impl_._oneof_case_[0] = PROMPT_NOT_SET;
}
inline Prompt::PromptCase Prompt::prompt_case() const {
  return Prompt::PromptCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SamplerParameters

// optional float eta = 1 [json_name = "eta"];
inline bool SamplerParameters::_internal_has_eta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SamplerParameters::has_eta() const {
  return _internal_has_eta();
}
inline void SamplerParameters::clear_eta() {
  _impl_.eta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SamplerParameters::_internal_eta() const {
  return _impl_.eta_;
}
inline float SamplerParameters::eta() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.eta)
  return _internal_eta();
}
inline void SamplerParameters::_internal_set_eta(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.eta_ = value;
}
inline void SamplerParameters::set_eta(float value) {
  _internal_set_eta(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.eta)
}

// optional uint64 sampling_steps = 2 [json_name = "samplingSteps"];
inline bool SamplerParameters::_internal_has_sampling_steps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SamplerParameters::has_sampling_steps() const {
  return _internal_has_sampling_steps();
}
inline void SamplerParameters::clear_sampling_steps() {
  _impl_.sampling_steps_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SamplerParameters::_internal_sampling_steps() const {
  return _impl_.sampling_steps_;
}
inline uint64_t SamplerParameters::sampling_steps() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.sampling_steps)
  return _internal_sampling_steps();
}
inline void SamplerParameters::_internal_set_sampling_steps(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sampling_steps_ = value;
}
inline void SamplerParameters::set_sampling_steps(uint64_t value) {
  _internal_set_sampling_steps(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.sampling_steps)
}

// optional uint64 latent_channels = 3 [json_name = "latentChannels"];
inline bool SamplerParameters::_internal_has_latent_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SamplerParameters::has_latent_channels() const {
  return _internal_has_latent_channels();
}
inline void SamplerParameters::clear_latent_channels() {
  _impl_.latent_channels_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SamplerParameters::_internal_latent_channels() const {
  return _impl_.latent_channels_;
}
inline uint64_t SamplerParameters::latent_channels() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.latent_channels)
  return _internal_latent_channels();
}
inline void SamplerParameters::_internal_set_latent_channels(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latent_channels_ = value;
}
inline void SamplerParameters::set_latent_channels(uint64_t value) {
  _internal_set_latent_channels(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.latent_channels)
}

// optional uint64 downsampling_factor = 4 [json_name = "downsamplingFactor"];
inline bool SamplerParameters::_internal_has_downsampling_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SamplerParameters::has_downsampling_factor() const {
  return _internal_has_downsampling_factor();
}
inline void SamplerParameters::clear_downsampling_factor() {
  _impl_.downsampling_factor_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t SamplerParameters::_internal_downsampling_factor() const {
  return _impl_.downsampling_factor_;
}
inline uint64_t SamplerParameters::downsampling_factor() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.downsampling_factor)
  return _internal_downsampling_factor();
}
inline void SamplerParameters::_internal_set_downsampling_factor(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.downsampling_factor_ = value;
}
inline void SamplerParameters::set_downsampling_factor(uint64_t value) {
  _internal_set_downsampling_factor(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.downsampling_factor)
}

// optional float cfg_scale = 5 [json_name = "cfgScale"];
inline bool SamplerParameters::_internal_has_cfg_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SamplerParameters::has_cfg_scale() const {
  return _internal_has_cfg_scale();
}
inline void SamplerParameters::clear_cfg_scale() {
  _impl_.cfg_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SamplerParameters::_internal_cfg_scale() const {
  return _impl_.cfg_scale_;
}
inline float SamplerParameters::cfg_scale() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.cfg_scale)
  return _internal_cfg_scale();
}
inline void SamplerParameters::_internal_set_cfg_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cfg_scale_ = value;
}
inline void SamplerParameters::set_cfg_scale(float value) {
  _internal_set_cfg_scale(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.cfg_scale)
}

// optional float init_noise_scale = 6 [json_name = "initNoiseScale"];
inline bool SamplerParameters::_internal_has_init_noise_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SamplerParameters::has_init_noise_scale() const {
  return _internal_has_init_noise_scale();
}
inline void SamplerParameters::clear_init_noise_scale() {
  _impl_.init_noise_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float SamplerParameters::_internal_init_noise_scale() const {
  return _impl_.init_noise_scale_;
}
inline float SamplerParameters::init_noise_scale() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.init_noise_scale)
  return _internal_init_noise_scale();
}
inline void SamplerParameters::_internal_set_init_noise_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.init_noise_scale_ = value;
}
inline void SamplerParameters::set_init_noise_scale(float value) {
  _internal_set_init_noise_scale(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.init_noise_scale)
}

// optional float step_noise_scale = 7 [json_name = "stepNoiseScale"];
inline bool SamplerParameters::_internal_has_step_noise_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SamplerParameters::has_step_noise_scale() const {
  return _internal_has_step_noise_scale();
}
inline void SamplerParameters::clear_step_noise_scale() {
  _impl_.step_noise_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float SamplerParameters::_internal_step_noise_scale() const {
  return _impl_.step_noise_scale_;
}
inline float SamplerParameters::step_noise_scale() const {
  // @@protoc_insertion_point(field_get:gooseai.SamplerParameters.step_noise_scale)
  return _internal_step_noise_scale();
}
inline void SamplerParameters::_internal_set_step_noise_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.step_noise_scale_ = value;
}
inline void SamplerParameters::set_step_noise_scale(float value) {
  _internal_set_step_noise_scale(value);
  // @@protoc_insertion_point(field_set:gooseai.SamplerParameters.step_noise_scale)
}

// -------------------------------------------------------------------

// ConditionerParameters

// optional string vector_adjust_prior = 1 [json_name = "vectorAdjustPrior"];
inline bool ConditionerParameters::_internal_has_vector_adjust_prior() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConditionerParameters::has_vector_adjust_prior() const {
  return _internal_has_vector_adjust_prior();
}
inline void ConditionerParameters::clear_vector_adjust_prior() {
  _impl_.vector_adjust_prior_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConditionerParameters::vector_adjust_prior() const {
  // @@protoc_insertion_point(field_get:gooseai.ConditionerParameters.vector_adjust_prior)
  return _internal_vector_adjust_prior();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConditionerParameters::set_vector_adjust_prior(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vector_adjust_prior_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.ConditionerParameters.vector_adjust_prior)
}
inline std::string* ConditionerParameters::mutable_vector_adjust_prior() {
  std::string* _s = _internal_mutable_vector_adjust_prior();
  // @@protoc_insertion_point(field_mutable:gooseai.ConditionerParameters.vector_adjust_prior)
  return _s;
}
inline const std::string& ConditionerParameters::_internal_vector_adjust_prior() const {
  return _impl_.vector_adjust_prior_.Get();
}
inline void ConditionerParameters::_internal_set_vector_adjust_prior(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vector_adjust_prior_.Set(value, GetArenaForAllocation());
}
inline std::string* ConditionerParameters::_internal_mutable_vector_adjust_prior() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vector_adjust_prior_.Mutable(GetArenaForAllocation());
}
inline std::string* ConditionerParameters::release_vector_adjust_prior() {
  // @@protoc_insertion_point(field_release:gooseai.ConditionerParameters.vector_adjust_prior)
  if (!_internal_has_vector_adjust_prior()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vector_adjust_prior_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vector_adjust_prior_.IsDefault()) {
    _impl_.vector_adjust_prior_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConditionerParameters::set_allocated_vector_adjust_prior(std::string* vector_adjust_prior) {
  if (vector_adjust_prior != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vector_adjust_prior_.SetAllocated(vector_adjust_prior, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vector_adjust_prior_.IsDefault()) {
    _impl_.vector_adjust_prior_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.ConditionerParameters.vector_adjust_prior)
}

// optional .gooseai.Model conditioner = 2 [json_name = "conditioner"];
inline bool ConditionerParameters::_internal_has_conditioner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conditioner_ != nullptr);
  return value;
}
inline bool ConditionerParameters::has_conditioner() const {
  return _internal_has_conditioner();
}
inline void ConditionerParameters::clear_conditioner() {
  if (_impl_.conditioner_ != nullptr) _impl_.conditioner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gooseai::Model& ConditionerParameters::_internal_conditioner() const {
  const ::gooseai::Model* p = _impl_.conditioner_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::Model&>(
      ::gooseai::_Model_default_instance_);
}
inline const ::gooseai::Model& ConditionerParameters::conditioner() const {
  // @@protoc_insertion_point(field_get:gooseai.ConditionerParameters.conditioner)
  return _internal_conditioner();
}
inline void ConditionerParameters::unsafe_arena_set_allocated_conditioner(
    ::gooseai::Model* conditioner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditioner_);
  }
  _impl_.conditioner_ = conditioner;
  if (conditioner) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.ConditionerParameters.conditioner)
}
inline ::gooseai::Model* ConditionerParameters::release_conditioner() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::Model* temp = _impl_.conditioner_;
  _impl_.conditioner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::Model* ConditionerParameters::unsafe_arena_release_conditioner() {
  // @@protoc_insertion_point(field_release:gooseai.ConditionerParameters.conditioner)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::Model* temp = _impl_.conditioner_;
  _impl_.conditioner_ = nullptr;
  return temp;
}
inline ::gooseai::Model* ConditionerParameters::_internal_mutable_conditioner() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.conditioner_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::Model>(GetArenaForAllocation());
    _impl_.conditioner_ = p;
  }
  return _impl_.conditioner_;
}
inline ::gooseai::Model* ConditionerParameters::mutable_conditioner() {
  ::gooseai::Model* _msg = _internal_mutable_conditioner();
  // @@protoc_insertion_point(field_mutable:gooseai.ConditionerParameters.conditioner)
  return _msg;
}
inline void ConditionerParameters::set_allocated_conditioner(::gooseai::Model* conditioner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conditioner_;
  }
  if (conditioner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditioner);
    if (message_arena != submessage_arena) {
      conditioner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditioner, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.conditioner_ = conditioner;
  // @@protoc_insertion_point(field_set_allocated:gooseai.ConditionerParameters.conditioner)
}

// -------------------------------------------------------------------

// ScheduleParameters

// optional float start = 1 [json_name = "start"];
inline bool ScheduleParameters::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScheduleParameters::has_start() const {
  return _internal_has_start();
}
inline void ScheduleParameters::clear_start() {
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ScheduleParameters::_internal_start() const {
  return _impl_.start_;
}
inline float ScheduleParameters::start() const {
  // @@protoc_insertion_point(field_get:gooseai.ScheduleParameters.start)
  return _internal_start();
}
inline void ScheduleParameters::_internal_set_start(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}
inline void ScheduleParameters::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:gooseai.ScheduleParameters.start)
}

// optional float end = 2 [json_name = "end"];
inline bool ScheduleParameters::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScheduleParameters::has_end() const {
  return _internal_has_end();
}
inline void ScheduleParameters::clear_end() {
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ScheduleParameters::_internal_end() const {
  return _impl_.end_;
}
inline float ScheduleParameters::end() const {
  // @@protoc_insertion_point(field_get:gooseai.ScheduleParameters.end)
  return _internal_end();
}
inline void ScheduleParameters::_internal_set_end(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}
inline void ScheduleParameters::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:gooseai.ScheduleParameters.end)
}

// optional float value = 3 [json_name = "value"];
inline bool ScheduleParameters::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScheduleParameters::has_value() const {
  return _internal_has_value();
}
inline void ScheduleParameters::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ScheduleParameters::_internal_value() const {
  return _impl_.value_;
}
inline float ScheduleParameters::value() const {
  // @@protoc_insertion_point(field_get:gooseai.ScheduleParameters.value)
  return _internal_value();
}
inline void ScheduleParameters::_internal_set_value(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_ = value;
}
inline void ScheduleParameters::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:gooseai.ScheduleParameters.value)
}

// -------------------------------------------------------------------

// StepParameter

// float scaled_step = 1 [json_name = "scaledStep"];
inline void StepParameter::clear_scaled_step() {
  _impl_.scaled_step_ = 0;
}
inline float StepParameter::_internal_scaled_step() const {
  return _impl_.scaled_step_;
}
inline float StepParameter::scaled_step() const {
  // @@protoc_insertion_point(field_get:gooseai.StepParameter.scaled_step)
  return _internal_scaled_step();
}
inline void StepParameter::_internal_set_scaled_step(float value) {
  
  _impl_.scaled_step_ = value;
}
inline void StepParameter::set_scaled_step(float value) {
  _internal_set_scaled_step(value);
  // @@protoc_insertion_point(field_set:gooseai.StepParameter.scaled_step)
}

// optional .gooseai.SamplerParameters sampler = 2 [json_name = "sampler"];
inline bool StepParameter::_internal_has_sampler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sampler_ != nullptr);
  return value;
}
inline bool StepParameter::has_sampler() const {
  return _internal_has_sampler();
}
inline void StepParameter::clear_sampler() {
  if (_impl_.sampler_ != nullptr) _impl_.sampler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::SamplerParameters& StepParameter::_internal_sampler() const {
  const ::gooseai::SamplerParameters* p = _impl_.sampler_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::SamplerParameters&>(
      ::gooseai::_SamplerParameters_default_instance_);
}
inline const ::gooseai::SamplerParameters& StepParameter::sampler() const {
  // @@protoc_insertion_point(field_get:gooseai.StepParameter.sampler)
  return _internal_sampler();
}
inline void StepParameter::unsafe_arena_set_allocated_sampler(
    ::gooseai::SamplerParameters* sampler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sampler_);
  }
  _impl_.sampler_ = sampler;
  if (sampler) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.StepParameter.sampler)
}
inline ::gooseai::SamplerParameters* StepParameter::release_sampler() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::SamplerParameters* temp = _impl_.sampler_;
  _impl_.sampler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::SamplerParameters* StepParameter::unsafe_arena_release_sampler() {
  // @@protoc_insertion_point(field_release:gooseai.StepParameter.sampler)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::SamplerParameters* temp = _impl_.sampler_;
  _impl_.sampler_ = nullptr;
  return temp;
}
inline ::gooseai::SamplerParameters* StepParameter::_internal_mutable_sampler() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sampler_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::SamplerParameters>(GetArenaForAllocation());
    _impl_.sampler_ = p;
  }
  return _impl_.sampler_;
}
inline ::gooseai::SamplerParameters* StepParameter::mutable_sampler() {
  ::gooseai::SamplerParameters* _msg = _internal_mutable_sampler();
  // @@protoc_insertion_point(field_mutable:gooseai.StepParameter.sampler)
  return _msg;
}
inline void StepParameter::set_allocated_sampler(::gooseai::SamplerParameters* sampler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sampler_;
  }
  if (sampler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sampler);
    if (message_arena != submessage_arena) {
      sampler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sampler, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sampler_ = sampler;
  // @@protoc_insertion_point(field_set_allocated:gooseai.StepParameter.sampler)
}

// optional .gooseai.ScheduleParameters schedule = 3 [json_name = "schedule"];
inline bool StepParameter::_internal_has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline bool StepParameter::has_schedule() const {
  return _internal_has_schedule();
}
inline void StepParameter::clear_schedule() {
  if (_impl_.schedule_ != nullptr) _impl_.schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gooseai::ScheduleParameters& StepParameter::_internal_schedule() const {
  const ::gooseai::ScheduleParameters* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::ScheduleParameters&>(
      ::gooseai::_ScheduleParameters_default_instance_);
}
inline const ::gooseai::ScheduleParameters& StepParameter::schedule() const {
  // @@protoc_insertion_point(field_get:gooseai.StepParameter.schedule)
  return _internal_schedule();
}
inline void StepParameter::unsafe_arena_set_allocated_schedule(
    ::gooseai::ScheduleParameters* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.StepParameter.schedule)
}
inline ::gooseai::ScheduleParameters* StepParameter::release_schedule() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::ScheduleParameters* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::ScheduleParameters* StepParameter::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:gooseai.StepParameter.schedule)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::ScheduleParameters* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::gooseai::ScheduleParameters* StepParameter::_internal_mutable_schedule() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::ScheduleParameters>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::gooseai::ScheduleParameters* StepParameter::mutable_schedule() {
  ::gooseai::ScheduleParameters* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:gooseai.StepParameter.schedule)
  return _msg;
}
inline void StepParameter::set_allocated_schedule(::gooseai::ScheduleParameters* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schedule_;
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schedule);
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:gooseai.StepParameter.schedule)
}

// optional .gooseai.GuidanceParameters guidance = 4 [json_name = "guidance"];
inline bool StepParameter::_internal_has_guidance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.guidance_ != nullptr);
  return value;
}
inline bool StepParameter::has_guidance() const {
  return _internal_has_guidance();
}
inline void StepParameter::clear_guidance() {
  if (_impl_.guidance_ != nullptr) _impl_.guidance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::gooseai::GuidanceParameters& StepParameter::_internal_guidance() const {
  const ::gooseai::GuidanceParameters* p = _impl_.guidance_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::GuidanceParameters&>(
      ::gooseai::_GuidanceParameters_default_instance_);
}
inline const ::gooseai::GuidanceParameters& StepParameter::guidance() const {
  // @@protoc_insertion_point(field_get:gooseai.StepParameter.guidance)
  return _internal_guidance();
}
inline void StepParameter::unsafe_arena_set_allocated_guidance(
    ::gooseai::GuidanceParameters* guidance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guidance_);
  }
  _impl_.guidance_ = guidance;
  if (guidance) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.StepParameter.guidance)
}
inline ::gooseai::GuidanceParameters* StepParameter::release_guidance() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gooseai::GuidanceParameters* temp = _impl_.guidance_;
  _impl_.guidance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::GuidanceParameters* StepParameter::unsafe_arena_release_guidance() {
  // @@protoc_insertion_point(field_release:gooseai.StepParameter.guidance)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gooseai::GuidanceParameters* temp = _impl_.guidance_;
  _impl_.guidance_ = nullptr;
  return temp;
}
inline ::gooseai::GuidanceParameters* StepParameter::_internal_mutable_guidance() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.guidance_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::GuidanceParameters>(GetArenaForAllocation());
    _impl_.guidance_ = p;
  }
  return _impl_.guidance_;
}
inline ::gooseai::GuidanceParameters* StepParameter::mutable_guidance() {
  ::gooseai::GuidanceParameters* _msg = _internal_mutable_guidance();
  // @@protoc_insertion_point(field_mutable:gooseai.StepParameter.guidance)
  return _msg;
}
inline void StepParameter::set_allocated_guidance(::gooseai::GuidanceParameters* guidance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guidance_;
  }
  if (guidance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guidance);
    if (message_arena != submessage_arena) {
      guidance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guidance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.guidance_ = guidance;
  // @@protoc_insertion_point(field_set_allocated:gooseai.StepParameter.guidance)
}

// -------------------------------------------------------------------

// Model

// .gooseai.ModelArchitecture architecture = 1 [json_name = "architecture"];
inline void Model::clear_architecture() {
  _impl_.architecture_ = 0;
}
inline ::gooseai::ModelArchitecture Model::_internal_architecture() const {
  return static_cast< ::gooseai::ModelArchitecture >(_impl_.architecture_);
}
inline ::gooseai::ModelArchitecture Model::architecture() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.architecture)
  return _internal_architecture();
}
inline void Model::_internal_set_architecture(::gooseai::ModelArchitecture value) {
  
  _impl_.architecture_ = value;
}
inline void Model::set_architecture(::gooseai::ModelArchitecture value) {
  _internal_set_architecture(value);
  // @@protoc_insertion_point(field_set:gooseai.Model.architecture)
}

// string publisher = 2 [json_name = "publisher"];
inline void Model::clear_publisher() {
  _impl_.publisher_.ClearToEmpty();
}
inline const std::string& Model::publisher() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_publisher(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publisher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Model.publisher)
}
inline std::string* Model::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:gooseai.Model.publisher)
  return _s;
}
inline const std::string& Model::_internal_publisher() const {
  return _impl_.publisher_.Get();
}
inline void Model::_internal_set_publisher(const std::string& value) {
  
  _impl_.publisher_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_publisher() {
  
  return _impl_.publisher_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_publisher() {
  // @@protoc_insertion_point(field_release:gooseai.Model.publisher)
  return _impl_.publisher_.Release();
}
inline void Model::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    
  } else {
    
  }
  _impl_.publisher_.SetAllocated(publisher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Model.publisher)
}

// string dataset = 3 [json_name = "dataset"];
inline void Model::clear_dataset() {
  _impl_.dataset_.ClearToEmpty();
}
inline const std::string& Model::dataset() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.dataset)
  return _internal_dataset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_dataset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dataset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Model.dataset)
}
inline std::string* Model::mutable_dataset() {
  std::string* _s = _internal_mutable_dataset();
  // @@protoc_insertion_point(field_mutable:gooseai.Model.dataset)
  return _s;
}
inline const std::string& Model::_internal_dataset() const {
  return _impl_.dataset_.Get();
}
inline void Model::_internal_set_dataset(const std::string& value) {
  
  _impl_.dataset_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_dataset() {
  
  return _impl_.dataset_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_dataset() {
  // @@protoc_insertion_point(field_release:gooseai.Model.dataset)
  return _impl_.dataset_.Release();
}
inline void Model::set_allocated_dataset(std::string* dataset) {
  if (dataset != nullptr) {
    
  } else {
    
  }
  _impl_.dataset_.SetAllocated(dataset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dataset_.IsDefault()) {
    _impl_.dataset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Model.dataset)
}

// float version = 4 [json_name = "version"];
inline void Model::clear_version() {
  _impl_.version_ = 0;
}
inline float Model::_internal_version() const {
  return _impl_.version_;
}
inline float Model::version() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.version)
  return _internal_version();
}
inline void Model::_internal_set_version(float value) {
  
  _impl_.version_ = value;
}
inline void Model::set_version(float value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:gooseai.Model.version)
}

// string semantic_version = 5 [json_name = "semanticVersion"];
inline void Model::clear_semantic_version() {
  _impl_.semantic_version_.ClearToEmpty();
}
inline const std::string& Model::semantic_version() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.semantic_version)
  return _internal_semantic_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_semantic_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.semantic_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Model.semantic_version)
}
inline std::string* Model::mutable_semantic_version() {
  std::string* _s = _internal_mutable_semantic_version();
  // @@protoc_insertion_point(field_mutable:gooseai.Model.semantic_version)
  return _s;
}
inline const std::string& Model::_internal_semantic_version() const {
  return _impl_.semantic_version_.Get();
}
inline void Model::_internal_set_semantic_version(const std::string& value) {
  
  _impl_.semantic_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_semantic_version() {
  
  return _impl_.semantic_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_semantic_version() {
  // @@protoc_insertion_point(field_release:gooseai.Model.semantic_version)
  return _impl_.semantic_version_.Release();
}
inline void Model::set_allocated_semantic_version(std::string* semantic_version) {
  if (semantic_version != nullptr) {
    
  } else {
    
  }
  _impl_.semantic_version_.SetAllocated(semantic_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.semantic_version_.IsDefault()) {
    _impl_.semantic_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Model.semantic_version)
}

// string alias = 6 [json_name = "alias"];
inline void Model::clear_alias() {
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& Model::alias() const {
  // @@protoc_insertion_point(field_get:gooseai.Model.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_alias(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alias_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Model.alias)
}
inline std::string* Model::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:gooseai.Model.alias)
  return _s;
}
inline const std::string& Model::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void Model::_internal_set_alias(const std::string& value) {
  
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_alias() {
  
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_alias() {
  // @@protoc_insertion_point(field_release:gooseai.Model.alias)
  return _impl_.alias_.Release();
}
inline void Model::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Model.alias)
}

// -------------------------------------------------------------------

// CutoutParameters

// repeated .gooseai.CutoutParameters cutouts = 1 [json_name = "cutouts"];
inline int CutoutParameters::_internal_cutouts_size() const {
  return _impl_.cutouts_.size();
}
inline int CutoutParameters::cutouts_size() const {
  return _internal_cutouts_size();
}
inline void CutoutParameters::clear_cutouts() {
  _impl_.cutouts_.Clear();
}
inline ::gooseai::CutoutParameters* CutoutParameters::mutable_cutouts(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.CutoutParameters.cutouts)
  return _impl_.cutouts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::CutoutParameters >*
CutoutParameters::mutable_cutouts() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.CutoutParameters.cutouts)
  return &_impl_.cutouts_;
}
inline const ::gooseai::CutoutParameters& CutoutParameters::_internal_cutouts(int index) const {
  return _impl_.cutouts_.Get(index);
}
inline const ::gooseai::CutoutParameters& CutoutParameters::cutouts(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.CutoutParameters.cutouts)
  return _internal_cutouts(index);
}
inline ::gooseai::CutoutParameters* CutoutParameters::_internal_add_cutouts() {
  return _impl_.cutouts_.Add();
}
inline ::gooseai::CutoutParameters* CutoutParameters::add_cutouts() {
  ::gooseai::CutoutParameters* _add = _internal_add_cutouts();
  // @@protoc_insertion_point(field_add:gooseai.CutoutParameters.cutouts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::CutoutParameters >&
CutoutParameters::cutouts() const {
  // @@protoc_insertion_point(field_list:gooseai.CutoutParameters.cutouts)
  return _impl_.cutouts_;
}

// optional uint32 count = 2 [json_name = "count"];
inline bool CutoutParameters::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CutoutParameters::has_count() const {
  return _internal_has_count();
}
inline void CutoutParameters::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CutoutParameters::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CutoutParameters::count() const {
  // @@protoc_insertion_point(field_get:gooseai.CutoutParameters.count)
  return _internal_count();
}
inline void CutoutParameters::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.count_ = value;
}
inline void CutoutParameters::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:gooseai.CutoutParameters.count)
}

// optional float gray = 3 [json_name = "gray"];
inline bool CutoutParameters::_internal_has_gray() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CutoutParameters::has_gray() const {
  return _internal_has_gray();
}
inline void CutoutParameters::clear_gray() {
  _impl_.gray_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CutoutParameters::_internal_gray() const {
  return _impl_.gray_;
}
inline float CutoutParameters::gray() const {
  // @@protoc_insertion_point(field_get:gooseai.CutoutParameters.gray)
  return _internal_gray();
}
inline void CutoutParameters::_internal_set_gray(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gray_ = value;
}
inline void CutoutParameters::set_gray(float value) {
  _internal_set_gray(value);
  // @@protoc_insertion_point(field_set:gooseai.CutoutParameters.gray)
}

// optional float blur = 4 [json_name = "blur"];
inline bool CutoutParameters::_internal_has_blur() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CutoutParameters::has_blur() const {
  return _internal_has_blur();
}
inline void CutoutParameters::clear_blur() {
  _impl_.blur_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CutoutParameters::_internal_blur() const {
  return _impl_.blur_;
}
inline float CutoutParameters::blur() const {
  // @@protoc_insertion_point(field_get:gooseai.CutoutParameters.blur)
  return _internal_blur();
}
inline void CutoutParameters::_internal_set_blur(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.blur_ = value;
}
inline void CutoutParameters::set_blur(float value) {
  _internal_set_blur(value);
  // @@protoc_insertion_point(field_set:gooseai.CutoutParameters.blur)
}

// optional float size_power = 5 [json_name = "sizePower"];
inline bool CutoutParameters::_internal_has_size_power() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CutoutParameters::has_size_power() const {
  return _internal_has_size_power();
}
inline void CutoutParameters::clear_size_power() {
  _impl_.size_power_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CutoutParameters::_internal_size_power() const {
  return _impl_.size_power_;
}
inline float CutoutParameters::size_power() const {
  // @@protoc_insertion_point(field_get:gooseai.CutoutParameters.size_power)
  return _internal_size_power();
}
inline void CutoutParameters::_internal_set_size_power(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_power_ = value;
}
inline void CutoutParameters::set_size_power(float value) {
  _internal_set_size_power(value);
  // @@protoc_insertion_point(field_set:gooseai.CutoutParameters.size_power)
}

// -------------------------------------------------------------------

// GuidanceScheduleParameters

// float duration = 1 [json_name = "duration"];
inline void GuidanceScheduleParameters::clear_duration() {
  _impl_.duration_ = 0;
}
inline float GuidanceScheduleParameters::_internal_duration() const {
  return _impl_.duration_;
}
inline float GuidanceScheduleParameters::duration() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceScheduleParameters.duration)
  return _internal_duration();
}
inline void GuidanceScheduleParameters::_internal_set_duration(float value) {
  
  _impl_.duration_ = value;
}
inline void GuidanceScheduleParameters::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:gooseai.GuidanceScheduleParameters.duration)
}

// float value = 2 [json_name = "value"];
inline void GuidanceScheduleParameters::clear_value() {
  _impl_.value_ = 0;
}
inline float GuidanceScheduleParameters::_internal_value() const {
  return _impl_.value_;
}
inline float GuidanceScheduleParameters::value() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceScheduleParameters.value)
  return _internal_value();
}
inline void GuidanceScheduleParameters::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void GuidanceScheduleParameters::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:gooseai.GuidanceScheduleParameters.value)
}

// -------------------------------------------------------------------

// GuidanceInstanceParameters

// repeated .gooseai.Model models = 2 [json_name = "models"];
inline int GuidanceInstanceParameters::_internal_models_size() const {
  return _impl_.models_.size();
}
inline int GuidanceInstanceParameters::models_size() const {
  return _internal_models_size();
}
inline void GuidanceInstanceParameters::clear_models() {
  _impl_.models_.Clear();
}
inline ::gooseai::Model* GuidanceInstanceParameters::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.GuidanceInstanceParameters.models)
  return _impl_.models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Model >*
GuidanceInstanceParameters::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.GuidanceInstanceParameters.models)
  return &_impl_.models_;
}
inline const ::gooseai::Model& GuidanceInstanceParameters::_internal_models(int index) const {
  return _impl_.models_.Get(index);
}
inline const ::gooseai::Model& GuidanceInstanceParameters::models(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceInstanceParameters.models)
  return _internal_models(index);
}
inline ::gooseai::Model* GuidanceInstanceParameters::_internal_add_models() {
  return _impl_.models_.Add();
}
inline ::gooseai::Model* GuidanceInstanceParameters::add_models() {
  ::gooseai::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:gooseai.GuidanceInstanceParameters.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Model >&
GuidanceInstanceParameters::models() const {
  // @@protoc_insertion_point(field_list:gooseai.GuidanceInstanceParameters.models)
  return _impl_.models_;
}

// optional float guidance_strength = 3 [json_name = "guidanceStrength"];
inline bool GuidanceInstanceParameters::_internal_has_guidance_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GuidanceInstanceParameters::has_guidance_strength() const {
  return _internal_has_guidance_strength();
}
inline void GuidanceInstanceParameters::clear_guidance_strength() {
  _impl_.guidance_strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float GuidanceInstanceParameters::_internal_guidance_strength() const {
  return _impl_.guidance_strength_;
}
inline float GuidanceInstanceParameters::guidance_strength() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceInstanceParameters.guidance_strength)
  return _internal_guidance_strength();
}
inline void GuidanceInstanceParameters::_internal_set_guidance_strength(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.guidance_strength_ = value;
}
inline void GuidanceInstanceParameters::set_guidance_strength(float value) {
  _internal_set_guidance_strength(value);
  // @@protoc_insertion_point(field_set:gooseai.GuidanceInstanceParameters.guidance_strength)
}

// repeated .gooseai.GuidanceScheduleParameters schedule = 4 [json_name = "schedule"];
inline int GuidanceInstanceParameters::_internal_schedule_size() const {
  return _impl_.schedule_.size();
}
inline int GuidanceInstanceParameters::schedule_size() const {
  return _internal_schedule_size();
}
inline void GuidanceInstanceParameters::clear_schedule() {
  _impl_.schedule_.Clear();
}
inline ::gooseai::GuidanceScheduleParameters* GuidanceInstanceParameters::mutable_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.GuidanceInstanceParameters.schedule)
  return _impl_.schedule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceScheduleParameters >*
GuidanceInstanceParameters::mutable_schedule() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.GuidanceInstanceParameters.schedule)
  return &_impl_.schedule_;
}
inline const ::gooseai::GuidanceScheduleParameters& GuidanceInstanceParameters::_internal_schedule(int index) const {
  return _impl_.schedule_.Get(index);
}
inline const ::gooseai::GuidanceScheduleParameters& GuidanceInstanceParameters::schedule(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceInstanceParameters.schedule)
  return _internal_schedule(index);
}
inline ::gooseai::GuidanceScheduleParameters* GuidanceInstanceParameters::_internal_add_schedule() {
  return _impl_.schedule_.Add();
}
inline ::gooseai::GuidanceScheduleParameters* GuidanceInstanceParameters::add_schedule() {
  ::gooseai::GuidanceScheduleParameters* _add = _internal_add_schedule();
  // @@protoc_insertion_point(field_add:gooseai.GuidanceInstanceParameters.schedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceScheduleParameters >&
GuidanceInstanceParameters::schedule() const {
  // @@protoc_insertion_point(field_list:gooseai.GuidanceInstanceParameters.schedule)
  return _impl_.schedule_;
}

// optional .gooseai.CutoutParameters cutouts = 5 [json_name = "cutouts"];
inline bool GuidanceInstanceParameters::_internal_has_cutouts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cutouts_ != nullptr);
  return value;
}
inline bool GuidanceInstanceParameters::has_cutouts() const {
  return _internal_has_cutouts();
}
inline void GuidanceInstanceParameters::clear_cutouts() {
  if (_impl_.cutouts_ != nullptr) _impl_.cutouts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::CutoutParameters& GuidanceInstanceParameters::_internal_cutouts() const {
  const ::gooseai::CutoutParameters* p = _impl_.cutouts_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::CutoutParameters&>(
      ::gooseai::_CutoutParameters_default_instance_);
}
inline const ::gooseai::CutoutParameters& GuidanceInstanceParameters::cutouts() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceInstanceParameters.cutouts)
  return _internal_cutouts();
}
inline void GuidanceInstanceParameters::unsafe_arena_set_allocated_cutouts(
    ::gooseai::CutoutParameters* cutouts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cutouts_);
  }
  _impl_.cutouts_ = cutouts;
  if (cutouts) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.GuidanceInstanceParameters.cutouts)
}
inline ::gooseai::CutoutParameters* GuidanceInstanceParameters::release_cutouts() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::CutoutParameters* temp = _impl_.cutouts_;
  _impl_.cutouts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::CutoutParameters* GuidanceInstanceParameters::unsafe_arena_release_cutouts() {
  // @@protoc_insertion_point(field_release:gooseai.GuidanceInstanceParameters.cutouts)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::CutoutParameters* temp = _impl_.cutouts_;
  _impl_.cutouts_ = nullptr;
  return temp;
}
inline ::gooseai::CutoutParameters* GuidanceInstanceParameters::_internal_mutable_cutouts() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cutouts_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::CutoutParameters>(GetArenaForAllocation());
    _impl_.cutouts_ = p;
  }
  return _impl_.cutouts_;
}
inline ::gooseai::CutoutParameters* GuidanceInstanceParameters::mutable_cutouts() {
  ::gooseai::CutoutParameters* _msg = _internal_mutable_cutouts();
  // @@protoc_insertion_point(field_mutable:gooseai.GuidanceInstanceParameters.cutouts)
  return _msg;
}
inline void GuidanceInstanceParameters::set_allocated_cutouts(::gooseai::CutoutParameters* cutouts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cutouts_;
  }
  if (cutouts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cutouts);
    if (message_arena != submessage_arena) {
      cutouts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cutouts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cutouts_ = cutouts;
  // @@protoc_insertion_point(field_set_allocated:gooseai.GuidanceInstanceParameters.cutouts)
}

// optional .gooseai.Prompt prompt = 6 [json_name = "prompt"];
inline bool GuidanceInstanceParameters::_internal_has_prompt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prompt_ != nullptr);
  return value;
}
inline bool GuidanceInstanceParameters::has_prompt() const {
  return _internal_has_prompt();
}
inline void GuidanceInstanceParameters::clear_prompt() {
  if (_impl_.prompt_ != nullptr) _impl_.prompt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gooseai::Prompt& GuidanceInstanceParameters::_internal_prompt() const {
  const ::gooseai::Prompt* p = _impl_.prompt_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::Prompt&>(
      ::gooseai::_Prompt_default_instance_);
}
inline const ::gooseai::Prompt& GuidanceInstanceParameters::prompt() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceInstanceParameters.prompt)
  return _internal_prompt();
}
inline void GuidanceInstanceParameters::unsafe_arena_set_allocated_prompt(
    ::gooseai::Prompt* prompt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_);
  }
  _impl_.prompt_ = prompt;
  if (prompt) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.GuidanceInstanceParameters.prompt)
}
inline ::gooseai::Prompt* GuidanceInstanceParameters::release_prompt() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::Prompt* GuidanceInstanceParameters::unsafe_arena_release_prompt() {
  // @@protoc_insertion_point(field_release:gooseai.GuidanceInstanceParameters.prompt)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gooseai::Prompt* temp = _impl_.prompt_;
  _impl_.prompt_ = nullptr;
  return temp;
}
inline ::gooseai::Prompt* GuidanceInstanceParameters::_internal_mutable_prompt() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.prompt_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::Prompt>(GetArenaForAllocation());
    _impl_.prompt_ = p;
  }
  return _impl_.prompt_;
}
inline ::gooseai::Prompt* GuidanceInstanceParameters::mutable_prompt() {
  ::gooseai::Prompt* _msg = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:gooseai.GuidanceInstanceParameters.prompt)
  return _msg;
}
inline void GuidanceInstanceParameters::set_allocated_prompt(::gooseai::Prompt* prompt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prompt_;
  }
  if (prompt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt);
    if (message_arena != submessage_arena) {
      prompt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.prompt_ = prompt;
  // @@protoc_insertion_point(field_set_allocated:gooseai.GuidanceInstanceParameters.prompt)
}

// -------------------------------------------------------------------

// GuidanceParameters

// .gooseai.GuidancePreset guidance_preset = 1 [json_name = "guidancePreset"];
inline void GuidanceParameters::clear_guidance_preset() {
  _impl_.guidance_preset_ = 0;
}
inline ::gooseai::GuidancePreset GuidanceParameters::_internal_guidance_preset() const {
  return static_cast< ::gooseai::GuidancePreset >(_impl_.guidance_preset_);
}
inline ::gooseai::GuidancePreset GuidanceParameters::guidance_preset() const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceParameters.guidance_preset)
  return _internal_guidance_preset();
}
inline void GuidanceParameters::_internal_set_guidance_preset(::gooseai::GuidancePreset value) {
  
  _impl_.guidance_preset_ = value;
}
inline void GuidanceParameters::set_guidance_preset(::gooseai::GuidancePreset value) {
  _internal_set_guidance_preset(value);
  // @@protoc_insertion_point(field_set:gooseai.GuidanceParameters.guidance_preset)
}

// repeated .gooseai.GuidanceInstanceParameters instances = 2 [json_name = "instances"];
inline int GuidanceParameters::_internal_instances_size() const {
  return _impl_.instances_.size();
}
inline int GuidanceParameters::instances_size() const {
  return _internal_instances_size();
}
inline void GuidanceParameters::clear_instances() {
  _impl_.instances_.Clear();
}
inline ::gooseai::GuidanceInstanceParameters* GuidanceParameters::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.GuidanceParameters.instances)
  return _impl_.instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceInstanceParameters >*
GuidanceParameters::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.GuidanceParameters.instances)
  return &_impl_.instances_;
}
inline const ::gooseai::GuidanceInstanceParameters& GuidanceParameters::_internal_instances(int index) const {
  return _impl_.instances_.Get(index);
}
inline const ::gooseai::GuidanceInstanceParameters& GuidanceParameters::instances(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.GuidanceParameters.instances)
  return _internal_instances(index);
}
inline ::gooseai::GuidanceInstanceParameters* GuidanceParameters::_internal_add_instances() {
  return _impl_.instances_.Add();
}
inline ::gooseai::GuidanceInstanceParameters* GuidanceParameters::add_instances() {
  ::gooseai::GuidanceInstanceParameters* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:gooseai.GuidanceParameters.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::GuidanceInstanceParameters >&
GuidanceParameters::instances() const {
  // @@protoc_insertion_point(field_list:gooseai.GuidanceParameters.instances)
  return _impl_.instances_;
}

// -------------------------------------------------------------------

// TransformType

// .gooseai.DiffusionSampler diffusion = 1 [json_name = "diffusion"];
inline bool TransformType::_internal_has_diffusion() const {
  return type_case() == kDiffusion;
}
inline bool TransformType::has_diffusion() const {
  return _internal_has_diffusion();
}
inline void TransformType::set_has_diffusion() {
  _impl_._oneof_case_[0] = kDiffusion;
}
inline void TransformType::clear_diffusion() {
  if (_internal_has_diffusion()) {
    _impl_.type_.diffusion_ = 0;
    clear_has_type();
  }
}
inline ::gooseai::DiffusionSampler TransformType::_internal_diffusion() const {
  if (_internal_has_diffusion()) {
    return static_cast< ::gooseai::DiffusionSampler >(_impl_.type_.diffusion_);
  }
  return static_cast< ::gooseai::DiffusionSampler >(0);
}
inline ::gooseai::DiffusionSampler TransformType::diffusion() const {
  // @@protoc_insertion_point(field_get:gooseai.TransformType.diffusion)
  return _internal_diffusion();
}
inline void TransformType::_internal_set_diffusion(::gooseai::DiffusionSampler value) {
  if (!_internal_has_diffusion()) {
    clear_type();
    set_has_diffusion();
  }
  _impl_.type_.diffusion_ = value;
}
inline void TransformType::set_diffusion(::gooseai::DiffusionSampler value) {
  _internal_set_diffusion(value);
  // @@protoc_insertion_point(field_set:gooseai.TransformType.diffusion)
}

// .gooseai.Upscaler upscaler = 2 [json_name = "upscaler"];
inline bool TransformType::_internal_has_upscaler() const {
  return type_case() == kUpscaler;
}
inline bool TransformType::has_upscaler() const {
  return _internal_has_upscaler();
}
inline void TransformType::set_has_upscaler() {
  _impl_._oneof_case_[0] = kUpscaler;
}
inline void TransformType::clear_upscaler() {
  if (_internal_has_upscaler()) {
    _impl_.type_.upscaler_ = 0;
    clear_has_type();
  }
}
inline ::gooseai::Upscaler TransformType::_internal_upscaler() const {
  if (_internal_has_upscaler()) {
    return static_cast< ::gooseai::Upscaler >(_impl_.type_.upscaler_);
  }
  return static_cast< ::gooseai::Upscaler >(0);
}
inline ::gooseai::Upscaler TransformType::upscaler() const {
  // @@protoc_insertion_point(field_get:gooseai.TransformType.upscaler)
  return _internal_upscaler();
}
inline void TransformType::_internal_set_upscaler(::gooseai::Upscaler value) {
  if (!_internal_has_upscaler()) {
    clear_type();
    set_has_upscaler();
  }
  _impl_.type_.upscaler_ = value;
}
inline void TransformType::set_upscaler(::gooseai::Upscaler value) {
  _internal_set_upscaler(value);
  // @@protoc_insertion_point(field_set:gooseai.TransformType.upscaler)
}

inline bool TransformType::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void TransformType::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline TransformType::TypeCase TransformType::type_case() const {
  return TransformType::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ImageParameters

// optional uint64 height = 1 [json_name = "height"];
inline bool ImageParameters::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageParameters::has_height() const {
  return _internal_has_height();
}
inline void ImageParameters::clear_height() {
  _impl_.height_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ImageParameters::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t ImageParameters::height() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.height)
  return _internal_height();
}
inline void ImageParameters::_internal_set_height(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void ImageParameters::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.height)
}

// optional uint64 width = 2 [json_name = "width"];
inline bool ImageParameters::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImageParameters::has_width() const {
  return _internal_has_width();
}
inline void ImageParameters::clear_width() {
  _impl_.width_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ImageParameters::_internal_width() const {
  return _impl_.width_;
}
inline uint64_t ImageParameters::width() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.width)
  return _internal_width();
}
inline void ImageParameters::_internal_set_width(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void ImageParameters::set_width(uint64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.width)
}

// repeated uint32 seed = 3 [json_name = "seed"];
inline int ImageParameters::_internal_seed_size() const {
  return _impl_.seed_.size();
}
inline int ImageParameters::seed_size() const {
  return _internal_seed_size();
}
inline void ImageParameters::clear_seed() {
  _impl_.seed_.Clear();
}
inline uint32_t ImageParameters::_internal_seed(int index) const {
  return _impl_.seed_.Get(index);
}
inline uint32_t ImageParameters::seed(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.seed)
  return _internal_seed(index);
}
inline void ImageParameters::set_seed(int index, uint32_t value) {
  _impl_.seed_.Set(index, value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.seed)
}
inline void ImageParameters::_internal_add_seed(uint32_t value) {
  _impl_.seed_.Add(value);
}
inline void ImageParameters::add_seed(uint32_t value) {
  _internal_add_seed(value);
  // @@protoc_insertion_point(field_add:gooseai.ImageParameters.seed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ImageParameters::_internal_seed() const {
  return _impl_.seed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ImageParameters::seed() const {
  // @@protoc_insertion_point(field_list:gooseai.ImageParameters.seed)
  return _internal_seed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ImageParameters::_internal_mutable_seed() {
  return &_impl_.seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ImageParameters::mutable_seed() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ImageParameters.seed)
  return _internal_mutable_seed();
}

// optional uint64 samples = 4 [json_name = "samples"];
inline bool ImageParameters::_internal_has_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImageParameters::has_samples() const {
  return _internal_has_samples();
}
inline void ImageParameters::clear_samples() {
  _impl_.samples_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ImageParameters::_internal_samples() const {
  return _impl_.samples_;
}
inline uint64_t ImageParameters::samples() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.samples)
  return _internal_samples();
}
inline void ImageParameters::_internal_set_samples(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.samples_ = value;
}
inline void ImageParameters::set_samples(uint64_t value) {
  _internal_set_samples(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.samples)
}

// optional uint64 steps = 5 [json_name = "steps"];
inline bool ImageParameters::_internal_has_steps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImageParameters::has_steps() const {
  return _internal_has_steps();
}
inline void ImageParameters::clear_steps() {
  _impl_.steps_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t ImageParameters::_internal_steps() const {
  return _impl_.steps_;
}
inline uint64_t ImageParameters::steps() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.steps)
  return _internal_steps();
}
inline void ImageParameters::_internal_set_steps(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.steps_ = value;
}
inline void ImageParameters::set_steps(uint64_t value) {
  _internal_set_steps(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.steps)
}

// optional .gooseai.TransformType transform = 6 [json_name = "transform"];
inline bool ImageParameters::_internal_has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline bool ImageParameters::has_transform() const {
  return _internal_has_transform();
}
inline void ImageParameters::clear_transform() {
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::TransformType& ImageParameters::_internal_transform() const {
  const ::gooseai::TransformType* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::TransformType&>(
      ::gooseai::_TransformType_default_instance_);
}
inline const ::gooseai::TransformType& ImageParameters::transform() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.transform)
  return _internal_transform();
}
inline void ImageParameters::unsafe_arena_set_allocated_transform(
    ::gooseai::TransformType* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.ImageParameters.transform)
}
inline ::gooseai::TransformType* ImageParameters::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::TransformType* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::TransformType* ImageParameters::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:gooseai.ImageParameters.transform)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::TransformType* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::gooseai::TransformType* ImageParameters::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::TransformType>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::gooseai::TransformType* ImageParameters::mutable_transform() {
  ::gooseai::TransformType* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:gooseai.ImageParameters.transform)
  return _msg;
}
inline void ImageParameters::set_allocated_transform(::gooseai::TransformType* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:gooseai.ImageParameters.transform)
}

// repeated .gooseai.StepParameter parameters = 7 [json_name = "parameters"];
inline int ImageParameters::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int ImageParameters::parameters_size() const {
  return _internal_parameters_size();
}
inline void ImageParameters::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::gooseai::StepParameter* ImageParameters::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.ImageParameters.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::StepParameter >*
ImageParameters::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ImageParameters.parameters)
  return &_impl_.parameters_;
}
inline const ::gooseai::StepParameter& ImageParameters::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::gooseai::StepParameter& ImageParameters::parameters(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.parameters)
  return _internal_parameters(index);
}
inline ::gooseai::StepParameter* ImageParameters::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::gooseai::StepParameter* ImageParameters::add_parameters() {
  ::gooseai::StepParameter* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:gooseai.ImageParameters.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::StepParameter >&
ImageParameters::parameters() const {
  // @@protoc_insertion_point(field_list:gooseai.ImageParameters.parameters)
  return _impl_.parameters_;
}

// optional .gooseai.MaskedAreaInit masked_area_init = 8 [json_name = "maskedAreaInit"];
inline bool ImageParameters::_internal_has_masked_area_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImageParameters::has_masked_area_init() const {
  return _internal_has_masked_area_init();
}
inline void ImageParameters::clear_masked_area_init() {
  _impl_.masked_area_init_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::gooseai::MaskedAreaInit ImageParameters::_internal_masked_area_init() const {
  return static_cast< ::gooseai::MaskedAreaInit >(_impl_.masked_area_init_);
}
inline ::gooseai::MaskedAreaInit ImageParameters::masked_area_init() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.masked_area_init)
  return _internal_masked_area_init();
}
inline void ImageParameters::_internal_set_masked_area_init(::gooseai::MaskedAreaInit value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.masked_area_init_ = value;
}
inline void ImageParameters::set_masked_area_init(::gooseai::MaskedAreaInit value) {
  _internal_set_masked_area_init(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.masked_area_init)
}

// optional .gooseai.WeightMethod weight_method = 9 [json_name = "weightMethod"];
inline bool ImageParameters::_internal_has_weight_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImageParameters::has_weight_method() const {
  return _internal_has_weight_method();
}
inline void ImageParameters::clear_weight_method() {
  _impl_.weight_method_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::gooseai::WeightMethod ImageParameters::_internal_weight_method() const {
  return static_cast< ::gooseai::WeightMethod >(_impl_.weight_method_);
}
inline ::gooseai::WeightMethod ImageParameters::weight_method() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.weight_method)
  return _internal_weight_method();
}
inline void ImageParameters::_internal_set_weight_method(::gooseai::WeightMethod value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.weight_method_ = value;
}
inline void ImageParameters::set_weight_method(::gooseai::WeightMethod value) {
  _internal_set_weight_method(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.weight_method)
}

// optional bool quantize = 10 [json_name = "quantize"];
inline bool ImageParameters::_internal_has_quantize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageParameters::has_quantize() const {
  return _internal_has_quantize();
}
inline void ImageParameters::clear_quantize() {
  _impl_.quantize_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ImageParameters::_internal_quantize() const {
  return _impl_.quantize_;
}
inline bool ImageParameters::quantize() const {
  // @@protoc_insertion_point(field_get:gooseai.ImageParameters.quantize)
  return _internal_quantize();
}
inline void ImageParameters::_internal_set_quantize(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.quantize_ = value;
}
inline void ImageParameters::set_quantize(bool value) {
  _internal_set_quantize(value);
  // @@protoc_insertion_point(field_set:gooseai.ImageParameters.quantize)
}

// -------------------------------------------------------------------

// ClassifierConcept

// string concept = 1 [json_name = "concept"];
inline void ClassifierConcept::clear_concept() {
  _impl_.concept_.ClearToEmpty();
}
inline const std::string& ClassifierConcept::concept() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierConcept.concept)
  return _internal_concept();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClassifierConcept::set_concept(ArgT0&& arg0, ArgT... args) {
 
 _impl_.concept_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.ClassifierConcept.concept)
}
inline std::string* ClassifierConcept::mutable_concept() {
  std::string* _s = _internal_mutable_concept();
  // @@protoc_insertion_point(field_mutable:gooseai.ClassifierConcept.concept)
  return _s;
}
inline const std::string& ClassifierConcept::_internal_concept() const {
  return _impl_.concept_.Get();
}
inline void ClassifierConcept::_internal_set_concept(const std::string& value) {
  
  _impl_.concept_.Set(value, GetArenaForAllocation());
}
inline std::string* ClassifierConcept::_internal_mutable_concept() {
  
  return _impl_.concept_.Mutable(GetArenaForAllocation());
}
inline std::string* ClassifierConcept::release_concept() {
  // @@protoc_insertion_point(field_release:gooseai.ClassifierConcept.concept)
  return _impl_.concept_.Release();
}
inline void ClassifierConcept::set_allocated_concept(std::string* concept) {
  if (concept != nullptr) {
    
  } else {
    
  }
  _impl_.concept_.SetAllocated(concept, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.concept_.IsDefault()) {
    _impl_.concept_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.ClassifierConcept.concept)
}

// optional float threshold = 2 [json_name = "threshold"];
inline bool ClassifierConcept::_internal_has_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClassifierConcept::has_threshold() const {
  return _internal_has_threshold();
}
inline void ClassifierConcept::clear_threshold() {
  _impl_.threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ClassifierConcept::_internal_threshold() const {
  return _impl_.threshold_;
}
inline float ClassifierConcept::threshold() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierConcept.threshold)
  return _internal_threshold();
}
inline void ClassifierConcept::_internal_set_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.threshold_ = value;
}
inline void ClassifierConcept::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:gooseai.ClassifierConcept.threshold)
}

// -------------------------------------------------------------------

// ClassifierCategory

// string name = 1 [json_name = "name"];
inline void ClassifierCategory::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ClassifierCategory::name() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierCategory.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClassifierCategory::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.ClassifierCategory.name)
}
inline std::string* ClassifierCategory::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gooseai.ClassifierCategory.name)
  return _s;
}
inline const std::string& ClassifierCategory::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ClassifierCategory::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClassifierCategory::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClassifierCategory::release_name() {
  // @@protoc_insertion_point(field_release:gooseai.ClassifierCategory.name)
  return _impl_.name_.Release();
}
inline void ClassifierCategory::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.ClassifierCategory.name)
}

// repeated .gooseai.ClassifierConcept concepts = 2 [json_name = "concepts"];
inline int ClassifierCategory::_internal_concepts_size() const {
  return _impl_.concepts_.size();
}
inline int ClassifierCategory::concepts_size() const {
  return _internal_concepts_size();
}
inline void ClassifierCategory::clear_concepts() {
  _impl_.concepts_.Clear();
}
inline ::gooseai::ClassifierConcept* ClassifierCategory::mutable_concepts(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.ClassifierCategory.concepts)
  return _impl_.concepts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierConcept >*
ClassifierCategory::mutable_concepts() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ClassifierCategory.concepts)
  return &_impl_.concepts_;
}
inline const ::gooseai::ClassifierConcept& ClassifierCategory::_internal_concepts(int index) const {
  return _impl_.concepts_.Get(index);
}
inline const ::gooseai::ClassifierConcept& ClassifierCategory::concepts(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierCategory.concepts)
  return _internal_concepts(index);
}
inline ::gooseai::ClassifierConcept* ClassifierCategory::_internal_add_concepts() {
  return _impl_.concepts_.Add();
}
inline ::gooseai::ClassifierConcept* ClassifierCategory::add_concepts() {
  ::gooseai::ClassifierConcept* _add = _internal_add_concepts();
  // @@protoc_insertion_point(field_add:gooseai.ClassifierCategory.concepts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierConcept >&
ClassifierCategory::concepts() const {
  // @@protoc_insertion_point(field_list:gooseai.ClassifierCategory.concepts)
  return _impl_.concepts_;
}

// optional float adjustment = 3 [json_name = "adjustment"];
inline bool ClassifierCategory::_internal_has_adjustment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClassifierCategory::has_adjustment() const {
  return _internal_has_adjustment();
}
inline void ClassifierCategory::clear_adjustment() {
  _impl_.adjustment_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ClassifierCategory::_internal_adjustment() const {
  return _impl_.adjustment_;
}
inline float ClassifierCategory::adjustment() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierCategory.adjustment)
  return _internal_adjustment();
}
inline void ClassifierCategory::_internal_set_adjustment(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.adjustment_ = value;
}
inline void ClassifierCategory::set_adjustment(float value) {
  _internal_set_adjustment(value);
  // @@protoc_insertion_point(field_set:gooseai.ClassifierCategory.adjustment)
}

// optional .gooseai.Action action = 4 [json_name = "action"];
inline bool ClassifierCategory::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClassifierCategory::has_action() const {
  return _internal_has_action();
}
inline void ClassifierCategory::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::gooseai::Action ClassifierCategory::_internal_action() const {
  return static_cast< ::gooseai::Action >(_impl_.action_);
}
inline ::gooseai::Action ClassifierCategory::action() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierCategory.action)
  return _internal_action();
}
inline void ClassifierCategory::_internal_set_action(::gooseai::Action value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.action_ = value;
}
inline void ClassifierCategory::set_action(::gooseai::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:gooseai.ClassifierCategory.action)
}

// optional .gooseai.ClassifierMode classifier_mode = 5 [json_name = "classifierMode"];
inline bool ClassifierCategory::_internal_has_classifier_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClassifierCategory::has_classifier_mode() const {
  return _internal_has_classifier_mode();
}
inline void ClassifierCategory::clear_classifier_mode() {
  _impl_.classifier_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::gooseai::ClassifierMode ClassifierCategory::_internal_classifier_mode() const {
  return static_cast< ::gooseai::ClassifierMode >(_impl_.classifier_mode_);
}
inline ::gooseai::ClassifierMode ClassifierCategory::classifier_mode() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierCategory.classifier_mode)
  return _internal_classifier_mode();
}
inline void ClassifierCategory::_internal_set_classifier_mode(::gooseai::ClassifierMode value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.classifier_mode_ = value;
}
inline void ClassifierCategory::set_classifier_mode(::gooseai::ClassifierMode value) {
  _internal_set_classifier_mode(value);
  // @@protoc_insertion_point(field_set:gooseai.ClassifierCategory.classifier_mode)
}

// -------------------------------------------------------------------

// ClassifierParameters

// repeated .gooseai.ClassifierCategory categories = 1 [json_name = "categories"];
inline int ClassifierParameters::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int ClassifierParameters::categories_size() const {
  return _internal_categories_size();
}
inline void ClassifierParameters::clear_categories() {
  _impl_.categories_.Clear();
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.ClassifierParameters.categories)
  return _impl_.categories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >*
ClassifierParameters::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ClassifierParameters.categories)
  return &_impl_.categories_;
}
inline const ::gooseai::ClassifierCategory& ClassifierParameters::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const ::gooseai::ClassifierCategory& ClassifierParameters::categories(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierParameters.categories)
  return _internal_categories(index);
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::add_categories() {
  ::gooseai::ClassifierCategory* _add = _internal_add_categories();
  // @@protoc_insertion_point(field_add:gooseai.ClassifierParameters.categories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >&
ClassifierParameters::categories() const {
  // @@protoc_insertion_point(field_list:gooseai.ClassifierParameters.categories)
  return _impl_.categories_;
}

// repeated .gooseai.ClassifierCategory exceeds = 2 [json_name = "exceeds"];
inline int ClassifierParameters::_internal_exceeds_size() const {
  return _impl_.exceeds_.size();
}
inline int ClassifierParameters::exceeds_size() const {
  return _internal_exceeds_size();
}
inline void ClassifierParameters::clear_exceeds() {
  _impl_.exceeds_.Clear();
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::mutable_exceeds(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.ClassifierParameters.exceeds)
  return _impl_.exceeds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >*
ClassifierParameters::mutable_exceeds() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ClassifierParameters.exceeds)
  return &_impl_.exceeds_;
}
inline const ::gooseai::ClassifierCategory& ClassifierParameters::_internal_exceeds(int index) const {
  return _impl_.exceeds_.Get(index);
}
inline const ::gooseai::ClassifierCategory& ClassifierParameters::exceeds(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierParameters.exceeds)
  return _internal_exceeds(index);
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::_internal_add_exceeds() {
  return _impl_.exceeds_.Add();
}
inline ::gooseai::ClassifierCategory* ClassifierParameters::add_exceeds() {
  ::gooseai::ClassifierCategory* _add = _internal_add_exceeds();
  // @@protoc_insertion_point(field_add:gooseai.ClassifierParameters.exceeds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::ClassifierCategory >&
ClassifierParameters::exceeds() const {
  // @@protoc_insertion_point(field_list:gooseai.ClassifierParameters.exceeds)
  return _impl_.exceeds_;
}

// optional .gooseai.Action realized_action = 3 [json_name = "realizedAction"];
inline bool ClassifierParameters::_internal_has_realized_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClassifierParameters::has_realized_action() const {
  return _internal_has_realized_action();
}
inline void ClassifierParameters::clear_realized_action() {
  _impl_.realized_action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::gooseai::Action ClassifierParameters::_internal_realized_action() const {
  return static_cast< ::gooseai::Action >(_impl_.realized_action_);
}
inline ::gooseai::Action ClassifierParameters::realized_action() const {
  // @@protoc_insertion_point(field_get:gooseai.ClassifierParameters.realized_action)
  return _internal_realized_action();
}
inline void ClassifierParameters::_internal_set_realized_action(::gooseai::Action value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.realized_action_ = value;
}
inline void ClassifierParameters::set_realized_action(::gooseai::Action value) {
  _internal_set_realized_action(value);
  // @@protoc_insertion_point(field_set:gooseai.ClassifierParameters.realized_action)
}

// -------------------------------------------------------------------

// AssetParameters

// .gooseai.AssetAction action = 1 [json_name = "action"];
inline void AssetParameters::clear_action() {
  _impl_.action_ = 0;
}
inline ::gooseai::AssetAction AssetParameters::_internal_action() const {
  return static_cast< ::gooseai::AssetAction >(_impl_.action_);
}
inline ::gooseai::AssetAction AssetParameters::action() const {
  // @@protoc_insertion_point(field_get:gooseai.AssetParameters.action)
  return _internal_action();
}
inline void AssetParameters::_internal_set_action(::gooseai::AssetAction value) {
  
  _impl_.action_ = value;
}
inline void AssetParameters::set_action(::gooseai::AssetAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:gooseai.AssetParameters.action)
}

// string project_id = 2 [json_name = "projectId"];
inline void AssetParameters::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& AssetParameters::project_id() const {
  // @@protoc_insertion_point(field_get:gooseai.AssetParameters.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetParameters::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AssetParameters.project_id)
}
inline std::string* AssetParameters::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AssetParameters.project_id)
  return _s;
}
inline const std::string& AssetParameters::_internal_project_id() const {
  return _impl_.project_id_.Get();
}
inline void AssetParameters::_internal_set_project_id(const std::string& value) {
  
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetParameters::_internal_mutable_project_id() {
  
  return _impl_.project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetParameters::release_project_id() {
  // @@protoc_insertion_point(field_release:gooseai.AssetParameters.project_id)
  return _impl_.project_id_.Release();
}
inline void AssetParameters::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  _impl_.project_id_.SetAllocated(project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.project_id_.IsDefault()) {
    _impl_.project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AssetParameters.project_id)
}

// .gooseai.AssetUse use = 3 [json_name = "use"];
inline void AssetParameters::clear_use() {
  _impl_.use_ = 0;
}
inline ::gooseai::AssetUse AssetParameters::_internal_use() const {
  return static_cast< ::gooseai::AssetUse >(_impl_.use_);
}
inline ::gooseai::AssetUse AssetParameters::use() const {
  // @@protoc_insertion_point(field_get:gooseai.AssetParameters.use)
  return _internal_use();
}
inline void AssetParameters::_internal_set_use(::gooseai::AssetUse value) {
  
  _impl_.use_ = value;
}
inline void AssetParameters::set_use(::gooseai::AssetUse value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:gooseai.AssetParameters.use)
}

// -------------------------------------------------------------------

// AnswerMeta

// optional string gpu_id = 1 [json_name = "gpuId"];
inline bool AnswerMeta::_internal_has_gpu_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnswerMeta::has_gpu_id() const {
  return _internal_has_gpu_id();
}
inline void AnswerMeta::clear_gpu_id() {
  _impl_.gpu_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AnswerMeta::gpu_id() const {
  // @@protoc_insertion_point(field_get:gooseai.AnswerMeta.gpu_id)
  return _internal_gpu_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerMeta::set_gpu_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gpu_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AnswerMeta.gpu_id)
}
inline std::string* AnswerMeta::mutable_gpu_id() {
  std::string* _s = _internal_mutable_gpu_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AnswerMeta.gpu_id)
  return _s;
}
inline const std::string& AnswerMeta::_internal_gpu_id() const {
  return _impl_.gpu_id_.Get();
}
inline void AnswerMeta::_internal_set_gpu_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gpu_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerMeta::_internal_mutable_gpu_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gpu_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerMeta::release_gpu_id() {
  // @@protoc_insertion_point(field_release:gooseai.AnswerMeta.gpu_id)
  if (!_internal_has_gpu_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gpu_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gpu_id_.IsDefault()) {
    _impl_.gpu_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AnswerMeta::set_allocated_gpu_id(std::string* gpu_id) {
  if (gpu_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gpu_id_.SetAllocated(gpu_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gpu_id_.IsDefault()) {
    _impl_.gpu_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AnswerMeta.gpu_id)
}

// optional string cpu_id = 2 [json_name = "cpuId"];
inline bool AnswerMeta::_internal_has_cpu_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AnswerMeta::has_cpu_id() const {
  return _internal_has_cpu_id();
}
inline void AnswerMeta::clear_cpu_id() {
  _impl_.cpu_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AnswerMeta::cpu_id() const {
  // @@protoc_insertion_point(field_get:gooseai.AnswerMeta.cpu_id)
  return _internal_cpu_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerMeta::set_cpu_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cpu_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AnswerMeta.cpu_id)
}
inline std::string* AnswerMeta::mutable_cpu_id() {
  std::string* _s = _internal_mutable_cpu_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AnswerMeta.cpu_id)
  return _s;
}
inline const std::string& AnswerMeta::_internal_cpu_id() const {
  return _impl_.cpu_id_.Get();
}
inline void AnswerMeta::_internal_set_cpu_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cpu_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerMeta::_internal_mutable_cpu_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cpu_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerMeta::release_cpu_id() {
  // @@protoc_insertion_point(field_release:gooseai.AnswerMeta.cpu_id)
  if (!_internal_has_cpu_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cpu_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpu_id_.IsDefault()) {
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AnswerMeta::set_allocated_cpu_id(std::string* cpu_id) {
  if (cpu_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cpu_id_.SetAllocated(cpu_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpu_id_.IsDefault()) {
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AnswerMeta.cpu_id)
}

// optional string node_id = 3 [json_name = "nodeId"];
inline bool AnswerMeta::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AnswerMeta::has_node_id() const {
  return _internal_has_node_id();
}
inline void AnswerMeta::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AnswerMeta::node_id() const {
  // @@protoc_insertion_point(field_get:gooseai.AnswerMeta.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerMeta::set_node_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AnswerMeta.node_id)
}
inline std::string* AnswerMeta::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AnswerMeta.node_id)
  return _s;
}
inline const std::string& AnswerMeta::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void AnswerMeta::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerMeta::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerMeta::release_node_id() {
  // @@protoc_insertion_point(field_release:gooseai.AnswerMeta.node_id)
  if (!_internal_has_node_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.node_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AnswerMeta::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.node_id_.SetAllocated(node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AnswerMeta.node_id)
}

// optional string engine_id = 4 [json_name = "engineId"];
inline bool AnswerMeta::_internal_has_engine_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AnswerMeta::has_engine_id() const {
  return _internal_has_engine_id();
}
inline void AnswerMeta::clear_engine_id() {
  _impl_.engine_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AnswerMeta::engine_id() const {
  // @@protoc_insertion_point(field_get:gooseai.AnswerMeta.engine_id)
  return _internal_engine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerMeta::set_engine_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.engine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.AnswerMeta.engine_id)
}
inline std::string* AnswerMeta::mutable_engine_id() {
  std::string* _s = _internal_mutable_engine_id();
  // @@protoc_insertion_point(field_mutable:gooseai.AnswerMeta.engine_id)
  return _s;
}
inline const std::string& AnswerMeta::_internal_engine_id() const {
  return _impl_.engine_id_.Get();
}
inline void AnswerMeta::_internal_set_engine_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.engine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnswerMeta::_internal_mutable_engine_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.engine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnswerMeta::release_engine_id() {
  // @@protoc_insertion_point(field_release:gooseai.AnswerMeta.engine_id)
  if (!_internal_has_engine_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.engine_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_id_.IsDefault()) {
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AnswerMeta::set_allocated_engine_id(std::string* engine_id) {
  if (engine_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.engine_id_.SetAllocated(engine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_id_.IsDefault()) {
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.AnswerMeta.engine_id)
}

// -------------------------------------------------------------------

// Answer

// string answer_id = 1 [json_name = "answerId"];
inline void Answer::clear_answer_id() {
  _impl_.answer_id_.ClearToEmpty();
}
inline const std::string& Answer::answer_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.answer_id)
  return _internal_answer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_answer_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.answer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Answer.answer_id)
}
inline std::string* Answer::mutable_answer_id() {
  std::string* _s = _internal_mutable_answer_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Answer.answer_id)
  return _s;
}
inline const std::string& Answer::_internal_answer_id() const {
  return _impl_.answer_id_.Get();
}
inline void Answer::_internal_set_answer_id(const std::string& value) {
  
  _impl_.answer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_answer_id() {
  
  return _impl_.answer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Answer::release_answer_id() {
  // @@protoc_insertion_point(field_release:gooseai.Answer.answer_id)
  return _impl_.answer_id_.Release();
}
inline void Answer::set_allocated_answer_id(std::string* answer_id) {
  if (answer_id != nullptr) {
    
  } else {
    
  }
  _impl_.answer_id_.SetAllocated(answer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.answer_id_.IsDefault()) {
    _impl_.answer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Answer.answer_id)
}

// string request_id = 2 [json_name = "requestId"];
inline void Answer::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Answer::request_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Answer.request_id)
}
inline std::string* Answer::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Answer.request_id)
  return _s;
}
inline const std::string& Answer::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void Answer::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Answer::release_request_id() {
  // @@protoc_insertion_point(field_release:gooseai.Answer.request_id)
  return _impl_.request_id_.Release();
}
inline void Answer::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Answer.request_id)
}

// uint64 received = 3 [json_name = "received"];
inline void Answer::clear_received() {
  _impl_.received_ = uint64_t{0u};
}
inline uint64_t Answer::_internal_received() const {
  return _impl_.received_;
}
inline uint64_t Answer::received() const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.received)
  return _internal_received();
}
inline void Answer::_internal_set_received(uint64_t value) {
  
  _impl_.received_ = value;
}
inline void Answer::set_received(uint64_t value) {
  _internal_set_received(value);
  // @@protoc_insertion_point(field_set:gooseai.Answer.received)
}

// uint64 created = 4 [json_name = "created"];
inline void Answer::clear_created() {
  _impl_.created_ = uint64_t{0u};
}
inline uint64_t Answer::_internal_created() const {
  return _impl_.created_;
}
inline uint64_t Answer::created() const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.created)
  return _internal_created();
}
inline void Answer::_internal_set_created(uint64_t value) {
  
  _impl_.created_ = value;
}
inline void Answer::set_created(uint64_t value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:gooseai.Answer.created)
}

// optional .gooseai.AnswerMeta meta = 6 [json_name = "meta"];
inline bool Answer::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool Answer::has_meta() const {
  return _internal_has_meta();
}
inline void Answer::clear_meta() {
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::AnswerMeta& Answer::_internal_meta() const {
  const ::gooseai::AnswerMeta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::AnswerMeta&>(
      ::gooseai::_AnswerMeta_default_instance_);
}
inline const ::gooseai::AnswerMeta& Answer::meta() const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.meta)
  return _internal_meta();
}
inline void Answer::unsafe_arena_set_allocated_meta(
    ::gooseai::AnswerMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Answer.meta)
}
inline ::gooseai::AnswerMeta* Answer::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::AnswerMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::AnswerMeta* Answer::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:gooseai.Answer.meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::AnswerMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::gooseai::AnswerMeta* Answer::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::AnswerMeta>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::gooseai::AnswerMeta* Answer::mutable_meta() {
  ::gooseai::AnswerMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:gooseai.Answer.meta)
  return _msg;
}
inline void Answer::set_allocated_meta(::gooseai::AnswerMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Answer.meta)
}

// repeated .gooseai.Artifact artifacts = 7 [json_name = "artifacts"];
inline int Answer::_internal_artifacts_size() const {
  return _impl_.artifacts_.size();
}
inline int Answer::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void Answer::clear_artifacts() {
  _impl_.artifacts_.Clear();
}
inline ::gooseai::Artifact* Answer::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Answer.artifacts)
  return _impl_.artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Artifact >*
Answer::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Answer.artifacts)
  return &_impl_.artifacts_;
}
inline const ::gooseai::Artifact& Answer::_internal_artifacts(int index) const {
  return _impl_.artifacts_.Get(index);
}
inline const ::gooseai::Artifact& Answer::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Answer.artifacts)
  return _internal_artifacts(index);
}
inline ::gooseai::Artifact* Answer::_internal_add_artifacts() {
  return _impl_.artifacts_.Add();
}
inline ::gooseai::Artifact* Answer::add_artifacts() {
  ::gooseai::Artifact* _add = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add:gooseai.Answer.artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Artifact >&
Answer::artifacts() const {
  // @@protoc_insertion_point(field_list:gooseai.Answer.artifacts)
  return _impl_.artifacts_;
}

// -------------------------------------------------------------------

// Request

// string engine_id = 1 [json_name = "engineId"];
inline void Request::clear_engine_id() {
  _impl_.engine_id_.ClearToEmpty();
}
inline const std::string& Request::engine_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.engine_id)
  return _internal_engine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_engine_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Request.engine_id)
}
inline std::string* Request::mutable_engine_id() {
  std::string* _s = _internal_mutable_engine_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.engine_id)
  return _s;
}
inline const std::string& Request::_internal_engine_id() const {
  return _impl_.engine_id_.Get();
}
inline void Request::_internal_set_engine_id(const std::string& value) {
  
  _impl_.engine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_engine_id() {
  
  return _impl_.engine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_engine_id() {
  // @@protoc_insertion_point(field_release:gooseai.Request.engine_id)
  return _impl_.engine_id_.Release();
}
inline void Request::set_allocated_engine_id(std::string* engine_id) {
  if (engine_id != nullptr) {
    
  } else {
    
  }
  _impl_.engine_id_.SetAllocated(engine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_id_.IsDefault()) {
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.engine_id)
}

// string request_id = 2 [json_name = "requestId"];
inline void Request::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Request::request_id() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Request.request_id)
}
inline std::string* Request::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.request_id)
  return _s;
}
inline const std::string& Request::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void Request::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_request_id() {
  // @@protoc_insertion_point(field_release:gooseai.Request.request_id)
  return _impl_.request_id_.Release();
}
inline void Request::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.request_id)
}

// .gooseai.ArtifactType requested_type = 3 [json_name = "requestedType"];
inline void Request::clear_requested_type() {
  _impl_.requested_type_ = 0;
}
inline ::gooseai::ArtifactType Request::_internal_requested_type() const {
  return static_cast< ::gooseai::ArtifactType >(_impl_.requested_type_);
}
inline ::gooseai::ArtifactType Request::requested_type() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.requested_type)
  return _internal_requested_type();
}
inline void Request::_internal_set_requested_type(::gooseai::ArtifactType value) {
  
  _impl_.requested_type_ = value;
}
inline void Request::set_requested_type(::gooseai::ArtifactType value) {
  _internal_set_requested_type(value);
  // @@protoc_insertion_point(field_set:gooseai.Request.requested_type)
}

// repeated .gooseai.Prompt prompt = 4 [json_name = "prompt"];
inline int Request::_internal_prompt_size() const {
  return _impl_.prompt_.size();
}
inline int Request::prompt_size() const {
  return _internal_prompt_size();
}
inline void Request::clear_prompt() {
  _impl_.prompt_.Clear();
}
inline ::gooseai::Prompt* Request::mutable_prompt(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Request.prompt)
  return _impl_.prompt_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Prompt >*
Request::mutable_prompt() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Request.prompt)
  return &_impl_.prompt_;
}
inline const ::gooseai::Prompt& Request::_internal_prompt(int index) const {
  return _impl_.prompt_.Get(index);
}
inline const ::gooseai::Prompt& Request::prompt(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Request.prompt)
  return _internal_prompt(index);
}
inline ::gooseai::Prompt* Request::_internal_add_prompt() {
  return _impl_.prompt_.Add();
}
inline ::gooseai::Prompt* Request::add_prompt() {
  ::gooseai::Prompt* _add = _internal_add_prompt();
  // @@protoc_insertion_point(field_add:gooseai.Request.prompt)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Prompt >&
Request::prompt() const {
  // @@protoc_insertion_point(field_list:gooseai.Request.prompt)
  return _impl_.prompt_;
}

// .gooseai.ImageParameters image = 5 [json_name = "image"];
inline bool Request::_internal_has_image() const {
  return params_case() == kImage;
}
inline bool Request::has_image() const {
  return _internal_has_image();
}
inline void Request::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void Request::clear_image() {
  if (_internal_has_image()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.params_.image_;
    }
    clear_has_params();
  }
}
inline ::gooseai::ImageParameters* Request::release_image() {
  // @@protoc_insertion_point(field_release:gooseai.Request.image)
  if (_internal_has_image()) {
    clear_has_params();
    ::gooseai::ImageParameters* temp = _impl_.params_.image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::ImageParameters& Request::_internal_image() const {
  return _internal_has_image()
      ? *_impl_.params_.image_
      : reinterpret_cast< ::gooseai::ImageParameters&>(::gooseai::_ImageParameters_default_instance_);
}
inline const ::gooseai::ImageParameters& Request::image() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.image)
  return _internal_image();
}
inline ::gooseai::ImageParameters* Request::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Request.image)
  if (_internal_has_image()) {
    clear_has_params();
    ::gooseai::ImageParameters* temp = _impl_.params_.image_;
    _impl_.params_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_image(::gooseai::ImageParameters* image) {
  clear_params();
  if (image) {
    set_has_image();
    _impl_.params_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Request.image)
}
inline ::gooseai::ImageParameters* Request::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_params();
    set_has_image();
    _impl_.params_.image_ = CreateMaybeMessage< ::gooseai::ImageParameters >(GetArenaForAllocation());
  }
  return _impl_.params_.image_;
}
inline ::gooseai::ImageParameters* Request::mutable_image() {
  ::gooseai::ImageParameters* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.image)
  return _msg;
}

// .gooseai.ClassifierParameters classifier = 7 [json_name = "classifier"];
inline bool Request::_internal_has_classifier() const {
  return params_case() == kClassifier;
}
inline bool Request::has_classifier() const {
  return _internal_has_classifier();
}
inline void Request::set_has_classifier() {
  _impl_._oneof_case_[0] = kClassifier;
}
inline void Request::clear_classifier() {
  if (_internal_has_classifier()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.params_.classifier_;
    }
    clear_has_params();
  }
}
inline ::gooseai::ClassifierParameters* Request::release_classifier() {
  // @@protoc_insertion_point(field_release:gooseai.Request.classifier)
  if (_internal_has_classifier()) {
    clear_has_params();
    ::gooseai::ClassifierParameters* temp = _impl_.params_.classifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.classifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::ClassifierParameters& Request::_internal_classifier() const {
  return _internal_has_classifier()
      ? *_impl_.params_.classifier_
      : reinterpret_cast< ::gooseai::ClassifierParameters&>(::gooseai::_ClassifierParameters_default_instance_);
}
inline const ::gooseai::ClassifierParameters& Request::classifier() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.classifier)
  return _internal_classifier();
}
inline ::gooseai::ClassifierParameters* Request::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Request.classifier)
  if (_internal_has_classifier()) {
    clear_has_params();
    ::gooseai::ClassifierParameters* temp = _impl_.params_.classifier_;
    _impl_.params_.classifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_classifier(::gooseai::ClassifierParameters* classifier) {
  clear_params();
  if (classifier) {
    set_has_classifier();
    _impl_.params_.classifier_ = classifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Request.classifier)
}
inline ::gooseai::ClassifierParameters* Request::_internal_mutable_classifier() {
  if (!_internal_has_classifier()) {
    clear_params();
    set_has_classifier();
    _impl_.params_.classifier_ = CreateMaybeMessage< ::gooseai::ClassifierParameters >(GetArenaForAllocation());
  }
  return _impl_.params_.classifier_;
}
inline ::gooseai::ClassifierParameters* Request::mutable_classifier() {
  ::gooseai::ClassifierParameters* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.classifier)
  return _msg;
}

// .gooseai.AssetParameters asset = 8 [json_name = "asset"];
inline bool Request::_internal_has_asset() const {
  return params_case() == kAsset;
}
inline bool Request::has_asset() const {
  return _internal_has_asset();
}
inline void Request::set_has_asset() {
  _impl_._oneof_case_[0] = kAsset;
}
inline void Request::clear_asset() {
  if (_internal_has_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.params_.asset_;
    }
    clear_has_params();
  }
}
inline ::gooseai::AssetParameters* Request::release_asset() {
  // @@protoc_insertion_point(field_release:gooseai.Request.asset)
  if (_internal_has_asset()) {
    clear_has_params();
    ::gooseai::AssetParameters* temp = _impl_.params_.asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.params_.asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gooseai::AssetParameters& Request::_internal_asset() const {
  return _internal_has_asset()
      ? *_impl_.params_.asset_
      : reinterpret_cast< ::gooseai::AssetParameters&>(::gooseai::_AssetParameters_default_instance_);
}
inline const ::gooseai::AssetParameters& Request::asset() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.asset)
  return _internal_asset();
}
inline ::gooseai::AssetParameters* Request::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gooseai.Request.asset)
  if (_internal_has_asset()) {
    clear_has_params();
    ::gooseai::AssetParameters* temp = _impl_.params_.asset_;
    _impl_.params_.asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_asset(::gooseai::AssetParameters* asset) {
  clear_params();
  if (asset) {
    set_has_asset();
    _impl_.params_.asset_ = asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Request.asset)
}
inline ::gooseai::AssetParameters* Request::_internal_mutable_asset() {
  if (!_internal_has_asset()) {
    clear_params();
    set_has_asset();
    _impl_.params_.asset_ = CreateMaybeMessage< ::gooseai::AssetParameters >(GetArenaForAllocation());
  }
  return _impl_.params_.asset_;
}
inline ::gooseai::AssetParameters* Request::mutable_asset() {
  ::gooseai::AssetParameters* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.asset)
  return _msg;
}

// optional .gooseai.ConditionerParameters conditioner = 6 [json_name = "conditioner"];
inline bool Request::_internal_has_conditioner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conditioner_ != nullptr);
  return value;
}
inline bool Request::has_conditioner() const {
  return _internal_has_conditioner();
}
inline void Request::clear_conditioner() {
  if (_impl_.conditioner_ != nullptr) _impl_.conditioner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gooseai::ConditionerParameters& Request::_internal_conditioner() const {
  const ::gooseai::ConditionerParameters* p = _impl_.conditioner_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::ConditionerParameters&>(
      ::gooseai::_ConditionerParameters_default_instance_);
}
inline const ::gooseai::ConditionerParameters& Request::conditioner() const {
  // @@protoc_insertion_point(field_get:gooseai.Request.conditioner)
  return _internal_conditioner();
}
inline void Request::unsafe_arena_set_allocated_conditioner(
    ::gooseai::ConditionerParameters* conditioner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditioner_);
  }
  _impl_.conditioner_ = conditioner;
  if (conditioner) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Request.conditioner)
}
inline ::gooseai::ConditionerParameters* Request::release_conditioner() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::ConditionerParameters* temp = _impl_.conditioner_;
  _impl_.conditioner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::ConditionerParameters* Request::unsafe_arena_release_conditioner() {
  // @@protoc_insertion_point(field_release:gooseai.Request.conditioner)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gooseai::ConditionerParameters* temp = _impl_.conditioner_;
  _impl_.conditioner_ = nullptr;
  return temp;
}
inline ::gooseai::ConditionerParameters* Request::_internal_mutable_conditioner() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.conditioner_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::ConditionerParameters>(GetArenaForAllocation());
    _impl_.conditioner_ = p;
  }
  return _impl_.conditioner_;
}
inline ::gooseai::ConditionerParameters* Request::mutable_conditioner() {
  ::gooseai::ConditionerParameters* _msg = _internal_mutable_conditioner();
  // @@protoc_insertion_point(field_mutable:gooseai.Request.conditioner)
  return _msg;
}
inline void Request::set_allocated_conditioner(::gooseai::ConditionerParameters* conditioner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conditioner_;
  }
  if (conditioner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditioner);
    if (message_arena != submessage_arena) {
      conditioner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditioner, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.conditioner_ = conditioner;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.conditioner)
}

inline bool Request::has_params() const {
  return params_case() != PARAMS_NOT_SET;
}
inline void Request::clear_has_params() {
  _impl_._oneof_case_[0] = PARAMS_NOT_SET;
}
inline Request::ParamsCase Request::params_case() const {
  return Request::ParamsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OnStatus

// repeated .gooseai.FinishReason reason = 1 [json_name = "reason"];
inline int OnStatus::_internal_reason_size() const {
  return _impl_.reason_.size();
}
inline int OnStatus::reason_size() const {
  return _internal_reason_size();
}
inline void OnStatus::clear_reason() {
  _impl_.reason_.Clear();
}
inline ::gooseai::FinishReason OnStatus::_internal_reason(int index) const {
  return static_cast< ::gooseai::FinishReason >(_impl_.reason_.Get(index));
}
inline ::gooseai::FinishReason OnStatus::reason(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.OnStatus.reason)
  return _internal_reason(index);
}
inline void OnStatus::set_reason(int index, ::gooseai::FinishReason value) {
  _impl_.reason_.Set(index, value);
  // @@protoc_insertion_point(field_set:gooseai.OnStatus.reason)
}
inline void OnStatus::_internal_add_reason(::gooseai::FinishReason value) {
  _impl_.reason_.Add(value);
}
inline void OnStatus::add_reason(::gooseai::FinishReason value) {
  _internal_add_reason(value);
  // @@protoc_insertion_point(field_add:gooseai.OnStatus.reason)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
OnStatus::reason() const {
  // @@protoc_insertion_point(field_list:gooseai.OnStatus.reason)
  return _impl_.reason_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OnStatus::_internal_mutable_reason() {
  return &_impl_.reason_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OnStatus::mutable_reason() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.OnStatus.reason)
  return _internal_mutable_reason();
}

// optional string target = 2 [json_name = "target"];
inline bool OnStatus::_internal_has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnStatus::has_target() const {
  return _internal_has_target();
}
inline void OnStatus::clear_target() {
  _impl_.target_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnStatus::target() const {
  // @@protoc_insertion_point(field_get:gooseai.OnStatus.target)
  return _internal_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnStatus::set_target(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.OnStatus.target)
}
inline std::string* OnStatus::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:gooseai.OnStatus.target)
  return _s;
}
inline const std::string& OnStatus::_internal_target() const {
  return _impl_.target_.Get();
}
inline void OnStatus::_internal_set_target(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_.Set(value, GetArenaForAllocation());
}
inline std::string* OnStatus::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_.Mutable(GetArenaForAllocation());
}
inline std::string* OnStatus::release_target() {
  // @@protoc_insertion_point(field_release:gooseai.OnStatus.target)
  if (!_internal_has_target()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnStatus::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_.SetAllocated(target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.OnStatus.target)
}

// repeated .gooseai.StageAction action = 3 [json_name = "action"];
inline int OnStatus::_internal_action_size() const {
  return _impl_.action_.size();
}
inline int OnStatus::action_size() const {
  return _internal_action_size();
}
inline void OnStatus::clear_action() {
  _impl_.action_.Clear();
}
inline ::gooseai::StageAction OnStatus::_internal_action(int index) const {
  return static_cast< ::gooseai::StageAction >(_impl_.action_.Get(index));
}
inline ::gooseai::StageAction OnStatus::action(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.OnStatus.action)
  return _internal_action(index);
}
inline void OnStatus::set_action(int index, ::gooseai::StageAction value) {
  _impl_.action_.Set(index, value);
  // @@protoc_insertion_point(field_set:gooseai.OnStatus.action)
}
inline void OnStatus::_internal_add_action(::gooseai::StageAction value) {
  _impl_.action_.Add(value);
}
inline void OnStatus::add_action(::gooseai::StageAction value) {
  _internal_add_action(value);
  // @@protoc_insertion_point(field_add:gooseai.OnStatus.action)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
OnStatus::action() const {
  // @@protoc_insertion_point(field_list:gooseai.OnStatus.action)
  return _impl_.action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OnStatus::_internal_mutable_action() {
  return &_impl_.action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
OnStatus::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.OnStatus.action)
  return _internal_mutable_action();
}

// -------------------------------------------------------------------

// Stage

// string id = 1 [json_name = "id"];
inline void Stage::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Stage::id() const {
  // @@protoc_insertion_point(field_get:gooseai.Stage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stage::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.Stage.id)
}
inline std::string* Stage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gooseai.Stage.id)
  return _s;
}
inline const std::string& Stage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Stage::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Stage::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Stage::release_id() {
  // @@protoc_insertion_point(field_release:gooseai.Stage.id)
  return _impl_.id_.Release();
}
inline void Stage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.Stage.id)
}

// .gooseai.Request request = 2 [json_name = "request"];
inline bool Stage::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool Stage::has_request() const {
  return _internal_has_request();
}
inline void Stage::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::gooseai::Request& Stage::_internal_request() const {
  const ::gooseai::Request* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::gooseai::Request&>(
      ::gooseai::_Request_default_instance_);
}
inline const ::gooseai::Request& Stage::request() const {
  // @@protoc_insertion_point(field_get:gooseai.Stage.request)
  return _internal_request();
}
inline void Stage::unsafe_arena_set_allocated_request(
    ::gooseai::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gooseai.Stage.request)
}
inline ::gooseai::Request* Stage::release_request() {
  
  ::gooseai::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gooseai::Request* Stage::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:gooseai.Stage.request)
  
  ::gooseai::Request* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::gooseai::Request* Stage::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::gooseai::Request>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::gooseai::Request* Stage::mutable_request() {
  ::gooseai::Request* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:gooseai.Stage.request)
  return _msg;
}
inline void Stage::set_allocated_request(::gooseai::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:gooseai.Stage.request)
}

// repeated .gooseai.OnStatus on_status = 3 [json_name = "onStatus"];
inline int Stage::_internal_on_status_size() const {
  return _impl_.on_status_.size();
}
inline int Stage::on_status_size() const {
  return _internal_on_status_size();
}
inline void Stage::clear_on_status() {
  _impl_.on_status_.Clear();
}
inline ::gooseai::OnStatus* Stage::mutable_on_status(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.Stage.on_status)
  return _impl_.on_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OnStatus >*
Stage::mutable_on_status() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.Stage.on_status)
  return &_impl_.on_status_;
}
inline const ::gooseai::OnStatus& Stage::_internal_on_status(int index) const {
  return _impl_.on_status_.Get(index);
}
inline const ::gooseai::OnStatus& Stage::on_status(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.Stage.on_status)
  return _internal_on_status(index);
}
inline ::gooseai::OnStatus* Stage::_internal_add_on_status() {
  return _impl_.on_status_.Add();
}
inline ::gooseai::OnStatus* Stage::add_on_status() {
  ::gooseai::OnStatus* _add = _internal_add_on_status();
  // @@protoc_insertion_point(field_add:gooseai.Stage.on_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::OnStatus >&
Stage::on_status() const {
  // @@protoc_insertion_point(field_list:gooseai.Stage.on_status)
  return _impl_.on_status_;
}

// -------------------------------------------------------------------

// ChainRequest

// string request_id = 1 [json_name = "requestId"];
inline void ChainRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ChainRequest::request_id() const {
  // @@protoc_insertion_point(field_get:gooseai.ChainRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChainRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gooseai.ChainRequest.request_id)
}
inline std::string* ChainRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:gooseai.ChainRequest.request_id)
  return _s;
}
inline const std::string& ChainRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ChainRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChainRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChainRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:gooseai.ChainRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void ChainRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gooseai.ChainRequest.request_id)
}

// repeated .gooseai.Stage stage = 2 [json_name = "stage"];
inline int ChainRequest::_internal_stage_size() const {
  return _impl_.stage_.size();
}
inline int ChainRequest::stage_size() const {
  return _internal_stage_size();
}
inline void ChainRequest::clear_stage() {
  _impl_.stage_.Clear();
}
inline ::gooseai::Stage* ChainRequest::mutable_stage(int index) {
  // @@protoc_insertion_point(field_mutable:gooseai.ChainRequest.stage)
  return _impl_.stage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Stage >*
ChainRequest::mutable_stage() {
  // @@protoc_insertion_point(field_mutable_list:gooseai.ChainRequest.stage)
  return &_impl_.stage_;
}
inline const ::gooseai::Stage& ChainRequest::_internal_stage(int index) const {
  return _impl_.stage_.Get(index);
}
inline const ::gooseai::Stage& ChainRequest::stage(int index) const {
  // @@protoc_insertion_point(field_get:gooseai.ChainRequest.stage)
  return _internal_stage(index);
}
inline ::gooseai::Stage* ChainRequest::_internal_add_stage() {
  return _impl_.stage_.Add();
}
inline ::gooseai::Stage* ChainRequest::add_stage() {
  ::gooseai::Stage* _add = _internal_add_stage();
  // @@protoc_insertion_point(field_add:gooseai.ChainRequest.stage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gooseai::Stage >&
ChainRequest::stage() const {
  // @@protoc_insertion_point(field_list:gooseai.ChainRequest.stage)
  return _impl_.stage_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gooseai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gooseai::FinishReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::FinishReason>() {
  return ::gooseai::FinishReason_descriptor();
}
template <> struct is_proto_enum< ::gooseai::ArtifactType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::ArtifactType>() {
  return ::gooseai::ArtifactType_descriptor();
}
template <> struct is_proto_enum< ::gooseai::MaskedAreaInit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::MaskedAreaInit>() {
  return ::gooseai::MaskedAreaInit_descriptor();
}
template <> struct is_proto_enum< ::gooseai::WeightMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::WeightMethod>() {
  return ::gooseai::WeightMethod_descriptor();
}
template <> struct is_proto_enum< ::gooseai::DiffusionSampler> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::DiffusionSampler>() {
  return ::gooseai::DiffusionSampler_descriptor();
}
template <> struct is_proto_enum< ::gooseai::Upscaler> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::Upscaler>() {
  return ::gooseai::Upscaler_descriptor();
}
template <> struct is_proto_enum< ::gooseai::GuidancePreset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::GuidancePreset>() {
  return ::gooseai::GuidancePreset_descriptor();
}
template <> struct is_proto_enum< ::gooseai::ModelArchitecture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::ModelArchitecture>() {
  return ::gooseai::ModelArchitecture_descriptor();
}
template <> struct is_proto_enum< ::gooseai::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::Action>() {
  return ::gooseai::Action_descriptor();
}
template <> struct is_proto_enum< ::gooseai::ClassifierMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::ClassifierMode>() {
  return ::gooseai::ClassifierMode_descriptor();
}
template <> struct is_proto_enum< ::gooseai::AssetAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::AssetAction>() {
  return ::gooseai::AssetAction_descriptor();
}
template <> struct is_proto_enum< ::gooseai::AssetUse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::AssetUse>() {
  return ::gooseai::AssetUse_descriptor();
}
template <> struct is_proto_enum< ::gooseai::StageAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gooseai::StageAction>() {
  return ::gooseai::StageAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_generation_2eproto
