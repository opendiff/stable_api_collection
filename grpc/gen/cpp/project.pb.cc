// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: project.proto

#include "project.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace gooseai {
PROTOBUF_CONSTEXPR ProjectAsset::ProjectAsset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_)*/nullptr
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.created_at_)*/uint64_t{0u}
  , /*decltype(_impl_.updated_at_)*/uint64_t{0u}
  , /*decltype(_impl_.use_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProjectAssetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProjectAssetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProjectAssetDefaultTypeInternal() {}
  union {
    ProjectAsset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProjectAssetDefaultTypeInternal _ProjectAsset_default_instance_;
PROTOBUF_CONSTEXPR Project::Project(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.assets_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_)*/nullptr
  , /*decltype(_impl_.access_)*/0
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.created_at_)*/uint64_t{0u}
  , /*decltype(_impl_.updated_at_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProjectDefaultTypeInternal() {}
  union {
    Project _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProjectDefaultTypeInternal _Project_default_instance_;
PROTOBUF_CONSTEXPR CreateProjectRequest::CreateProjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_)*/nullptr
  , /*decltype(_impl_.access_)*/0
  , /*decltype(_impl_.status_)*/0} {}
struct CreateProjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateProjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateProjectRequestDefaultTypeInternal() {}
  union {
    CreateProjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateProjectRequestDefaultTypeInternal _CreateProjectRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateProjectRequest::UpdateProjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_)*/nullptr
  , /*decltype(_impl_.access_)*/0
  , /*decltype(_impl_.status_)*/0} {}
struct UpdateProjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateProjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateProjectRequestDefaultTypeInternal() {}
  union {
    UpdateProjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateProjectRequestDefaultTypeInternal _UpdateProjectRequest_default_instance_;
PROTOBUF_CONSTEXPR ListProjectRequest::ListProjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ListProjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListProjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListProjectRequestDefaultTypeInternal() {}
  union {
    ListProjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListProjectRequestDefaultTypeInternal _ListProjectRequest_default_instance_;
PROTOBUF_CONSTEXPR GetProjectRequest::GetProjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GetProjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetProjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetProjectRequestDefaultTypeInternal() {}
  union {
    GetProjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetProjectRequestDefaultTypeInternal _GetProjectRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteProjectRequest::DeleteProjectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeleteProjectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteProjectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteProjectRequestDefaultTypeInternal() {}
  union {
    DeleteProjectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteProjectRequestDefaultTypeInternal _DeleteProjectRequest_default_instance_;
PROTOBUF_CONSTEXPR QueryAssetsRequest::QueryAssetsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.use_)*/{}
  , /*decltype(_impl_._use_cached_byte_size_)*/{0}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.since_)*/uint64_t{0u}
  , /*decltype(_impl_.until_)*/uint64_t{0u}
  , /*decltype(_impl_.limit_)*/uint64_t{0u}
  , /*decltype(_impl_.sort_dir_)*/0} {}
struct QueryAssetsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryAssetsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryAssetsRequestDefaultTypeInternal() {}
  union {
    QueryAssetsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryAssetsRequestDefaultTypeInternal _QueryAssetsRequest_default_instance_;
PROTOBUF_CONSTEXPR QueryAssetsResponse::QueryAssetsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.assets_)*/{}
  , /*decltype(_impl_.last_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct QueryAssetsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryAssetsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryAssetsResponseDefaultTypeInternal() {}
  union {
    QueryAssetsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryAssetsResponseDefaultTypeInternal _QueryAssetsResponse_default_instance_;
}  // namespace gooseai
static ::_pb::Metadata file_level_metadata_project_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_project_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_project_2eproto = nullptr;

const uint32_t TableStruct_project_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.uri_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.use_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.updated_at_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ProjectAsset, _impl_.request_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.access_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.file_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.updated_at_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Project, _impl_.assets_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_.access_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CreateProjectRequest, _impl_.file_),
  ~0u,
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.access_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::gooseai::UpdateProjectRequest, _impl_.file_),
  ~0u,
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::gooseai::ListProjectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ListProjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ListProjectRequest, _impl_.owner_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::GetProjectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GetProjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::GetProjectRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GetProjectRequest, _impl_.owner_id_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::DeleteProjectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::DeleteProjectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::DeleteProjectRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::DeleteProjectRequest, _impl_.owner_id_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.since_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.until_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.limit_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.start_key_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.use_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsRequest, _impl_.sort_dir_),
  ~0u,
  0,
  2,
  3,
  4,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsResponse, _impl_.assets_),
  PROTOBUF_FIELD_OFFSET(::gooseai::QueryAssetsResponse, _impl_.last_key_),
  ~0u,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::gooseai::ProjectAsset)},
  { 14, -1, -1, sizeof(::gooseai::Project)},
  { 30, 41, -1, sizeof(::gooseai::CreateProjectRequest)},
  { 46, 58, -1, sizeof(::gooseai::UpdateProjectRequest)},
  { 64, 71, -1, sizeof(::gooseai::ListProjectRequest)},
  { 72, 80, -1, sizeof(::gooseai::GetProjectRequest)},
  { 82, 90, -1, sizeof(::gooseai::DeleteProjectRequest)},
  { 92, 106, -1, sizeof(::gooseai::QueryAssetsRequest)},
  { 114, 122, -1, sizeof(::gooseai::QueryAssetsResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::gooseai::_ProjectAsset_default_instance_._instance,
  &::gooseai::_Project_default_instance_._instance,
  &::gooseai::_CreateProjectRequest_default_instance_._instance,
  &::gooseai::_UpdateProjectRequest_default_instance_._instance,
  &::gooseai::_ListProjectRequest_default_instance_._instance,
  &::gooseai::_GetProjectRequest_default_instance_._instance,
  &::gooseai::_DeleteProjectRequest_default_instance_._instance,
  &::gooseai::_QueryAssetsRequest_default_instance_._instance,
  &::gooseai::_QueryAssetsResponse_default_instance_._instance,
};

const char descriptor_table_protodef_project_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rproject.proto\022\007gooseai\032\020generation.pro"
  "to\"\356\001\n\014ProjectAsset\022\016\n\002id\030\001 \001(\tR\002id\022\020\n\003u"
  "ri\030\002 \001(\tR\003uri\022*\n\003use\030\003 \001(\0162\030.gooseai.Pro"
  "jectAssetUseR\003use\022\022\n\004name\030\004 \001(\tR\004name\022\022\n"
  "\004size\030\005 \001(\004R\004size\022\035\n\ncreated_at\030\006 \001(\004R\tc"
  "reatedAt\022\035\n\nupdated_at\030\007 \001(\004R\tupdatedAt\022"
  "*\n\007request\030\010 \001(\0132\020.gooseai.RequestR\007requ"
  "est\"\326\002\n\007Project\022\016\n\002id\030\001 \001(\tR\002id\022\024\n\005title"
  "\030\002 \001(\tR\005title\022\031\n\010owner_id\030\003 \001(\tR\007ownerId"
  "\022.\n\006access\030\004 \001(\0162\026.gooseai.ProjectAccess"
  "R\006access\022.\n\006status\030\005 \001(\0162\026.gooseai.Proje"
  "ctStatusR\006status\022\022\n\004size\030\006 \001(\004R\004size\022)\n\004"
  "file\030\007 \001(\0132\025.gooseai.ProjectAssetR\004file\022"
  "\035\n\ncreated_at\030\010 \001(\004R\tcreatedAt\022\035\n\nupdate"
  "d_at\030\t \001(\004R\tupdatedAt\022-\n\006assets\030\n \003(\0132\025."
  "gooseai.ProjectAssetR\006assets\"\362\001\n\024CreateP"
  "rojectRequest\022\024\n\005title\030\001 \001(\tR\005title\022\036\n\010o"
  "wner_id\030\002 \001(\tH\000R\007ownerId\210\001\001\022.\n\006access\030\003 "
  "\001(\0162\026.gooseai.ProjectAccessR\006access\022.\n\006s"
  "tatus\030\004 \001(\0162\026.gooseai.ProjectStatusR\006sta"
  "tus\022.\n\004file\030\005 \001(\0132\025.gooseai.ProjectAsset"
  "H\001R\004file\210\001\001B\013\n\t_owner_idB\007\n\005_file\"\261\002\n\024Up"
  "dateProjectRequest\022\016\n\002id\030\001 \001(\tR\002id\022\036\n\010ow"
  "ner_id\030\002 \001(\tH\000R\007ownerId\210\001\001\022\031\n\005title\030\003 \001("
  "\tH\001R\005title\210\001\001\0223\n\006access\030\004 \001(\0162\026.gooseai."
  "ProjectAccessH\002R\006access\210\001\001\0223\n\006status\030\005 \001"
  "(\0162\026.gooseai.ProjectStatusH\003R\006status\210\001\001\022"
  ".\n\004file\030\006 \001(\0132\025.gooseai.ProjectAssetH\004R\004"
  "file\210\001\001B\013\n\t_owner_idB\010\n\006_titleB\t\n\007_acces"
  "sB\t\n\007_statusB\007\n\005_file\"A\n\022ListProjectRequ"
  "est\022\036\n\010owner_id\030\001 \001(\tH\000R\007ownerId\210\001\001B\013\n\t_"
  "owner_id\"P\n\021GetProjectRequest\022\016\n\002id\030\001 \001("
  "\tR\002id\022\036\n\010owner_id\030\002 \001(\tH\000R\007ownerId\210\001\001B\013\n"
  "\t_owner_id\"S\n\024DeleteProjectRequest\022\016\n\002id"
  "\030\001 \001(\tR\002id\022\036\n\010owner_id\030\002 \001(\tH\000R\007ownerId\210"
  "\001\001B\013\n\t_owner_id\"\320\002\n\022QueryAssetsRequest\022\016"
  "\n\002id\030\001 \001(\tR\002id\022\036\n\010owner_id\030\002 \001(\tH\000R\007owne"
  "rId\210\001\001\022\031\n\005since\030\003 \001(\004H\001R\005since\210\001\001\022\031\n\005unt"
  "il\030\004 \001(\004H\002R\005until\210\001\001\022\031\n\005limit\030\005 \001(\004H\003R\005l"
  "imit\210\001\001\022 \n\tstart_key\030\006 \001(\tH\004R\010startKey\210\001"
  "\001\022*\n\003use\030\007 \003(\0162\030.gooseai.ProjectAssetUse"
  "R\003use\0222\n\010sort_dir\030\010 \001(\0162\027.gooseai.Projec"
  "tSortDirR\007sortDirB\013\n\t_owner_idB\010\n\006_since"
  "B\010\n\006_untilB\010\n\006_limitB\014\n\n_start_key\"q\n\023Qu"
  "eryAssetsResponse\022-\n\006assets\030\001 \003(\0132\025.goos"
  "eai.ProjectAssetR\006assets\022\036\n\010last_key\030\002 \001"
  "(\tH\000R\007lastKey\210\001\001B\013\n\t_last_key*F\n\rProject"
  "Access\022\032\n\026PROJECT_ACCESS_PRIVATE\020\000\022\031\n\025PR"
  "OJECT_ACCESS_PUBLIC\020\001*c\n\rProjectStatus\022\033"
  "\n\027PROJECT_STATUS_INACTIVE\020\000\022\031\n\025PROJECT_S"
  "TATUS_ACTIVE\020\001\022\032\n\026PROJECT_STATUS_DELETED"
  "\020\002*\260\001\n\017ProjectAssetUse\022\037\n\033PROJECT_ASSET_"
  "USE_UNDEFINED\020\000\022\033\n\027PROJECT_ASSET_USE_INP"
  "UT\020\001\022\034\n\030PROJECT_ASSET_USE_OUTPUT\020\002\022\"\n\036PR"
  "OJECT_ASSET_USE_INTERMEDIATE\020\003\022\035\n\031PROJEC"
  "T_ASSET_USE_PROJECT\020\004*g\n\016ProjectSortDir\022"
  " \n\034PROJECT_SORT_DIR_UNSPECIFIED\020\000\022\030\n\024PRO"
  "JECT_SORT_DIR_ASC\020\001\022\031\n\025PROJECT_SORT_DIR_"
  "DESC\020\0022\205\003\n\016ProjectService\022;\n\006Create\022\035.go"
  "oseai.CreateProjectRequest\032\020.gooseai.Pro"
  "ject\"\000\022;\n\006Update\022\035.gooseai.UpdateProject"
  "Request\032\020.gooseai.Project\"\000\0229\n\004List\022\033.go"
  "oseai.ListProjectRequest\032\020.gooseai.Proje"
  "ct\"\0000\001\0225\n\003Get\022\032.gooseai.GetProjectReques"
  "t\032\020.gooseai.Project\"\000\022;\n\006Delete\022\035.goosea"
  "i.DeleteProjectRequest\032\020.gooseai.Project"
  "\"\000\022J\n\013QueryAssets\022\033.gooseai.QueryAssetsR"
  "equest\032\034.gooseai.QueryAssetsResponse\"\000B8"
  "Z6github.com/stability-ai/api-interfaces"
  "/gooseai/projectb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_project_2eproto_deps[1] = {
  &::descriptor_table_generation_2eproto,
};
static ::_pbi::once_flag descriptor_table_project_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_project_2eproto = {
    false, false, 2784, descriptor_table_protodef_project_2eproto,
    "project.proto",
    &descriptor_table_project_2eproto_once, descriptor_table_project_2eproto_deps, 1, 9,
    schemas, file_default_instances, TableStruct_project_2eproto::offsets,
    file_level_metadata_project_2eproto, file_level_enum_descriptors_project_2eproto,
    file_level_service_descriptors_project_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_project_2eproto_getter() {
  return &descriptor_table_project_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_project_2eproto(&descriptor_table_project_2eproto);
namespace gooseai {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectAccess_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_project_2eproto);
  return file_level_enum_descriptors_project_2eproto[0];
}
bool ProjectAccess_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_project_2eproto);
  return file_level_enum_descriptors_project_2eproto[1];
}
bool ProjectStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectAssetUse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_project_2eproto);
  return file_level_enum_descriptors_project_2eproto[2];
}
bool ProjectAssetUse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectSortDir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_project_2eproto);
  return file_level_enum_descriptors_project_2eproto[3];
}
bool ProjectSortDir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ProjectAsset::_Internal {
 public:
  static const ::gooseai::Request& request(const ProjectAsset* msg);
};

const ::gooseai::Request&
ProjectAsset::_Internal::request(const ProjectAsset* msg) {
  return *msg->_impl_.request_;
}
void ProjectAsset::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
ProjectAsset::ProjectAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ProjectAsset)
}
ProjectAsset::ProjectAsset(const ProjectAsset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProjectAsset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.size_){}
    , decltype(_impl_.created_at_){}
    , decltype(_impl_.updated_at_){}
    , decltype(_impl_.use_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uri().empty()) {
    _this->_impl_.uri_.Set(from._internal_uri(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_request()) {
    _this->_impl_.request_ = new ::gooseai::Request(*from._impl_.request_);
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.use_));
  // @@protoc_insertion_point(copy_constructor:gooseai.ProjectAsset)
}

inline void ProjectAsset::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.created_at_){uint64_t{0u}}
    , decltype(_impl_.updated_at_){uint64_t{0u}}
    , decltype(_impl_.use_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProjectAsset::~ProjectAsset() {
  // @@protoc_insertion_point(destructor:gooseai.ProjectAsset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProjectAsset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.uri_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.request_;
}

void ProjectAsset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProjectAsset::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ProjectAsset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.uri_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
  ::memset(&_impl_.size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.use_) -
      reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.use_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProjectAsset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ProjectAsset.id"));
        } else
          goto handle_unusual;
        continue;
      // string uri = 2 [json_name = "uri"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uri();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ProjectAsset.uri"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectAssetUse use = 3 [json_name = "use"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::gooseai::ProjectAssetUse>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 4 [json_name = "name"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ProjectAsset.name"));
        } else
          goto handle_unusual;
        continue;
      // uint64 size = 5 [json_name = "size"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 created_at = 6 [json_name = "createdAt"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.created_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 updated_at = 7 [json_name = "updatedAt"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Request request = 8 [json_name = "request"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProjectAsset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ProjectAsset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ProjectAsset.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string uri = 2 [json_name = "uri"];
  if (!this->_internal_uri().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uri().data(), static_cast<int>(this->_internal_uri().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ProjectAsset.uri");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uri(), target);
  }

  // .gooseai.ProjectAssetUse use = 3 [json_name = "use"];
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_use(), target);
  }

  // string name = 4 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ProjectAsset.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // uint64 size = 5 [json_name = "size"];
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_size(), target);
  }

  // uint64 created_at = 6 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_created_at(), target);
  }

  // uint64 updated_at = 7 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_updated_at(), target);
  }

  // .gooseai.Request request = 8 [json_name = "request"];
  if (this->_internal_has_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::request(this),
        _Internal::request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ProjectAsset)
  return target;
}

size_t ProjectAsset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ProjectAsset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string uri = 2 [json_name = "uri"];
  if (!this->_internal_uri().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uri());
  }

  // string name = 4 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .gooseai.Request request = 8 [json_name = "request"];
  if (this->_internal_has_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.request_);
  }

  // uint64 size = 5 [json_name = "size"];
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  // uint64 created_at = 6 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_created_at());
  }

  // uint64 updated_at = 7 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_updated_at());
  }

  // .gooseai.ProjectAssetUse use = 3 [json_name = "use"];
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProjectAsset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProjectAsset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProjectAsset::GetClassData() const { return &_class_data_; }


void ProjectAsset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProjectAsset*>(&to_msg);
  auto& from = static_cast<const ProjectAsset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ProjectAsset)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_uri().empty()) {
    _this->_internal_set_uri(from._internal_uri());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_request()) {
    _this->_internal_mutable_request()->::gooseai::Request::MergeFrom(
        from._internal_request());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_created_at() != 0) {
    _this->_internal_set_created_at(from._internal_created_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProjectAsset::CopyFrom(const ProjectAsset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ProjectAsset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProjectAsset::IsInitialized() const {
  return true;
}

void ProjectAsset::InternalSwap(ProjectAsset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uri_, lhs_arena,
      &other->_impl_.uri_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProjectAsset, _impl_.use_)
      + sizeof(ProjectAsset::_impl_.use_)
      - PROTOBUF_FIELD_OFFSET(ProjectAsset, _impl_.request_)>(
          reinterpret_cast<char*>(&_impl_.request_),
          reinterpret_cast<char*>(&other->_impl_.request_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProjectAsset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[0]);
}

// ===================================================================

class Project::_Internal {
 public:
  static const ::gooseai::ProjectAsset& file(const Project* msg);
};

const ::gooseai::ProjectAsset&
Project::_Internal::file(const Project* msg) {
  return *msg->_impl_.file_;
}
Project::Project(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Project)
}
Project::Project(const Project& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Project* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.assets_){from._impl_.assets_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.created_at_){}
    , decltype(_impl_.updated_at_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_owner_id().empty()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_file()) {
    _this->_impl_.file_ = new ::gooseai::ProjectAsset(*from._impl_.file_);
  }
  ::memcpy(&_impl_.access_, &from._impl_.access_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.updated_at_) -
    reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.updated_at_));
  // @@protoc_insertion_point(copy_constructor:gooseai.Project)
}

inline void Project::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.assets_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){0}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.created_at_){uint64_t{0u}}
    , decltype(_impl_.updated_at_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Project::~Project() {
  // @@protoc_insertion_point(destructor:gooseai.Project)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Project::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assets_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.title_.Destroy();
  _impl_.owner_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.file_;
}

void Project::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Project::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Project)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assets_.Clear();
  _impl_.id_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.owner_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.file_ != nullptr) {
    delete _impl_.file_;
  }
  _impl_.file_ = nullptr;
  ::memset(&_impl_.access_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.updated_at_) -
      reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.updated_at_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Project::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Project.id"));
        } else
          goto handle_unusual;
        continue;
      // string title = 2 [json_name = "title"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Project.title"));
        } else
          goto handle_unusual;
        continue;
      // string owner_id = 3 [json_name = "ownerId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Project.owner_id"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectAccess access = 4 [json_name = "access"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_access(static_cast<::gooseai::ProjectAccess>(val));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectStatus status = 5 [json_name = "status"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::gooseai::ProjectStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 size = 6 [json_name = "size"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectAsset file = 7 [json_name = "file"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 created_at = 8 [json_name = "createdAt"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.created_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 updated_at = 9 [json_name = "updatedAt"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.ProjectAsset assets = 10 [json_name = "assets"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Project::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Project)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Project.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string title = 2 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Project.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // string owner_id = 3 [json_name = "ownerId"];
  if (!this->_internal_owner_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Project.owner_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_owner_id(), target);
  }

  // .gooseai.ProjectAccess access = 4 [json_name = "access"];
  if (this->_internal_access() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_access(), target);
  }

  // .gooseai.ProjectStatus status = 5 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_status(), target);
  }

  // uint64 size = 6 [json_name = "size"];
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_size(), target);
  }

  // .gooseai.ProjectAsset file = 7 [json_name = "file"];
  if (this->_internal_has_file()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::file(this),
        _Internal::file(this).GetCachedSize(), target, stream);
  }

  // uint64 created_at = 8 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_created_at(), target);
  }

  // uint64 updated_at = 9 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_updated_at(), target);
  }

  // repeated .gooseai.ProjectAsset assets = 10 [json_name = "assets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assets_size()); i < n; i++) {
    const auto& repfield = this->_internal_assets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Project)
  return target;
}

size_t Project::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Project)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.ProjectAsset assets = 10 [json_name = "assets"];
  total_size += 1UL * this->_internal_assets_size();
  for (const auto& msg : this->_impl_.assets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string title = 2 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string owner_id = 3 [json_name = "ownerId"];
  if (!this->_internal_owner_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner_id());
  }

  // .gooseai.ProjectAsset file = 7 [json_name = "file"];
  if (this->_internal_has_file()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.file_);
  }

  // .gooseai.ProjectAccess access = 4 [json_name = "access"];
  if (this->_internal_access() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_access());
  }

  // .gooseai.ProjectStatus status = 5 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // uint64 size = 6 [json_name = "size"];
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  // uint64 created_at = 8 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_created_at());
  }

  // uint64 updated_at = 9 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_updated_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Project::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Project::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Project::GetClassData() const { return &_class_data_; }


void Project::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Project*>(&to_msg);
  auto& from = static_cast<const Project&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Project)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assets_.MergeFrom(from._impl_.assets_);
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_owner_id().empty()) {
    _this->_internal_set_owner_id(from._internal_owner_id());
  }
  if (from._internal_has_file()) {
    _this->_internal_mutable_file()->::gooseai::ProjectAsset::MergeFrom(
        from._internal_file());
  }
  if (from._internal_access() != 0) {
    _this->_internal_set_access(from._internal_access());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_created_at() != 0) {
    _this->_internal_set_created_at(from._internal_created_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Project::CopyFrom(const Project& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Project)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Project::IsInitialized() const {
  return true;
}

void Project::InternalSwap(Project* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.assets_.InternalSwap(&other->_impl_.assets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Project, _impl_.updated_at_)
      + sizeof(Project::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(Project, _impl_.file_)>(
          reinterpret_cast<char*>(&_impl_.file_),
          reinterpret_cast<char*>(&other->_impl_.file_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Project::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[1]);
}

// ===================================================================

class CreateProjectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateProjectRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::ProjectAsset& file(const CreateProjectRequest* msg);
  static void set_has_file(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gooseai::ProjectAsset&
CreateProjectRequest::_Internal::file(const CreateProjectRequest* msg) {
  return *msg->_impl_.file_;
}
CreateProjectRequest::CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.CreateProjectRequest)
}
CreateProjectRequest::CreateProjectRequest(const CreateProjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateProjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_file()) {
    _this->_impl_.file_ = new ::gooseai::ProjectAsset(*from._impl_.file_);
  }
  ::memcpy(&_impl_.access_, &from._impl_.access_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:gooseai.CreateProjectRequest)
}

inline void CreateProjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){0}
    , decltype(_impl_.status_){0}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateProjectRequest::~CreateProjectRequest() {
  // @@protoc_insertion_point(destructor:gooseai.CreateProjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateProjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.owner_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.file_;
}

void CreateProjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateProjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.CreateProjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.title_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.owner_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.file_ != nullptr);
      _impl_.file_->Clear();
    }
  }
  ::memset(&_impl_.access_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.status_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateProjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1 [json_name = "title"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.CreateProjectRequest.title"));
        } else
          goto handle_unusual;
        continue;
      // optional string owner_id = 2 [json_name = "ownerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.CreateProjectRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectAccess access = 3 [json_name = "access"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_access(static_cast<::gooseai::ProjectAccess>(val));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectStatus status = 4 [json_name = "status"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::gooseai::ProjectStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ProjectAsset file = 5 [json_name = "file"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateProjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.CreateProjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.CreateProjectRequest.title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.CreateProjectRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner_id(), target);
  }

  // .gooseai.ProjectAccess access = 3 [json_name = "access"];
  if (this->_internal_access() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_access(), target);
  }

  // .gooseai.ProjectStatus status = 4 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // optional .gooseai.ProjectAsset file = 5 [json_name = "file"];
  if (_internal_has_file()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::file(this),
        _Internal::file(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.CreateProjectRequest)
  return target;
}

size_t CreateProjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.CreateProjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string title = 1 [json_name = "title"];
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string owner_id = 2 [json_name = "ownerId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_owner_id());
    }

    // optional .gooseai.ProjectAsset file = 5 [json_name = "file"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.file_);
    }

  }
  // .gooseai.ProjectAccess access = 3 [json_name = "access"];
  if (this->_internal_access() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_access());
  }

  // .gooseai.ProjectStatus status = 4 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateProjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateProjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateProjectRequest::GetClassData() const { return &_class_data_; }


void CreateProjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateProjectRequest*>(&to_msg);
  auto& from = static_cast<const CreateProjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.CreateProjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_owner_id(from._internal_owner_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_file()->::gooseai::ProjectAsset::MergeFrom(
          from._internal_file());
    }
  }
  if (from._internal_access() != 0) {
    _this->_internal_set_access(from._internal_access());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateProjectRequest::CopyFrom(const CreateProjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.CreateProjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateProjectRequest::IsInitialized() const {
  return true;
}

void CreateProjectRequest::InternalSwap(CreateProjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateProjectRequest, _impl_.status_)
      + sizeof(CreateProjectRequest::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(CreateProjectRequest, _impl_.file_)>(
          reinterpret_cast<char*>(&_impl_.file_),
          reinterpret_cast<char*>(&other->_impl_.file_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateProjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[2]);
}

// ===================================================================

class UpdateProjectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateProjectRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_access(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::gooseai::ProjectAsset& file(const UpdateProjectRequest* msg);
  static void set_has_file(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::gooseai::ProjectAsset&
UpdateProjectRequest::_Internal::file(const UpdateProjectRequest* msg) {
  return *msg->_impl_.file_;
}
UpdateProjectRequest::UpdateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.UpdateProjectRequest)
}
UpdateProjectRequest::UpdateProjectRequest(const UpdateProjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateProjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_file()) {
    _this->_impl_.file_ = new ::gooseai::ProjectAsset(*from._impl_.file_);
  }
  ::memcpy(&_impl_.access_, &from._impl_.access_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:gooseai.UpdateProjectRequest)
}

inline void UpdateProjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.file_){nullptr}
    , decltype(_impl_.access_){0}
    , decltype(_impl_.status_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateProjectRequest::~UpdateProjectRequest() {
  // @@protoc_insertion_point(destructor:gooseai.UpdateProjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateProjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.owner_id_.Destroy();
  _impl_.title_.Destroy();
  if (this != internal_default_instance()) delete _impl_.file_;
}

void UpdateProjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateProjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.UpdateProjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.owner_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.file_ != nullptr);
      _impl_.file_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.access_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.access_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateProjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.UpdateProjectRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // optional string owner_id = 2 [json_name = "ownerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.UpdateProjectRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string title = 3 [json_name = "title"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.UpdateProjectRequest.title"));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ProjectAccess access = 4 [json_name = "access"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_access(static_cast<::gooseai::ProjectAccess>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ProjectStatus status = 5 [json_name = "status"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::gooseai::ProjectStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ProjectAsset file = 6 [json_name = "file"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateProjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.UpdateProjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.UpdateProjectRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.UpdateProjectRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner_id(), target);
  }

  // optional string title = 3 [json_name = "title"];
  if (_internal_has_title()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.UpdateProjectRequest.title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // optional .gooseai.ProjectAccess access = 4 [json_name = "access"];
  if (_internal_has_access()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_access(), target);
  }

  // optional .gooseai.ProjectStatus status = 5 [json_name = "status"];
  if (_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_status(), target);
  }

  // optional .gooseai.ProjectAsset file = 6 [json_name = "file"];
  if (_internal_has_file()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::file(this),
        _Internal::file(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.UpdateProjectRequest)
  return target;
}

size_t UpdateProjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.UpdateProjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string owner_id = 2 [json_name = "ownerId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_owner_id());
    }

    // optional string title = 3 [json_name = "title"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional .gooseai.ProjectAsset file = 6 [json_name = "file"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.file_);
    }

    // optional .gooseai.ProjectAccess access = 4 [json_name = "access"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_access());
    }

    // optional .gooseai.ProjectStatus status = 5 [json_name = "status"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateProjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateProjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateProjectRequest::GetClassData() const { return &_class_data_; }


void UpdateProjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateProjectRequest*>(&to_msg);
  auto& from = static_cast<const UpdateProjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.UpdateProjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_owner_id(from._internal_owner_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_file()->::gooseai::ProjectAsset::MergeFrom(
          from._internal_file());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.access_ = from._impl_.access_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateProjectRequest::CopyFrom(const UpdateProjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.UpdateProjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateProjectRequest::IsInitialized() const {
  return true;
}

void UpdateProjectRequest::InternalSwap(UpdateProjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateProjectRequest, _impl_.status_)
      + sizeof(UpdateProjectRequest::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(UpdateProjectRequest, _impl_.file_)>(
          reinterpret_cast<char*>(&_impl_.file_),
          reinterpret_cast<char*>(&other->_impl_.file_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateProjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[3]);
}

// ===================================================================

class ListProjectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ListProjectRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ListProjectRequest::ListProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ListProjectRequest)
}
ListProjectRequest::ListProjectRequest(const ListProjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListProjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.ListProjectRequest)
}

inline void ListProjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_id_){}
  };
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListProjectRequest::~ListProjectRequest() {
  // @@protoc_insertion_point(destructor:gooseai.ListProjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListProjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.owner_id_.Destroy();
}

void ListProjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListProjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ListProjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.owner_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListProjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string owner_id = 1 [json_name = "ownerId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ListProjectRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListProjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ListProjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string owner_id = 1 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ListProjectRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_owner_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ListProjectRequest)
  return target;
}

size_t ListProjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ListProjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string owner_id = 1 [json_name = "ownerId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListProjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListProjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListProjectRequest::GetClassData() const { return &_class_data_; }


void ListProjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListProjectRequest*>(&to_msg);
  auto& from = static_cast<const ListProjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ListProjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_id()) {
    _this->_internal_set_owner_id(from._internal_owner_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListProjectRequest::CopyFrom(const ListProjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ListProjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListProjectRequest::IsInitialized() const {
  return true;
}

void ListProjectRequest::InternalSwap(ListProjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListProjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[4]);
}

// ===================================================================

class GetProjectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetProjectRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetProjectRequest::GetProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.GetProjectRequest)
}
GetProjectRequest::GetProjectRequest(const GetProjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetProjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.GetProjectRequest)
}

inline void GetProjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetProjectRequest::~GetProjectRequest() {
  // @@protoc_insertion_point(destructor:gooseai.GetProjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetProjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.owner_id_.Destroy();
}

void GetProjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetProjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.GetProjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.owner_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetProjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.GetProjectRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // optional string owner_id = 2 [json_name = "ownerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.GetProjectRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetProjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.GetProjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.GetProjectRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.GetProjectRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.GetProjectRequest)
  return target;
}

size_t GetProjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.GetProjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetProjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetProjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetProjectRequest::GetClassData() const { return &_class_data_; }


void GetProjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetProjectRequest*>(&to_msg);
  auto& from = static_cast<const GetProjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.GetProjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_owner_id()) {
    _this->_internal_set_owner_id(from._internal_owner_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetProjectRequest::CopyFrom(const GetProjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.GetProjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetProjectRequest::IsInitialized() const {
  return true;
}

void GetProjectRequest::InternalSwap(GetProjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetProjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[5]);
}

// ===================================================================

class DeleteProjectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteProjectRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeleteProjectRequest::DeleteProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.DeleteProjectRequest)
}
DeleteProjectRequest::DeleteProjectRequest(const DeleteProjectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteProjectRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.DeleteProjectRequest)
}

inline void DeleteProjectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteProjectRequest::~DeleteProjectRequest() {
  // @@protoc_insertion_point(destructor:gooseai.DeleteProjectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteProjectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.owner_id_.Destroy();
}

void DeleteProjectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteProjectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.DeleteProjectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.owner_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteProjectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.DeleteProjectRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // optional string owner_id = 2 [json_name = "ownerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.DeleteProjectRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteProjectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.DeleteProjectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.DeleteProjectRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.DeleteProjectRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.DeleteProjectRequest)
  return target;
}

size_t DeleteProjectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.DeleteProjectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteProjectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteProjectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteProjectRequest::GetClassData() const { return &_class_data_; }


void DeleteProjectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteProjectRequest*>(&to_msg);
  auto& from = static_cast<const DeleteProjectRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.DeleteProjectRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_owner_id()) {
    _this->_internal_set_owner_id(from._internal_owner_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteProjectRequest::CopyFrom(const DeleteProjectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.DeleteProjectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteProjectRequest::IsInitialized() const {
  return true;
}

void DeleteProjectRequest::InternalSwap(DeleteProjectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteProjectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[6]);
}

// ===================================================================

class QueryAssetsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<QueryAssetsRequest>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_since(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_until(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_start_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

QueryAssetsRequest::QueryAssetsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.QueryAssetsRequest)
}
QueryAssetsRequest::QueryAssetsRequest(const QueryAssetsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QueryAssetsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_){from._impl_.use_}
    , /*decltype(_impl_._use_cached_byte_size_)*/{0}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.start_key_){}
    , decltype(_impl_.since_){}
    , decltype(_impl_.until_){}
    , decltype(_impl_.limit_){}
    , decltype(_impl_.sort_dir_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_.Set(from._internal_owner_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.start_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_start_key()) {
    _this->_impl_.start_key_.Set(from._internal_start_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.since_, &from._impl_.since_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sort_dir_) -
    reinterpret_cast<char*>(&_impl_.since_)) + sizeof(_impl_.sort_dir_));
  // @@protoc_insertion_point(copy_constructor:gooseai.QueryAssetsRequest)
}

inline void QueryAssetsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_){arena}
    , /*decltype(_impl_._use_cached_byte_size_)*/{0}
    , decltype(_impl_.id_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.start_key_){}
    , decltype(_impl_.since_){uint64_t{0u}}
    , decltype(_impl_.until_){uint64_t{0u}}
    , decltype(_impl_.limit_){uint64_t{0u}}
    , decltype(_impl_.sort_dir_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QueryAssetsRequest::~QueryAssetsRequest() {
  // @@protoc_insertion_point(destructor:gooseai.QueryAssetsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueryAssetsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.use_.~RepeatedField();
  _impl_.id_.Destroy();
  _impl_.owner_id_.Destroy();
  _impl_.start_key_.Destroy();
}

void QueryAssetsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QueryAssetsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.QueryAssetsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.use_.Clear();
  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.owner_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.start_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.since_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.limit_) -
        reinterpret_cast<char*>(&_impl_.since_)) + sizeof(_impl_.limit_));
  }
  _impl_.sort_dir_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryAssetsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.QueryAssetsRequest.id"));
        } else
          goto handle_unusual;
        continue;
      // optional string owner_id = 2 [json_name = "ownerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.QueryAssetsRequest.owner_id"));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 since = 3 [json_name = "since"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_since(&has_bits);
          _impl_.since_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 until = 4 [json_name = "until"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_until(&has_bits);
          _impl_.until_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 limit = 5 [json_name = "limit"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_limit(&has_bits);
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string start_key = 6 [json_name = "startKey"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_start_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.QueryAssetsRequest.start_key"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.ProjectAssetUse use = 7 [json_name = "use"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_use(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_use(static_cast<::gooseai::ProjectAssetUse>(val));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ProjectSortDir sort_dir = 8 [json_name = "sortDir"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sort_dir(static_cast<::gooseai::ProjectSortDir>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryAssetsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.QueryAssetsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.QueryAssetsRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string owner_id = 2 [json_name = "ownerId"];
  if (_internal_has_owner_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner_id().data(), static_cast<int>(this->_internal_owner_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.QueryAssetsRequest.owner_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner_id(), target);
  }

  // optional uint64 since = 3 [json_name = "since"];
  if (_internal_has_since()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_since(), target);
  }

  // optional uint64 until = 4 [json_name = "until"];
  if (_internal_has_until()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_until(), target);
  }

  // optional uint64 limit = 5 [json_name = "limit"];
  if (_internal_has_limit()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_limit(), target);
  }

  // optional string start_key = 6 [json_name = "startKey"];
  if (_internal_has_start_key()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_start_key().data(), static_cast<int>(this->_internal_start_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.QueryAssetsRequest.start_key");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_start_key(), target);
  }

  // repeated .gooseai.ProjectAssetUse use = 7 [json_name = "use"];
  {
    int byte_size = _impl_._use_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          7, _impl_.use_, byte_size, target);
    }
  }

  // .gooseai.ProjectSortDir sort_dir = 8 [json_name = "sortDir"];
  if (this->_internal_sort_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_sort_dir(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.QueryAssetsRequest)
  return target;
}

size_t QueryAssetsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.QueryAssetsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.ProjectAssetUse use = 7 [json_name = "use"];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_use_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_use(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._use_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string owner_id = 2 [json_name = "ownerId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_owner_id());
    }

    // optional string start_key = 6 [json_name = "startKey"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_start_key());
    }

    // optional uint64 since = 3 [json_name = "since"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_since());
    }

    // optional uint64 until = 4 [json_name = "until"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_until());
    }

    // optional uint64 limit = 5 [json_name = "limit"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_limit());
    }

  }
  // .gooseai.ProjectSortDir sort_dir = 8 [json_name = "sortDir"];
  if (this->_internal_sort_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sort_dir());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryAssetsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QueryAssetsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryAssetsRequest::GetClassData() const { return &_class_data_; }


void QueryAssetsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QueryAssetsRequest*>(&to_msg);
  auto& from = static_cast<const QueryAssetsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.QueryAssetsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.use_.MergeFrom(from._impl_.use_);
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_owner_id(from._internal_owner_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_start_key(from._internal_start_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.since_ = from._impl_.since_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.until_ = from._impl_.until_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.limit_ = from._impl_.limit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_sort_dir() != 0) {
    _this->_internal_set_sort_dir(from._internal_sort_dir());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryAssetsRequest::CopyFrom(const QueryAssetsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.QueryAssetsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAssetsRequest::IsInitialized() const {
  return true;
}

void QueryAssetsRequest::InternalSwap(QueryAssetsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.use_.InternalSwap(&other->_impl_.use_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_id_, lhs_arena,
      &other->_impl_.owner_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.start_key_, lhs_arena,
      &other->_impl_.start_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueryAssetsRequest, _impl_.sort_dir_)
      + sizeof(QueryAssetsRequest::_impl_.sort_dir_)
      - PROTOBUF_FIELD_OFFSET(QueryAssetsRequest, _impl_.since_)>(
          reinterpret_cast<char*>(&_impl_.since_),
          reinterpret_cast<char*>(&other->_impl_.since_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryAssetsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[7]);
}

// ===================================================================

class QueryAssetsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<QueryAssetsResponse>()._impl_._has_bits_);
  static void set_has_last_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

QueryAssetsResponse::QueryAssetsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.QueryAssetsResponse)
}
QueryAssetsResponse::QueryAssetsResponse(const QueryAssetsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QueryAssetsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assets_){from._impl_.assets_}
    , decltype(_impl_.last_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.last_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_key()) {
    _this->_impl_.last_key_.Set(from._internal_last_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.QueryAssetsResponse)
}

inline void QueryAssetsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assets_){arena}
    , decltype(_impl_.last_key_){}
  };
  _impl_.last_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QueryAssetsResponse::~QueryAssetsResponse() {
  // @@protoc_insertion_point(destructor:gooseai.QueryAssetsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueryAssetsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assets_.~RepeatedPtrField();
  _impl_.last_key_.Destroy();
}

void QueryAssetsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QueryAssetsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.QueryAssetsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.last_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryAssetsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.ProjectAsset assets = 1 [json_name = "assets"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string last_key = 2 [json_name = "lastKey"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_last_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.QueryAssetsResponse.last_key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryAssetsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.QueryAssetsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.ProjectAsset assets = 1 [json_name = "assets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assets_size()); i < n; i++) {
    const auto& repfield = this->_internal_assets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string last_key = 2 [json_name = "lastKey"];
  if (_internal_has_last_key()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_last_key().data(), static_cast<int>(this->_internal_last_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.QueryAssetsResponse.last_key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_last_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.QueryAssetsResponse)
  return target;
}

size_t QueryAssetsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.QueryAssetsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.ProjectAsset assets = 1 [json_name = "assets"];
  total_size += 1UL * this->_internal_assets_size();
  for (const auto& msg : this->_impl_.assets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string last_key = 2 [json_name = "lastKey"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_last_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryAssetsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QueryAssetsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryAssetsResponse::GetClassData() const { return &_class_data_; }


void QueryAssetsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QueryAssetsResponse*>(&to_msg);
  auto& from = static_cast<const QueryAssetsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.QueryAssetsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assets_.MergeFrom(from._impl_.assets_);
  if (from._internal_has_last_key()) {
    _this->_internal_set_last_key(from._internal_last_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryAssetsResponse::CopyFrom(const QueryAssetsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.QueryAssetsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAssetsResponse::IsInitialized() const {
  return true;
}

void QueryAssetsResponse::InternalSwap(QueryAssetsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.assets_.InternalSwap(&other->_impl_.assets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_key_, lhs_arena,
      &other->_impl_.last_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryAssetsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_project_2eproto_getter, &descriptor_table_project_2eproto_once,
      file_level_metadata_project_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace gooseai
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::gooseai::ProjectAsset*
Arena::CreateMaybeMessage< ::gooseai::ProjectAsset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ProjectAsset >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Project*
Arena::CreateMaybeMessage< ::gooseai::Project >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Project >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::CreateProjectRequest*
Arena::CreateMaybeMessage< ::gooseai::CreateProjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::CreateProjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::UpdateProjectRequest*
Arena::CreateMaybeMessage< ::gooseai::UpdateProjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::UpdateProjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ListProjectRequest*
Arena::CreateMaybeMessage< ::gooseai::ListProjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ListProjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::GetProjectRequest*
Arena::CreateMaybeMessage< ::gooseai::GetProjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::GetProjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::DeleteProjectRequest*
Arena::CreateMaybeMessage< ::gooseai::DeleteProjectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::DeleteProjectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::QueryAssetsRequest*
Arena::CreateMaybeMessage< ::gooseai::QueryAssetsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::QueryAssetsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::QueryAssetsResponse*
Arena::CreateMaybeMessage< ::gooseai::QueryAssetsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::QueryAssetsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
