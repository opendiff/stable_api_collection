// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: generation.proto

#include "generation.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace gooseai {
PROTOBUF_CONSTEXPR Token::Token(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u} {}
struct TokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenDefaultTypeInternal() {}
  union {
    Token _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenDefaultTypeInternal _Token_default_instance_;
PROTOBUF_CONSTEXPR Tokens::Tokens(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_.tokenizer_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TokensDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokensDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokensDefaultTypeInternal() {}
  union {
    Tokens _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokensDefaultTypeInternal _Tokens_default_instance_;
PROTOBUF_CONSTEXPR Artifact::Artifact(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mime_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.magic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.finish_reason_)*/0
  , /*decltype(_impl_.seed_)*/0u
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ArtifactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactDefaultTypeInternal() {}
  union {
    Artifact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactDefaultTypeInternal _Artifact_default_instance_;
PROTOBUF_CONSTEXPR PromptParameters::PromptParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.init_)*/false
  , /*decltype(_impl_.weight_)*/0} {}
struct PromptParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptParametersDefaultTypeInternal() {}
  union {
    PromptParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptParametersDefaultTypeInternal _PromptParameters_default_instance_;
PROTOBUF_CONSTEXPR Prompt::Prompt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parameters_)*/nullptr
  , /*decltype(_impl_.prompt_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PromptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptDefaultTypeInternal() {}
  union {
    Prompt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptDefaultTypeInternal _Prompt_default_instance_;
PROTOBUF_CONSTEXPR SamplerParameters::SamplerParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sampling_steps_)*/uint64_t{0u}
  , /*decltype(_impl_.latent_channels_)*/uint64_t{0u}
  , /*decltype(_impl_.eta_)*/0
  , /*decltype(_impl_.cfg_scale_)*/0
  , /*decltype(_impl_.downsampling_factor_)*/uint64_t{0u}
  , /*decltype(_impl_.init_noise_scale_)*/0
  , /*decltype(_impl_.step_noise_scale_)*/0} {}
struct SamplerParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SamplerParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SamplerParametersDefaultTypeInternal() {}
  union {
    SamplerParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SamplerParametersDefaultTypeInternal _SamplerParameters_default_instance_;
PROTOBUF_CONSTEXPR ConditionerParameters::ConditionerParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vector_adjust_prior_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.conditioner_)*/nullptr} {}
struct ConditionerParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConditionerParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConditionerParametersDefaultTypeInternal() {}
  union {
    ConditionerParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConditionerParametersDefaultTypeInternal _ConditionerParameters_default_instance_;
PROTOBUF_CONSTEXPR ScheduleParameters::ScheduleParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.end_)*/0
  , /*decltype(_impl_.value_)*/0} {}
struct ScheduleParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScheduleParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScheduleParametersDefaultTypeInternal() {}
  union {
    ScheduleParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScheduleParametersDefaultTypeInternal _ScheduleParameters_default_instance_;
PROTOBUF_CONSTEXPR StepParameter::StepParameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sampler_)*/nullptr
  , /*decltype(_impl_.schedule_)*/nullptr
  , /*decltype(_impl_.guidance_)*/nullptr
  , /*decltype(_impl_.scaled_step_)*/0} {}
struct StepParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StepParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StepParameterDefaultTypeInternal() {}
  union {
    StepParameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StepParameterDefaultTypeInternal _StepParameter_default_instance_;
PROTOBUF_CONSTEXPR Model::Model(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.publisher_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dataset_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.semantic_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.architecture_)*/0
  , /*decltype(_impl_.version_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelDefaultTypeInternal() {}
  union {
    Model _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDefaultTypeInternal _Model_default_instance_;
PROTOBUF_CONSTEXPR CutoutParameters::CutoutParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cutouts_)*/{}
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.gray_)*/0
  , /*decltype(_impl_.blur_)*/0
  , /*decltype(_impl_.size_power_)*/0} {}
struct CutoutParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CutoutParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CutoutParametersDefaultTypeInternal() {}
  union {
    CutoutParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CutoutParametersDefaultTypeInternal _CutoutParameters_default_instance_;
PROTOBUF_CONSTEXPR GuidanceScheduleParameters::GuidanceScheduleParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GuidanceScheduleParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuidanceScheduleParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuidanceScheduleParametersDefaultTypeInternal() {}
  union {
    GuidanceScheduleParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuidanceScheduleParametersDefaultTypeInternal _GuidanceScheduleParameters_default_instance_;
PROTOBUF_CONSTEXPR GuidanceInstanceParameters::GuidanceInstanceParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.models_)*/{}
  , /*decltype(_impl_.schedule_)*/{}
  , /*decltype(_impl_.cutouts_)*/nullptr
  , /*decltype(_impl_.prompt_)*/nullptr
  , /*decltype(_impl_.guidance_strength_)*/0} {}
struct GuidanceInstanceParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuidanceInstanceParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuidanceInstanceParametersDefaultTypeInternal() {}
  union {
    GuidanceInstanceParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuidanceInstanceParametersDefaultTypeInternal _GuidanceInstanceParameters_default_instance_;
PROTOBUF_CONSTEXPR GuidanceParameters::GuidanceParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.instances_)*/{}
  , /*decltype(_impl_.guidance_preset_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GuidanceParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuidanceParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuidanceParametersDefaultTypeInternal() {}
  union {
    GuidanceParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuidanceParametersDefaultTypeInternal _GuidanceParameters_default_instance_;
PROTOBUF_CONSTEXPR TransformType::TransformType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TransformTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransformTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransformTypeDefaultTypeInternal() {}
  union {
    TransformType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransformTypeDefaultTypeInternal _TransformType_default_instance_;
PROTOBUF_CONSTEXPR ImageParameters::ImageParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seed_)*/{}
  , /*decltype(_impl_._seed_cached_byte_size_)*/{0}
  , /*decltype(_impl_.parameters_)*/{}
  , /*decltype(_impl_.transform_)*/nullptr
  , /*decltype(_impl_.height_)*/uint64_t{0u}
  , /*decltype(_impl_.width_)*/uint64_t{0u}
  , /*decltype(_impl_.samples_)*/uint64_t{0u}
  , /*decltype(_impl_.steps_)*/uint64_t{0u}
  , /*decltype(_impl_.masked_area_init_)*/0
  , /*decltype(_impl_.weight_method_)*/0
  , /*decltype(_impl_.quantize_)*/false} {}
struct ImageParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageParametersDefaultTypeInternal() {}
  union {
    ImageParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageParametersDefaultTypeInternal _ImageParameters_default_instance_;
PROTOBUF_CONSTEXPR ClassifierConcept::ClassifierConcept(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.concept_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.threshold_)*/0} {}
struct ClassifierConceptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClassifierConceptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClassifierConceptDefaultTypeInternal() {}
  union {
    ClassifierConcept _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassifierConceptDefaultTypeInternal _ClassifierConcept_default_instance_;
PROTOBUF_CONSTEXPR ClassifierCategory::ClassifierCategory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.concepts_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.adjustment_)*/0
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_.classifier_mode_)*/0} {}
struct ClassifierCategoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClassifierCategoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClassifierCategoryDefaultTypeInternal() {}
  union {
    ClassifierCategory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassifierCategoryDefaultTypeInternal _ClassifierCategory_default_instance_;
PROTOBUF_CONSTEXPR ClassifierParameters::ClassifierParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.categories_)*/{}
  , /*decltype(_impl_.exceeds_)*/{}
  , /*decltype(_impl_.realized_action_)*/0} {}
struct ClassifierParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClassifierParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClassifierParametersDefaultTypeInternal() {}
  union {
    ClassifierParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassifierParametersDefaultTypeInternal _ClassifierParameters_default_instance_;
PROTOBUF_CONSTEXPR AssetParameters::AssetParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.project_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_.use_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssetParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssetParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssetParametersDefaultTypeInternal() {}
  union {
    AssetParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssetParametersDefaultTypeInternal _AssetParameters_default_instance_;
PROTOBUF_CONSTEXPR AnswerMeta::AnswerMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gpu_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpu_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.engine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AnswerMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnswerMetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnswerMetaDefaultTypeInternal() {}
  union {
    AnswerMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnswerMetaDefaultTypeInternal _AnswerMeta_default_instance_;
PROTOBUF_CONSTEXPR Answer::Answer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.artifacts_)*/{}
  , /*decltype(_impl_.answer_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_.received_)*/uint64_t{0u}
  , /*decltype(_impl_.created_)*/uint64_t{0u}} {}
struct AnswerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnswerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnswerDefaultTypeInternal() {}
  union {
    Answer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnswerDefaultTypeInternal _Answer_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prompt_)*/{}
  , /*decltype(_impl_.engine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.conditioner_)*/nullptr
  , /*decltype(_impl_.requested_type_)*/0
  , /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR OnStatus::OnStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/{}
  , /*decltype(_impl_._reason_cached_byte_size_)*/{0}
  , /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._action_cached_byte_size_)*/{0}
  , /*decltype(_impl_.target_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct OnStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnStatusDefaultTypeInternal() {}
  union {
    OnStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnStatusDefaultTypeInternal _OnStatus_default_instance_;
PROTOBUF_CONSTEXPR Stage::Stage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.on_status_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StageDefaultTypeInternal() {}
  union {
    Stage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StageDefaultTypeInternal _Stage_default_instance_;
PROTOBUF_CONSTEXPR ChainRequest::ChainRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stage_)*/{}
  , /*decltype(_impl_.request_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChainRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChainRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChainRequestDefaultTypeInternal() {}
  union {
    ChainRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChainRequestDefaultTypeInternal _ChainRequest_default_instance_;
}  // namespace gooseai
static ::_pb::Metadata file_level_metadata_generation_2eproto[26];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_generation_2eproto[13];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_generation_2eproto = nullptr;

const uint32_t TableStruct_generation_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::gooseai::Token, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Token, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Token, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Token, _impl_.id_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::gooseai::Tokens, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Tokens, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Tokens, _impl_.tokens_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Tokens, _impl_.tokenizer_id_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.mime_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.magic_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.finish_reason_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.seed_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Artifact, _impl_.data_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::gooseai::PromptParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::PromptParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::PromptParameters, _impl_.init_),
  PROTOBUF_FIELD_OFFSET(::gooseai::PromptParameters, _impl_.weight_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::gooseai::Prompt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Prompt, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gooseai::Prompt, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Prompt, _impl_.parameters_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gooseai::Prompt, _impl_.prompt_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.eta_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.sampling_steps_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.latent_channels_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.downsampling_factor_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.cfg_scale_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.init_noise_scale_),
  PROTOBUF_FIELD_OFFSET(::gooseai::SamplerParameters, _impl_.step_noise_scale_),
  2,
  0,
  1,
  4,
  3,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::gooseai::ConditionerParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ConditionerParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ConditionerParameters, _impl_.vector_adjust_prior_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ConditionerParameters, _impl_.conditioner_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::gooseai::ScheduleParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ScheduleParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ScheduleParameters, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ScheduleParameters, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ScheduleParameters, _impl_.value_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _impl_.scaled_step_),
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _impl_.sampler_),
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _impl_.schedule_),
  PROTOBUF_FIELD_OFFSET(::gooseai::StepParameter, _impl_.guidance_),
  ~0u,
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.architecture_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.publisher_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.dataset_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.semantic_version_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Model, _impl_.alias_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_.cutouts_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_.gray_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_.blur_),
  PROTOBUF_FIELD_OFFSET(::gooseai::CutoutParameters, _impl_.size_power_),
  ~0u,
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceScheduleParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceScheduleParameters, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceScheduleParameters, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_.models_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_.guidance_strength_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_.schedule_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_.cutouts_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceInstanceParameters, _impl_.prompt_),
  ~0u,
  2,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceParameters, _impl_.guidance_preset_),
  PROTOBUF_FIELD_OFFSET(::gooseai::GuidanceParameters, _impl_.instances_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::TransformType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gooseai::TransformType, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gooseai::TransformType, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.seed_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.samples_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.steps_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.transform_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.masked_area_init_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.weight_method_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ImageParameters, _impl_.quantize_),
  1,
  2,
  ~0u,
  3,
  4,
  0,
  ~0u,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierConcept, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierConcept, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierConcept, _impl_.concept_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierConcept, _impl_.threshold_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_.concepts_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_.adjustment_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierCategory, _impl_.classifier_mode_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierParameters, _impl_.categories_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierParameters, _impl_.exceeds_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ClassifierParameters, _impl_.realized_action_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::AssetParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::AssetParameters, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AssetParameters, _impl_.project_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AssetParameters, _impl_.use_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _impl_.gpu_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _impl_.cpu_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::AnswerMeta, _impl_.engine_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.answer_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.received_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.created_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Answer, _impl_.artifacts_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.engine_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.requested_type_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.prompt_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.conditioner_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Request, _impl_.params_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::gooseai::OnStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::gooseai::OnStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::OnStatus, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::gooseai::OnStatus, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::gooseai::OnStatus, _impl_.action_),
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::Stage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::Stage, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Stage, _impl_.request_),
  PROTOBUF_FIELD_OFFSET(::gooseai::Stage, _impl_.on_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gooseai::ChainRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gooseai::ChainRequest, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::gooseai::ChainRequest, _impl_.stage_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::gooseai::Token)},
  { 10, 18, -1, sizeof(::gooseai::Tokens)},
  { 20, 41, -1, sizeof(::gooseai::Artifact)},
  { 55, 63, -1, sizeof(::gooseai::PromptParameters)},
  { 65, 76, -1, sizeof(::gooseai::Prompt)},
  { 80, 93, -1, sizeof(::gooseai::SamplerParameters)},
  { 100, 108, -1, sizeof(::gooseai::ConditionerParameters)},
  { 110, 119, -1, sizeof(::gooseai::ScheduleParameters)},
  { 122, 132, -1, sizeof(::gooseai::StepParameter)},
  { 136, -1, -1, sizeof(::gooseai::Model)},
  { 148, 159, -1, sizeof(::gooseai::CutoutParameters)},
  { 164, -1, -1, sizeof(::gooseai::GuidanceScheduleParameters)},
  { 172, 183, -1, sizeof(::gooseai::GuidanceInstanceParameters)},
  { 188, -1, -1, sizeof(::gooseai::GuidanceParameters)},
  { 196, -1, -1, sizeof(::gooseai::TransformType)},
  { 205, 221, -1, sizeof(::gooseai::ImageParameters)},
  { 231, 239, -1, sizeof(::gooseai::ClassifierConcept)},
  { 241, 252, -1, sizeof(::gooseai::ClassifierCategory)},
  { 257, 266, -1, sizeof(::gooseai::ClassifierParameters)},
  { 269, -1, -1, sizeof(::gooseai::AssetParameters)},
  { 278, 288, -1, sizeof(::gooseai::AnswerMeta)},
  { 292, 304, -1, sizeof(::gooseai::Answer)},
  { 310, 325, -1, sizeof(::gooseai::Request)},
  { 333, 342, -1, sizeof(::gooseai::OnStatus)},
  { 345, -1, -1, sizeof(::gooseai::Stage)},
  { 354, -1, -1, sizeof(::gooseai::ChainRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::gooseai::_Token_default_instance_._instance,
  &::gooseai::_Tokens_default_instance_._instance,
  &::gooseai::_Artifact_default_instance_._instance,
  &::gooseai::_PromptParameters_default_instance_._instance,
  &::gooseai::_Prompt_default_instance_._instance,
  &::gooseai::_SamplerParameters_default_instance_._instance,
  &::gooseai::_ConditionerParameters_default_instance_._instance,
  &::gooseai::_ScheduleParameters_default_instance_._instance,
  &::gooseai::_StepParameter_default_instance_._instance,
  &::gooseai::_Model_default_instance_._instance,
  &::gooseai::_CutoutParameters_default_instance_._instance,
  &::gooseai::_GuidanceScheduleParameters_default_instance_._instance,
  &::gooseai::_GuidanceInstanceParameters_default_instance_._instance,
  &::gooseai::_GuidanceParameters_default_instance_._instance,
  &::gooseai::_TransformType_default_instance_._instance,
  &::gooseai::_ImageParameters_default_instance_._instance,
  &::gooseai::_ClassifierConcept_default_instance_._instance,
  &::gooseai::_ClassifierCategory_default_instance_._instance,
  &::gooseai::_ClassifierParameters_default_instance_._instance,
  &::gooseai::_AssetParameters_default_instance_._instance,
  &::gooseai::_AnswerMeta_default_instance_._instance,
  &::gooseai::_Answer_default_instance_._instance,
  &::gooseai::_Request_default_instance_._instance,
  &::gooseai::_OnStatus_default_instance_._instance,
  &::gooseai::_Stage_default_instance_._instance,
  &::gooseai::_ChainRequest_default_instance_._instance,
};

const char descriptor_table_protodef_generation_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020generation.proto\022\007gooseai\032\rtensors.pro"
  "to\"9\n\005Token\022\027\n\004text\030\001 \001(\tH\000R\004text\210\001\001\022\016\n\002"
  "id\030\002 \001(\rR\002idB\007\n\005_text\"i\n\006Tokens\022&\n\006token"
  "s\030\001 \003(\0132\016.gooseai.TokenR\006tokens\022&\n\014token"
  "izer_id\030\002 \001(\tH\000R\013tokenizerId\210\001\001B\017\n\r_toke"
  "nizer_id\"\333\003\n\010Artifact\022\016\n\002id\030\001 \001(\004R\002id\022)\n"
  "\004type\030\002 \001(\0162\025.gooseai.ArtifactTypeR\004type"
  "\022\022\n\004mime\030\003 \001(\tR\004mime\022\031\n\005magic\030\004 \001(\tH\001R\005m"
  "agic\210\001\001\022\030\n\006binary\030\005 \001(\014H\000R\006binary\022\024\n\004tex"
  "t\030\006 \001(\tH\000R\004text\022)\n\006tokens\030\007 \001(\0132\017.goosea"
  "i.TokensH\000R\006tokens\022\?\n\nclassifier\030\013 \001(\0132\035"
  ".gooseai.ClassifierParametersH\000R\nclassif"
  "ier\022)\n\006tensor\030\016 \001(\0132\017.tensors.TensorH\000R\006"
  "tensor\022\024\n\005index\030\010 \001(\rR\005index\022:\n\rfinish_r"
  "eason\030\t \001(\0162\025.gooseai.FinishReasonR\014fini"
  "shReason\022\022\n\004seed\030\n \001(\rR\004seed\022\022\n\004uuid\030\014 \001"
  "(\tR\004uuid\022\022\n\004size\030\r \001(\004R\004sizeB\006\n\004dataB\010\n\006"
  "_magic\"\\\n\020PromptParameters\022\027\n\004init\030\001 \001(\010"
  "H\000R\004init\210\001\001\022\033\n\006weight\030\002 \001(\002H\001R\006weight\210\001\001"
  "B\007\n\005_initB\t\n\007_weight\"\323\001\n\006Prompt\022>\n\nparam"
  "eters\030\001 \001(\0132\031.gooseai.PromptParametersH\001"
  "R\nparameters\210\001\001\022\024\n\004text\030\002 \001(\tH\000R\004text\022)\n"
  "\006tokens\030\003 \001(\0132\017.gooseai.TokensH\000R\006tokens"
  "\022/\n\010artifact\030\004 \001(\0132\021.gooseai.ArtifactH\000R"
  "\010artifactB\010\n\006promptB\r\n\013_parameters\"\271\003\n\021S"
  "amplerParameters\022\025\n\003eta\030\001 \001(\002H\000R\003eta\210\001\001\022"
  "*\n\016sampling_steps\030\002 \001(\004H\001R\rsamplingSteps"
  "\210\001\001\022,\n\017latent_channels\030\003 \001(\004H\002R\016latentCh"
  "annels\210\001\001\0224\n\023downsampling_factor\030\004 \001(\004H\003"
  "R\022downsamplingFactor\210\001\001\022 \n\tcfg_scale\030\005 \001"
  "(\002H\004R\010cfgScale\210\001\001\022-\n\020init_noise_scale\030\006 "
  "\001(\002H\005R\016initNoiseScale\210\001\001\022-\n\020step_noise_s"
  "cale\030\007 \001(\002H\006R\016stepNoiseScale\210\001\001B\006\n\004_etaB"
  "\021\n\017_sampling_stepsB\022\n\020_latent_channelsB\026"
  "\n\024_downsampling_factorB\014\n\n_cfg_scaleB\023\n\021"
  "_init_noise_scaleB\023\n\021_step_noise_scale\"\253"
  "\001\n\025ConditionerParameters\0223\n\023vector_adjus"
  "t_prior\030\001 \001(\tH\000R\021vectorAdjustPrior\210\001\001\0225\n"
  "\013conditioner\030\002 \001(\0132\016.gooseai.ModelH\001R\013co"
  "nditioner\210\001\001B\026\n\024_vector_adjust_priorB\016\n\014"
  "_conditioner\"}\n\022ScheduleParameters\022\031\n\005st"
  "art\030\001 \001(\002H\000R\005start\210\001\001\022\025\n\003end\030\002 \001(\002H\001R\003en"
  "d\210\001\001\022\031\n\005value\030\003 \001(\002H\002R\005value\210\001\001B\010\n\006_star"
  "tB\006\n\004_endB\010\n\006_value\"\215\002\n\rStepParameter\022\037\n"
  "\013scaled_step\030\001 \001(\002R\nscaledStep\0229\n\007sample"
  "r\030\002 \001(\0132\032.gooseai.SamplerParametersH\000R\007s"
  "ampler\210\001\001\022<\n\010schedule\030\003 \001(\0132\033.gooseai.Sc"
  "heduleParametersH\001R\010schedule\210\001\001\022<\n\010guida"
  "nce\030\004 \001(\0132\033.gooseai.GuidanceParametersH\002"
  "R\010guidance\210\001\001B\n\n\010_samplerB\013\n\t_scheduleB\013"
  "\n\t_guidance\"\332\001\n\005Model\022>\n\014architecture\030\001 "
  "\001(\0162\032.gooseai.ModelArchitectureR\014archite"
  "cture\022\034\n\tpublisher\030\002 \001(\tR\tpublisher\022\030\n\007d"
  "ataset\030\003 \001(\tR\007dataset\022\030\n\007version\030\004 \001(\002R\007"
  "version\022)\n\020semantic_version\030\005 \001(\tR\017seman"
  "ticVersion\022\024\n\005alias\030\006 \001(\tR\005alias\"\343\001\n\020Cut"
  "outParameters\0223\n\007cutouts\030\001 \003(\0132\031.gooseai"
  ".CutoutParametersR\007cutouts\022\031\n\005count\030\002 \001("
  "\rH\000R\005count\210\001\001\022\027\n\004gray\030\003 \001(\002H\001R\004gray\210\001\001\022\027"
  "\n\004blur\030\004 \001(\002H\002R\004blur\210\001\001\022\"\n\nsize_power\030\005 "
  "\001(\002H\003R\tsizePower\210\001\001B\010\n\006_countB\007\n\005_grayB\007"
  "\n\005_blurB\r\n\013_size_power\"N\n\032GuidanceSchedu"
  "leParameters\022\032\n\010duration\030\001 \001(\002R\010duration"
  "\022\024\n\005value\030\002 \001(\002R\005value\"\314\002\n\032GuidanceInsta"
  "nceParameters\022&\n\006models\030\002 \003(\0132\016.gooseai."
  "ModelR\006models\0220\n\021guidance_strength\030\003 \001(\002"
  "H\000R\020guidanceStrength\210\001\001\022\?\n\010schedule\030\004 \003("
  "\0132#.gooseai.GuidanceScheduleParametersR\010"
  "schedule\0228\n\007cutouts\030\005 \001(\0132\031.gooseai.Cuto"
  "utParametersH\001R\007cutouts\210\001\001\022,\n\006prompt\030\006 \001"
  "(\0132\017.gooseai.PromptH\002R\006prompt\210\001\001B\024\n\022_gui"
  "dance_strengthB\n\n\010_cutoutsB\t\n\007_prompt\"\231\001"
  "\n\022GuidanceParameters\022@\n\017guidance_preset\030"
  "\001 \001(\0162\027.gooseai.GuidancePresetR\016guidance"
  "Preset\022A\n\tinstances\030\002 \003(\0132#.gooseai.Guid"
  "anceInstanceParametersR\tinstances\"\203\001\n\rTr"
  "ansformType\0229\n\tdiffusion\030\001 \001(\0162\031.gooseai"
  ".DiffusionSamplerH\000R\tdiffusion\022/\n\010upscal"
  "er\030\002 \001(\0162\021.gooseai.UpscalerH\000R\010upscalerB"
  "\006\n\004type\"\241\004\n\017ImageParameters\022\033\n\006height\030\001 "
  "\001(\004H\000R\006height\210\001\001\022\031\n\005width\030\002 \001(\004H\001R\005width"
  "\210\001\001\022\022\n\004seed\030\003 \003(\rR\004seed\022\035\n\007samples\030\004 \001(\004"
  "H\002R\007samples\210\001\001\022\031\n\005steps\030\005 \001(\004H\003R\005steps\210\001"
  "\001\0229\n\ttransform\030\006 \001(\0132\026.gooseai.Transform"
  "TypeH\004R\ttransform\210\001\001\0226\n\nparameters\030\007 \003(\013"
  "2\026.gooseai.StepParameterR\nparameters\022F\n\020"
  "masked_area_init\030\010 \001(\0162\027.gooseai.MaskedA"
  "reaInitH\005R\016maskedAreaInit\210\001\001\022\?\n\rweight_m"
  "ethod\030\t \001(\0162\025.gooseai.WeightMethodH\006R\014we"
  "ightMethod\210\001\001\022\037\n\010quantize\030\n \001(\010H\007R\010quant"
  "ize\210\001\001B\t\n\007_heightB\010\n\006_widthB\n\n\010_samplesB"
  "\010\n\006_stepsB\014\n\n_transformB\023\n\021_masked_area_"
  "initB\020\n\016_weight_methodB\013\n\t_quantize\"^\n\021C"
  "lassifierConcept\022\030\n\007concept\030\001 \001(\tR\007conce"
  "pt\022!\n\tthreshold\030\002 \001(\002H\000R\tthreshold\210\001\001B\014\n"
  "\n_threshold\"\250\002\n\022ClassifierCategory\022\022\n\004na"
  "me\030\001 \001(\tR\004name\0226\n\010concepts\030\002 \003(\0132\032.goose"
  "ai.ClassifierConceptR\010concepts\022#\n\nadjust"
  "ment\030\003 \001(\002H\000R\nadjustment\210\001\001\022,\n\006action\030\004 "
  "\001(\0162\017.gooseai.ActionH\001R\006action\210\001\001\022E\n\017cla"
  "ssifier_mode\030\005 \001(\0162\027.gooseai.ClassifierM"
  "odeH\002R\016classifierMode\210\001\001B\r\n\013_adjustmentB"
  "\t\n\007_actionB\022\n\020_classifier_mode\"\335\001\n\024Class"
  "ifierParameters\022;\n\ncategories\030\001 \003(\0132\033.go"
  "oseai.ClassifierCategoryR\ncategories\0225\n\007"
  "exceeds\030\002 \003(\0132\033.gooseai.ClassifierCatego"
  "ryR\007exceeds\022=\n\017realized_action\030\003 \001(\0162\017.g"
  "ooseai.ActionH\000R\016realizedAction\210\001\001B\022\n\020_r"
  "ealized_action\"\203\001\n\017AssetParameters\022,\n\006ac"
  "tion\030\001 \001(\0162\024.gooseai.AssetActionR\006action"
  "\022\035\n\nproject_id\030\002 \001(\tR\tprojectId\022#\n\003use\030\003"
  " \001(\0162\021.gooseai.AssetUseR\003use\"\264\001\n\nAnswerM"
  "eta\022\032\n\006gpu_id\030\001 \001(\tH\000R\005gpuId\210\001\001\022\032\n\006cpu_i"
  "d\030\002 \001(\tH\001R\005cpuId\210\001\001\022\034\n\007node_id\030\003 \001(\tH\002R\006"
  "nodeId\210\001\001\022 \n\tengine_id\030\004 \001(\tH\003R\010engineId"
  "\210\001\001B\t\n\007_gpu_idB\t\n\007_cpu_idB\n\n\010_node_idB\014\n"
  "\n_engine_id\"\342\001\n\006Answer\022\033\n\tanswer_id\030\001 \001("
  "\tR\010answerId\022\035\n\nrequest_id\030\002 \001(\tR\trequest"
  "Id\022\032\n\010received\030\003 \001(\004R\010received\022\030\n\007create"
  "d\030\004 \001(\004R\007created\022,\n\004meta\030\006 \001(\0132\023.gooseai"
  ".AnswerMetaH\000R\004meta\210\001\001\022/\n\tartifacts\030\007 \003("
  "\0132\021.gooseai.ArtifactR\tartifactsB\007\n\005_meta"
  "\"\276\003\n\007Request\022\033\n\tengine_id\030\001 \001(\tR\010engineI"
  "d\022\035\n\nrequest_id\030\002 \001(\tR\trequestId\022<\n\016requ"
  "ested_type\030\003 \001(\0162\025.gooseai.ArtifactTypeR"
  "\rrequestedType\022\'\n\006prompt\030\004 \003(\0132\017.gooseai"
  ".PromptR\006prompt\0220\n\005image\030\005 \001(\0132\030.gooseai"
  ".ImageParametersH\000R\005image\022\?\n\nclassifier\030"
  "\007 \001(\0132\035.gooseai.ClassifierParametersH\000R\n"
  "classifier\0220\n\005asset\030\010 \001(\0132\030.gooseai.Asse"
  "tParametersH\000R\005asset\022E\n\013conditioner\030\006 \001("
  "\0132\036.gooseai.ConditionerParametersH\001R\013con"
  "ditioner\210\001\001B\010\n\006paramsB\016\n\014_conditionerJ\004\010"
  "\t\020\nJ\004\010\n\020\013\"\217\001\n\010OnStatus\022-\n\006reason\030\001 \003(\0162\025"
  ".gooseai.FinishReasonR\006reason\022\033\n\006target\030"
  "\002 \001(\tH\000R\006target\210\001\001\022,\n\006action\030\003 \003(\0162\024.goo"
  "seai.StageActionR\006actionB\t\n\007_target\"s\n\005S"
  "tage\022\016\n\002id\030\001 \001(\tR\002id\022*\n\007request\030\002 \001(\0132\020."
  "gooseai.RequestR\007request\022.\n\ton_status\030\003 "
  "\003(\0132\021.gooseai.OnStatusR\010onStatus\"S\n\014Chai"
  "nRequest\022\035\n\nrequest_id\030\001 \001(\tR\trequestId\022"
  "$\n\005stage\030\002 \003(\0132\016.gooseai.StageR\005stage*E\n"
  "\014FinishReason\022\010\n\004NULL\020\000\022\n\n\006LENGTH\020\001\022\010\n\004S"
  "TOP\020\002\022\t\n\005ERROR\020\003\022\n\n\006FILTER\020\004*\344\001\n\014Artifac"
  "tType\022\021\n\rARTIFACT_NONE\020\000\022\022\n\016ARTIFACT_IMA"
  "GE\020\001\022\022\n\016ARTIFACT_VIDEO\020\002\022\021\n\rARTIFACT_TEX"
  "T\020\003\022\023\n\017ARTIFACT_TOKENS\020\004\022\026\n\022ARTIFACT_EMB"
  "EDDING\020\005\022\034\n\030ARTIFACT_CLASSIFICATIONS\020\006\022\021"
  "\n\rARTIFACT_MASK\020\007\022\023\n\017ARTIFACT_LATENT\020\010\022\023"
  "\n\017ARTIFACT_TENSOR\020\t*g\n\016MaskedAreaInit\022\031\n"
  "\025MASKED_AREA_INIT_ZERO\020\000\022\033\n\027MASKED_AREA_"
  "INIT_RANDOM\020\001\022\035\n\031MASKED_AREA_INIT_ORIGIN"
  "AL\020\002*5\n\014WeightMethod\022\020\n\014TEXT_ENCODER\020\000\022\023"
  "\n\017CROSS_ATTENTION\020\001*\230\002\n\020DiffusionSampler"
  "\022\020\n\014SAMPLER_DDIM\020\000\022\020\n\014SAMPLER_DDPM\020\001\022\023\n\017"
  "SAMPLER_K_EULER\020\002\022\035\n\031SAMPLER_K_EULER_ANC"
  "ESTRAL\020\003\022\022\n\016SAMPLER_K_HEUN\020\004\022\023\n\017SAMPLER_"
  "K_DPM_2\020\005\022\035\n\031SAMPLER_K_DPM_2_ANCESTRAL\020\006"
  "\022\021\n\rSAMPLER_K_LMS\020\007\022 \n\034SAMPLER_K_DPMPP_2"
  "S_ANCESTRAL\020\010\022\026\n\022SAMPLER_K_DPMPP_2M\020\t\022\027\n"
  "\023SAMPLER_K_DPMPP_SDE\020\n*F\n\010Upscaler\022\020\n\014UP"
  "SCALER_RGB\020\000\022\023\n\017UPSCALER_GFPGAN\020\001\022\023\n\017UPS"
  "CALER_ESRGAN\020\002*\330\001\n\016GuidancePreset\022\030\n\024GUI"
  "DANCE_PRESET_NONE\020\000\022\032\n\026GUIDANCE_PRESET_S"
  "IMPLE\020\001\022\035\n\031GUIDANCE_PRESET_FAST_BLUE\020\002\022\036"
  "\n\032GUIDANCE_PRESET_FAST_GREEN\020\003\022\030\n\024GUIDAN"
  "CE_PRESET_SLOW\020\004\022\032\n\026GUIDANCE_PRESET_SLOW"
  "ER\020\005\022\033\n\027GUIDANCE_PRESET_SLOWEST\020\006*\221\001\n\021Mo"
  "delArchitecture\022\033\n\027MODEL_ARCHITECTURE_NO"
  "NE\020\000\022\037\n\033MODEL_ARCHITECTURE_CLIP_VIT\020\001\022\"\n"
  "\036MODEL_ARCHITECTURE_CLIP_RESNET\020\002\022\032\n\026MOD"
  "EL_ARCHITECTURE_LDM\020\003*\242\001\n\006Action\022\026\n\022ACTI"
  "ON_PASSTHROUGH\020\000\022\037\n\033ACTION_REGENERATE_DU"
  "PLICATE\020\001\022\025\n\021ACTION_REGENERATE\020\002\022\036\n\032ACTI"
  "ON_OBFUSCATE_DUPLICATE\020\003\022\024\n\020ACTION_OBFUS"
  "CATE\020\004\022\022\n\016ACTION_DISCARD\020\005*D\n\016Classifier"
  "Mode\022\027\n\023CLSFR_MODE_ZEROSHOT\020\000\022\031\n\025CLSFR_M"
  "ODE_MULTICLASS\020\001*=\n\013AssetAction\022\r\n\tASSET"
  "_PUT\020\000\022\r\n\tASSET_GET\020\001\022\020\n\014ASSET_DELETE\020\002*"
  "\201\001\n\010AssetUse\022\027\n\023ASSET_USE_UNDEFINED\020\000\022\023\n"
  "\017ASSET_USE_INPUT\020\001\022\024\n\020ASSET_USE_OUTPUT\020\002"
  "\022\032\n\026ASSET_USE_INTERMEDIATE\020\003\022\025\n\021ASSET_US"
  "E_PROJECT\020\004*W\n\013StageAction\022\025\n\021STAGE_ACTI"
  "ON_PASS\020\000\022\030\n\024STAGE_ACTION_DISCARD\020\001\022\027\n\023S"
  "TAGE_ACTION_RETURN\020\0022\203\001\n\021GenerationServi"
  "ce\0221\n\010Generate\022\020.gooseai.Request\032\017.goose"
  "ai.Answer\"\0000\001\022;\n\rChainGenerate\022\025.gooseai"
  ".ChainRequest\032\017.gooseai.Answer\"\0000\001B;Z9gi"
  "thub.com/stability-ai/api-interfaces/goo"
  "seai/generationb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_generation_2eproto_deps[1] = {
  &::descriptor_table_tensors_2eproto,
};
static ::_pbi::once_flag descriptor_table_generation_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_generation_2eproto = {
    false, false, 7583, descriptor_table_protodef_generation_2eproto,
    "generation.proto",
    &descriptor_table_generation_2eproto_once, descriptor_table_generation_2eproto_deps, 1, 26,
    schemas, file_default_instances, TableStruct_generation_2eproto::offsets,
    file_level_metadata_generation_2eproto, file_level_enum_descriptors_generation_2eproto,
    file_level_service_descriptors_generation_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_generation_2eproto_getter() {
  return &descriptor_table_generation_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_generation_2eproto(&descriptor_table_generation_2eproto);
namespace gooseai {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FinishReason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[0];
}
bool FinishReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[1];
}
bool ArtifactType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MaskedAreaInit_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[2];
}
bool MaskedAreaInit_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeightMethod_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[3];
}
bool WeightMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DiffusionSampler_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[4];
}
bool DiffusionSampler_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Upscaler_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[5];
}
bool Upscaler_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuidancePreset_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[6];
}
bool GuidancePreset_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelArchitecture_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[7];
}
bool ModelArchitecture_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[8];
}
bool Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClassifierMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[9];
}
bool ClassifierMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AssetAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[10];
}
bool AssetAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AssetUse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[11];
}
bool AssetUse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StageAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_generation_2eproto);
  return file_level_enum_descriptors_generation_2eproto[12];
}
bool StageAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Token::_Internal {
 public:
  using HasBits = decltype(std::declval<Token>()._impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Token::Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Token)
}
Token::Token(const Token& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Token* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:gooseai.Token)
}

inline void Token::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.id_){0u}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Token::~Token() {
  // @@protoc_insertion_point(destructor:gooseai.Token)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Token::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void Token::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Token::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Token)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_.ClearNonDefaultToEmpty();
  }
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Token::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1 [json_name = "text"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Token.text"));
        } else
          goto handle_unusual;
        continue;
      // uint32 id = 2 [json_name = "id"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Token::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Token)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string text = 1 [json_name = "text"];
  if (_internal_has_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Token.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // uint32 id = 2 [json_name = "id"];
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Token)
  return target;
}

size_t Token::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Token)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 1 [json_name = "text"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // uint32 id = 2 [json_name = "id"];
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Token::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Token::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Token::GetClassData() const { return &_class_data_; }


void Token::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Token*>(&to_msg);
  auto& from = static_cast<const Token&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Token)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Token::CopyFrom(const Token& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Token)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Token::IsInitialized() const {
  return true;
}

void Token::InternalSwap(Token* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Token::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[0]);
}

// ===================================================================

class Tokens::_Internal {
 public:
  using HasBits = decltype(std::declval<Tokens>()._impl_._has_bits_);
  static void set_has_tokenizer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Tokens::Tokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Tokens)
}
Tokens::Tokens(const Tokens& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tokens* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){from._impl_.tokens_}
    , decltype(_impl_.tokenizer_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tokenizer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tokenizer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tokenizer_id()) {
    _this->_impl_.tokenizer_id_.Set(from._internal_tokenizer_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.Tokens)
}

inline void Tokens::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){arena}
    , decltype(_impl_.tokenizer_id_){}
  };
  _impl_.tokenizer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tokenizer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Tokens::~Tokens() {
  // @@protoc_insertion_point(destructor:gooseai.Tokens)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tokens::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokens_.~RepeatedPtrField();
  _impl_.tokenizer_id_.Destroy();
}

void Tokens::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tokens::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Tokens)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tokenizer_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tokens::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.Token tokens = 1 [json_name = "tokens"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string tokenizer_id = 2 [json_name = "tokenizerId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tokenizer_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Tokens.tokenizer_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tokens::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Tokens)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.Token tokens = 1 [json_name = "tokens"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string tokenizer_id = 2 [json_name = "tokenizerId"];
  if (_internal_has_tokenizer_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tokenizer_id().data(), static_cast<int>(this->_internal_tokenizer_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Tokens.tokenizer_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_tokenizer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Tokens)
  return target;
}

size_t Tokens::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Tokens)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.Token tokens = 1 [json_name = "tokens"];
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string tokenizer_id = 2 [json_name = "tokenizerId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tokenizer_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tokens::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tokens::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tokens::GetClassData() const { return &_class_data_; }


void Tokens::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tokens*>(&to_msg);
  auto& from = static_cast<const Tokens&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Tokens)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  if (from._internal_has_tokenizer_id()) {
    _this->_internal_set_tokenizer_id(from._internal_tokenizer_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tokens::CopyFrom(const Tokens& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Tokens)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tokens::IsInitialized() const {
  return true;
}

void Tokens::InternalSwap(Tokens* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tokenizer_id_, lhs_arena,
      &other->_impl_.tokenizer_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Tokens::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[1]);
}

// ===================================================================

class Artifact::_Internal {
 public:
  using HasBits = decltype(std::declval<Artifact>()._impl_._has_bits_);
  static void set_has_magic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::Tokens& tokens(const Artifact* msg);
  static const ::gooseai::ClassifierParameters& classifier(const Artifact* msg);
  static const ::tensors::Tensor& tensor(const Artifact* msg);
};

const ::gooseai::Tokens&
Artifact::_Internal::tokens(const Artifact* msg) {
  return *msg->_impl_.data_.tokens_;
}
const ::gooseai::ClassifierParameters&
Artifact::_Internal::classifier(const Artifact* msg) {
  return *msg->_impl_.data_.classifier_;
}
const ::tensors::Tensor&
Artifact::_Internal::tensor(const Artifact* msg) {
  return *msg->_impl_.data_.tensor_;
}
void Artifact::set_allocated_tokens(::gooseai::Tokens* tokens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (tokens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokens);
    if (message_arena != submessage_arena) {
      tokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokens, submessage_arena);
    }
    set_has_tokens();
    _impl_.data_.tokens_ = tokens;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.tokens)
}
void Artifact::set_allocated_classifier(::gooseai::ClassifierParameters* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(classifier);
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    set_has_classifier();
    _impl_.data_.classifier_ = classifier;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.classifier)
}
void Artifact::set_allocated_tensor(::tensors::Tensor* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor));
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    set_has_tensor();
    _impl_.data_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Artifact.tensor)
}
void Artifact::clear_tensor() {
  if (_internal_has_tensor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.tensor_;
    }
    clear_has_data();
  }
}
Artifact::Artifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Artifact)
}
Artifact::Artifact(const Artifact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Artifact* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mime_){}
    , decltype(_impl_.magic_){}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.finish_reason_){}
    , decltype(_impl_.seed_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mime().empty()) {
    _this->_impl_.mime_.Set(from._internal_mime(), 
      _this->GetArenaForAllocation());
  }
  _impl_.magic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.magic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_magic()) {
    _this->_impl_.magic_.Set(from._internal_magic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.size_));
  clear_has_data();
  switch (from.data_case()) {
    case kBinary: {
      _this->_internal_set_binary(from._internal_binary());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case kTokens: {
      _this->_internal_mutable_tokens()->::gooseai::Tokens::MergeFrom(
          from._internal_tokens());
      break;
    }
    case kClassifier: {
      _this->_internal_mutable_classifier()->::gooseai::ClassifierParameters::MergeFrom(
          from._internal_classifier());
      break;
    }
    case kTensor: {
      _this->_internal_mutable_tensor()->::tensors::Tensor::MergeFrom(
          from._internal_tensor());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.Artifact)
}

inline void Artifact::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mime_){}
    , decltype(_impl_.magic_){}
    , decltype(_impl_.uuid_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.finish_reason_){0}
    , decltype(_impl_.seed_){0u}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.mime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.magic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.magic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_data();
}

Artifact::~Artifact() {
  // @@protoc_insertion_point(destructor:gooseai.Artifact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Artifact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mime_.Destroy();
  _impl_.magic_.Destroy();
  _impl_.uuid_.Destroy();
  if (has_data()) {
    clear_data();
  }
}

void Artifact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Artifact::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:gooseai.Artifact)
  switch (data_case()) {
    case kBinary: {
      _impl_.data_.binary_.Destroy();
      break;
    }
    case kText: {
      _impl_.data_.text_.Destroy();
      break;
    }
    case kTokens: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.tokens_;
      }
      break;
    }
    case kClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.classifier_;
      }
      break;
    }
    case kTensor: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.tensor_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void Artifact::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Artifact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mime_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.magic_.ClearNonDefaultToEmpty();
  }
  _impl_.uuid_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.size_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.size_));
  clear_data();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Artifact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ArtifactType type = 2 [json_name = "type"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::gooseai::ArtifactType>(val));
        } else
          goto handle_unusual;
        continue;
      // string mime = 3 [json_name = "mime"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Artifact.mime"));
        } else
          goto handle_unusual;
        continue;
      // optional string magic = 4 [json_name = "magic"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_magic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Artifact.magic"));
        } else
          goto handle_unusual;
        continue;
      // bytes binary = 5 [json_name = "binary"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_binary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 6 [json_name = "text"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Artifact.text"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Tokens tokens = 7 [json_name = "tokens"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokens(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 index = 8 [json_name = "index"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.FinishReason finish_reason = 9 [json_name = "finishReason"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_finish_reason(static_cast<::gooseai::FinishReason>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 seed = 10 [json_name = "seed"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ClassifierParameters classifier = 11 [json_name = "classifier"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string uuid = 12 [json_name = "uuid"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Artifact.uuid"));
        } else
          goto handle_unusual;
        continue;
      // uint64 size = 13 [json_name = "size"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .tensors.Tensor tensor = 14 [json_name = "tensor"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_tensor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Artifact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Artifact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // .gooseai.ArtifactType type = 2 [json_name = "type"];
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // string mime = 3 [json_name = "mime"];
  if (!this->_internal_mime().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mime().data(), static_cast<int>(this->_internal_mime().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Artifact.mime");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_mime(), target);
  }

  // optional string magic = 4 [json_name = "magic"];
  if (_internal_has_magic()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_magic().data(), static_cast<int>(this->_internal_magic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Artifact.magic");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_magic(), target);
  }

  // bytes binary = 5 [json_name = "binary"];
  if (_internal_has_binary()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_binary(), target);
  }

  // string text = 6 [json_name = "text"];
  if (_internal_has_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Artifact.text");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_text(), target);
  }

  // .gooseai.Tokens tokens = 7 [json_name = "tokens"];
  if (_internal_has_tokens()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::tokens(this),
        _Internal::tokens(this).GetCachedSize(), target, stream);
  }

  // uint32 index = 8 [json_name = "index"];
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_index(), target);
  }

  // .gooseai.FinishReason finish_reason = 9 [json_name = "finishReason"];
  if (this->_internal_finish_reason() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_finish_reason(), target);
  }

  // uint32 seed = 10 [json_name = "seed"];
  if (this->_internal_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_seed(), target);
  }

  // .gooseai.ClassifierParameters classifier = 11 [json_name = "classifier"];
  if (_internal_has_classifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  // string uuid = 12 [json_name = "uuid"];
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Artifact.uuid");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_uuid(), target);
  }

  // uint64 size = 13 [json_name = "size"];
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_size(), target);
  }

  // .tensors.Tensor tensor = 14 [json_name = "tensor"];
  if (_internal_has_tensor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::tensor(this),
        _Internal::tensor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Artifact)
  return target;
}

size_t Artifact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Artifact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mime = 3 [json_name = "mime"];
  if (!this->_internal_mime().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mime());
  }

  // optional string magic = 4 [json_name = "magic"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_magic());
  }

  // string uuid = 12 [json_name = "uuid"];
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // uint64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // .gooseai.ArtifactType type = 2 [json_name = "type"];
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 index = 8 [json_name = "index"];
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  // .gooseai.FinishReason finish_reason = 9 [json_name = "finishReason"];
  if (this->_internal_finish_reason() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_finish_reason());
  }

  // uint32 seed = 10 [json_name = "seed"];
  if (this->_internal_seed() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seed());
  }

  // uint64 size = 13 [json_name = "size"];
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
  }

  switch (data_case()) {
    // bytes binary = 5 [json_name = "binary"];
    case kBinary: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_binary());
      break;
    }
    // string text = 6 [json_name = "text"];
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // .gooseai.Tokens tokens = 7 [json_name = "tokens"];
    case kTokens: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.tokens_);
      break;
    }
    // .gooseai.ClassifierParameters classifier = 11 [json_name = "classifier"];
    case kClassifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.classifier_);
      break;
    }
    // .tensors.Tensor tensor = 14 [json_name = "tensor"];
    case kTensor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.tensor_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Artifact::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Artifact::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Artifact::GetClassData() const { return &_class_data_; }


void Artifact::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Artifact*>(&to_msg);
  auto& from = static_cast<const Artifact&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Artifact)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mime().empty()) {
    _this->_internal_set_mime(from._internal_mime());
  }
  if (from._internal_has_magic()) {
    _this->_internal_set_magic(from._internal_magic());
  }
  if (!from._internal_uuid().empty()) {
    _this->_internal_set_uuid(from._internal_uuid());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  if (from._internal_finish_reason() != 0) {
    _this->_internal_set_finish_reason(from._internal_finish_reason());
  }
  if (from._internal_seed() != 0) {
    _this->_internal_set_seed(from._internal_seed());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  switch (from.data_case()) {
    case kBinary: {
      _this->_internal_set_binary(from._internal_binary());
      break;
    }
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case kTokens: {
      _this->_internal_mutable_tokens()->::gooseai::Tokens::MergeFrom(
          from._internal_tokens());
      break;
    }
    case kClassifier: {
      _this->_internal_mutable_classifier()->::gooseai::ClassifierParameters::MergeFrom(
          from._internal_classifier());
      break;
    }
    case kTensor: {
      _this->_internal_mutable_tensor()->::tensors::Tensor::MergeFrom(
          from._internal_tensor());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Artifact::CopyFrom(const Artifact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Artifact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Artifact::IsInitialized() const {
  return true;
}

void Artifact::InternalSwap(Artifact* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_, lhs_arena,
      &other->_impl_.mime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.magic_, lhs_arena,
      &other->_impl_.magic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Artifact, _impl_.size_)
      + sizeof(Artifact::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(Artifact, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Artifact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[2]);
}

// ===================================================================

class PromptParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptParameters>()._impl_._has_bits_);
  static void set_has_init(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PromptParameters::PromptParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.PromptParameters)
}
PromptParameters::PromptParameters(const PromptParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PromptParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.init_){}
    , decltype(_impl_.weight_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.init_, &from._impl_.init_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weight_) -
    reinterpret_cast<char*>(&_impl_.init_)) + sizeof(_impl_.weight_));
  // @@protoc_insertion_point(copy_constructor:gooseai.PromptParameters)
}

inline void PromptParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.init_){false}
    , decltype(_impl_.weight_){0}
  };
}

PromptParameters::~PromptParameters() {
  // @@protoc_insertion_point(destructor:gooseai.PromptParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PromptParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PromptParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.PromptParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.init_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weight_) -
        reinterpret_cast<char*>(&_impl_.init_)) + sizeof(_impl_.weight_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PromptParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool init = 1 [json_name = "init"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_init(&has_bits);
          _impl_.init_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float weight = 2 [json_name = "weight"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_weight(&has_bits);
          _impl_.weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.PromptParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool init = 1 [json_name = "init"];
  if (_internal_has_init()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_init(), target);
  }

  // optional float weight = 2 [json_name = "weight"];
  if (_internal_has_weight()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_weight(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.PromptParameters)
  return target;
}

size_t PromptParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.PromptParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool init = 1 [json_name = "init"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional float weight = 2 [json_name = "weight"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PromptParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PromptParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PromptParameters::GetClassData() const { return &_class_data_; }


void PromptParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PromptParameters*>(&to_msg);
  auto& from = static_cast<const PromptParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.PromptParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.init_ = from._impl_.init_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.weight_ = from._impl_.weight_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PromptParameters::CopyFrom(const PromptParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.PromptParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptParameters::IsInitialized() const {
  return true;
}

void PromptParameters::InternalSwap(PromptParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PromptParameters, _impl_.weight_)
      + sizeof(PromptParameters::_impl_.weight_)
      - PROTOBUF_FIELD_OFFSET(PromptParameters, _impl_.init_)>(
          reinterpret_cast<char*>(&_impl_.init_),
          reinterpret_cast<char*>(&other->_impl_.init_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PromptParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[3]);
}

// ===================================================================

class Prompt::_Internal {
 public:
  using HasBits = decltype(std::declval<Prompt>()._impl_._has_bits_);
  static const ::gooseai::PromptParameters& parameters(const Prompt* msg);
  static void set_has_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::Tokens& tokens(const Prompt* msg);
  static const ::gooseai::Artifact& artifact(const Prompt* msg);
};

const ::gooseai::PromptParameters&
Prompt::_Internal::parameters(const Prompt* msg) {
  return *msg->_impl_.parameters_;
}
const ::gooseai::Tokens&
Prompt::_Internal::tokens(const Prompt* msg) {
  return *msg->_impl_.prompt_.tokens_;
}
const ::gooseai::Artifact&
Prompt::_Internal::artifact(const Prompt* msg) {
  return *msg->_impl_.prompt_.artifact_;
}
void Prompt::set_allocated_tokens(::gooseai::Tokens* tokens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_prompt();
  if (tokens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokens);
    if (message_arena != submessage_arena) {
      tokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokens, submessage_arena);
    }
    set_has_tokens();
    _impl_.prompt_.tokens_ = tokens;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Prompt.tokens)
}
void Prompt::set_allocated_artifact(::gooseai::Artifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_prompt();
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    set_has_artifact();
    _impl_.prompt_.artifact_ = artifact;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Prompt.artifact)
}
Prompt::Prompt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Prompt)
}
Prompt::Prompt(const Prompt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Prompt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.prompt_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parameters()) {
    _this->_impl_.parameters_ = new ::gooseai::PromptParameters(*from._impl_.parameters_);
  }
  clear_has_prompt();
  switch (from.prompt_case()) {
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case kTokens: {
      _this->_internal_mutable_tokens()->::gooseai::Tokens::MergeFrom(
          from._internal_tokens());
      break;
    }
    case kArtifact: {
      _this->_internal_mutable_artifact()->::gooseai::Artifact::MergeFrom(
          from._internal_artifact());
      break;
    }
    case PROMPT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.Prompt)
}

inline void Prompt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parameters_){nullptr}
    , decltype(_impl_.prompt_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_prompt();
}

Prompt::~Prompt() {
  // @@protoc_insertion_point(destructor:gooseai.Prompt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Prompt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parameters_;
  if (has_prompt()) {
    clear_prompt();
  }
}

void Prompt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Prompt::clear_prompt() {
// @@protoc_insertion_point(one_of_clear_start:gooseai.Prompt)
  switch (prompt_case()) {
    case kText: {
      _impl_.prompt_.text_.Destroy();
      break;
    }
    case kTokens: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.prompt_.tokens_;
      }
      break;
    }
    case kArtifact: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.prompt_.artifact_;
      }
      break;
    }
    case PROMPT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROMPT_NOT_SET;
}


void Prompt::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Prompt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parameters_ != nullptr);
    _impl_.parameters_->Clear();
  }
  clear_prompt();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Prompt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .gooseai.PromptParameters parameters = 1 [json_name = "parameters"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 2 [json_name = "text"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Prompt.text"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Tokens tokens = 3 [json_name = "tokens"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokens(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Artifact artifact = 4 [json_name = "artifact"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Prompt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Prompt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .gooseai.PromptParameters parameters = 1 [json_name = "parameters"];
  if (_internal_has_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::parameters(this),
        _Internal::parameters(this).GetCachedSize(), target, stream);
  }

  // string text = 2 [json_name = "text"];
  if (_internal_has_text()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Prompt.text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text(), target);
  }

  // .gooseai.Tokens tokens = 3 [json_name = "tokens"];
  if (_internal_has_tokens()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tokens(this),
        _Internal::tokens(this).GetCachedSize(), target, stream);
  }

  // .gooseai.Artifact artifact = 4 [json_name = "artifact"];
  if (_internal_has_artifact()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::artifact(this),
        _Internal::artifact(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Prompt)
  return target;
}

size_t Prompt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Prompt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .gooseai.PromptParameters parameters = 1 [json_name = "parameters"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parameters_);
  }

  switch (prompt_case()) {
    // string text = 2 [json_name = "text"];
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // .gooseai.Tokens tokens = 3 [json_name = "tokens"];
    case kTokens: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prompt_.tokens_);
      break;
    }
    // .gooseai.Artifact artifact = 4 [json_name = "artifact"];
    case kArtifact: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prompt_.artifact_);
      break;
    }
    case PROMPT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Prompt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Prompt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Prompt::GetClassData() const { return &_class_data_; }


void Prompt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Prompt*>(&to_msg);
  auto& from = static_cast<const Prompt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Prompt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_parameters()) {
    _this->_internal_mutable_parameters()->::gooseai::PromptParameters::MergeFrom(
        from._internal_parameters());
  }
  switch (from.prompt_case()) {
    case kText: {
      _this->_internal_set_text(from._internal_text());
      break;
    }
    case kTokens: {
      _this->_internal_mutable_tokens()->::gooseai::Tokens::MergeFrom(
          from._internal_tokens());
      break;
    }
    case kArtifact: {
      _this->_internal_mutable_artifact()->::gooseai::Artifact::MergeFrom(
          from._internal_artifact());
      break;
    }
    case PROMPT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Prompt::CopyFrom(const Prompt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Prompt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Prompt::IsInitialized() const {
  return true;
}

void Prompt::InternalSwap(Prompt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.parameters_, other->_impl_.parameters_);
  swap(_impl_.prompt_, other->_impl_.prompt_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Prompt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[4]);
}

// ===================================================================

class SamplerParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<SamplerParameters>()._impl_._has_bits_);
  static void set_has_eta(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sampling_steps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latent_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_downsampling_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cfg_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_init_noise_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_step_noise_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SamplerParameters::SamplerParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.SamplerParameters)
}
SamplerParameters::SamplerParameters(const SamplerParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SamplerParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sampling_steps_){}
    , decltype(_impl_.latent_channels_){}
    , decltype(_impl_.eta_){}
    , decltype(_impl_.cfg_scale_){}
    , decltype(_impl_.downsampling_factor_){}
    , decltype(_impl_.init_noise_scale_){}
    , decltype(_impl_.step_noise_scale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sampling_steps_, &from._impl_.sampling_steps_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.step_noise_scale_) -
    reinterpret_cast<char*>(&_impl_.sampling_steps_)) + sizeof(_impl_.step_noise_scale_));
  // @@protoc_insertion_point(copy_constructor:gooseai.SamplerParameters)
}

inline void SamplerParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sampling_steps_){uint64_t{0u}}
    , decltype(_impl_.latent_channels_){uint64_t{0u}}
    , decltype(_impl_.eta_){0}
    , decltype(_impl_.cfg_scale_){0}
    , decltype(_impl_.downsampling_factor_){uint64_t{0u}}
    , decltype(_impl_.init_noise_scale_){0}
    , decltype(_impl_.step_noise_scale_){0}
  };
}

SamplerParameters::~SamplerParameters() {
  // @@protoc_insertion_point(destructor:gooseai.SamplerParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SamplerParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SamplerParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SamplerParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.SamplerParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.sampling_steps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.step_noise_scale_) -
        reinterpret_cast<char*>(&_impl_.sampling_steps_)) + sizeof(_impl_.step_noise_scale_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SamplerParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float eta = 1 [json_name = "eta"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_eta(&has_bits);
          _impl_.eta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 sampling_steps = 2 [json_name = "samplingSteps"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sampling_steps(&has_bits);
          _impl_.sampling_steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 latent_channels = 3 [json_name = "latentChannels"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_latent_channels(&has_bits);
          _impl_.latent_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 downsampling_factor = 4 [json_name = "downsamplingFactor"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_downsampling_factor(&has_bits);
          _impl_.downsampling_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cfg_scale = 5 [json_name = "cfgScale"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_cfg_scale(&has_bits);
          _impl_.cfg_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float init_noise_scale = 6 [json_name = "initNoiseScale"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_init_noise_scale(&has_bits);
          _impl_.init_noise_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float step_noise_scale = 7 [json_name = "stepNoiseScale"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_step_noise_scale(&has_bits);
          _impl_.step_noise_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SamplerParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.SamplerParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float eta = 1 [json_name = "eta"];
  if (_internal_has_eta()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_eta(), target);
  }

  // optional uint64 sampling_steps = 2 [json_name = "samplingSteps"];
  if (_internal_has_sampling_steps()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sampling_steps(), target);
  }

  // optional uint64 latent_channels = 3 [json_name = "latentChannels"];
  if (_internal_has_latent_channels()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_latent_channels(), target);
  }

  // optional uint64 downsampling_factor = 4 [json_name = "downsamplingFactor"];
  if (_internal_has_downsampling_factor()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_downsampling_factor(), target);
  }

  // optional float cfg_scale = 5 [json_name = "cfgScale"];
  if (_internal_has_cfg_scale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_cfg_scale(), target);
  }

  // optional float init_noise_scale = 6 [json_name = "initNoiseScale"];
  if (_internal_has_init_noise_scale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_init_noise_scale(), target);
  }

  // optional float step_noise_scale = 7 [json_name = "stepNoiseScale"];
  if (_internal_has_step_noise_scale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_step_noise_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.SamplerParameters)
  return target;
}

size_t SamplerParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.SamplerParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 sampling_steps = 2 [json_name = "samplingSteps"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sampling_steps());
    }

    // optional uint64 latent_channels = 3 [json_name = "latentChannels"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_latent_channels());
    }

    // optional float eta = 1 [json_name = "eta"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float cfg_scale = 5 [json_name = "cfgScale"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint64 downsampling_factor = 4 [json_name = "downsamplingFactor"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_downsampling_factor());
    }

    // optional float init_noise_scale = 6 [json_name = "initNoiseScale"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float step_noise_scale = 7 [json_name = "stepNoiseScale"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SamplerParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SamplerParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SamplerParameters::GetClassData() const { return &_class_data_; }


void SamplerParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SamplerParameters*>(&to_msg);
  auto& from = static_cast<const SamplerParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.SamplerParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sampling_steps_ = from._impl_.sampling_steps_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latent_channels_ = from._impl_.latent_channels_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.eta_ = from._impl_.eta_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cfg_scale_ = from._impl_.cfg_scale_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.downsampling_factor_ = from._impl_.downsampling_factor_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.init_noise_scale_ = from._impl_.init_noise_scale_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.step_noise_scale_ = from._impl_.step_noise_scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SamplerParameters::CopyFrom(const SamplerParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.SamplerParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SamplerParameters::IsInitialized() const {
  return true;
}

void SamplerParameters::InternalSwap(SamplerParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SamplerParameters, _impl_.step_noise_scale_)
      + sizeof(SamplerParameters::_impl_.step_noise_scale_)
      - PROTOBUF_FIELD_OFFSET(SamplerParameters, _impl_.sampling_steps_)>(
          reinterpret_cast<char*>(&_impl_.sampling_steps_),
          reinterpret_cast<char*>(&other->_impl_.sampling_steps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SamplerParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[5]);
}

// ===================================================================

class ConditionerParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ConditionerParameters>()._impl_._has_bits_);
  static void set_has_vector_adjust_prior(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::Model& conditioner(const ConditionerParameters* msg);
  static void set_has_conditioner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gooseai::Model&
ConditionerParameters::_Internal::conditioner(const ConditionerParameters* msg) {
  return *msg->_impl_.conditioner_;
}
ConditionerParameters::ConditionerParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ConditionerParameters)
}
ConditionerParameters::ConditionerParameters(const ConditionerParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConditionerParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vector_adjust_prior_){}
    , decltype(_impl_.conditioner_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vector_adjust_prior_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vector_adjust_prior_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vector_adjust_prior()) {
    _this->_impl_.vector_adjust_prior_.Set(from._internal_vector_adjust_prior(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_conditioner()) {
    _this->_impl_.conditioner_ = new ::gooseai::Model(*from._impl_.conditioner_);
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.ConditionerParameters)
}

inline void ConditionerParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vector_adjust_prior_){}
    , decltype(_impl_.conditioner_){nullptr}
  };
  _impl_.vector_adjust_prior_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vector_adjust_prior_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConditionerParameters::~ConditionerParameters() {
  // @@protoc_insertion_point(destructor:gooseai.ConditionerParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConditionerParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vector_adjust_prior_.Destroy();
  if (this != internal_default_instance()) delete _impl_.conditioner_;
}

void ConditionerParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConditionerParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ConditionerParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vector_adjust_prior_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.conditioner_ != nullptr);
      _impl_.conditioner_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConditionerParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string vector_adjust_prior = 1 [json_name = "vectorAdjustPrior"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vector_adjust_prior();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ConditionerParameters.vector_adjust_prior"));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.Model conditioner = 2 [json_name = "conditioner"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditioner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConditionerParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ConditionerParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string vector_adjust_prior = 1 [json_name = "vectorAdjustPrior"];
  if (_internal_has_vector_adjust_prior()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vector_adjust_prior().data(), static_cast<int>(this->_internal_vector_adjust_prior().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ConditionerParameters.vector_adjust_prior");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vector_adjust_prior(), target);
  }

  // optional .gooseai.Model conditioner = 2 [json_name = "conditioner"];
  if (_internal_has_conditioner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::conditioner(this),
        _Internal::conditioner(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ConditionerParameters)
  return target;
}

size_t ConditionerParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ConditionerParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string vector_adjust_prior = 1 [json_name = "vectorAdjustPrior"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vector_adjust_prior());
    }

    // optional .gooseai.Model conditioner = 2 [json_name = "conditioner"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditioner_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConditionerParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConditionerParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConditionerParameters::GetClassData() const { return &_class_data_; }


void ConditionerParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConditionerParameters*>(&to_msg);
  auto& from = static_cast<const ConditionerParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ConditionerParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vector_adjust_prior(from._internal_vector_adjust_prior());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_conditioner()->::gooseai::Model::MergeFrom(
          from._internal_conditioner());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConditionerParameters::CopyFrom(const ConditionerParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ConditionerParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionerParameters::IsInitialized() const {
  return true;
}

void ConditionerParameters::InternalSwap(ConditionerParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vector_adjust_prior_, lhs_arena,
      &other->_impl_.vector_adjust_prior_, rhs_arena
  );
  swap(_impl_.conditioner_, other->_impl_.conditioner_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConditionerParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[6]);
}

// ===================================================================

class ScheduleParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ScheduleParameters>()._impl_._has_bits_);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ScheduleParameters::ScheduleParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ScheduleParameters)
}
ScheduleParameters::ScheduleParameters(const ScheduleParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScheduleParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){}
    , decltype(_impl_.end_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_, &from._impl_.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:gooseai.ScheduleParameters)
}

inline void ScheduleParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){0}
    , decltype(_impl_.end_){0}
    , decltype(_impl_.value_){0}
  };
}

ScheduleParameters::~ScheduleParameters() {
  // @@protoc_insertion_point(destructor:gooseai.ScheduleParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScheduleParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScheduleParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScheduleParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ScheduleParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScheduleParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float start = 1 [json_name = "start"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float end = 2 [json_name = "end"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float value = 3 [json_name = "value"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScheduleParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ScheduleParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float start = 1 [json_name = "start"];
  if (_internal_has_start()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_start(), target);
  }

  // optional float end = 2 [json_name = "end"];
  if (_internal_has_end()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_end(), target);
  }

  // optional float value = 3 [json_name = "value"];
  if (_internal_has_value()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ScheduleParameters)
  return target;
}

size_t ScheduleParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ScheduleParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float start = 1 [json_name = "start"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float end = 2 [json_name = "end"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float value = 3 [json_name = "value"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScheduleParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScheduleParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScheduleParameters::GetClassData() const { return &_class_data_; }


void ScheduleParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScheduleParameters*>(&to_msg);
  auto& from = static_cast<const ScheduleParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ScheduleParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScheduleParameters::CopyFrom(const ScheduleParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ScheduleParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScheduleParameters::IsInitialized() const {
  return true;
}

void ScheduleParameters::InternalSwap(ScheduleParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScheduleParameters, _impl_.value_)
      + sizeof(ScheduleParameters::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(ScheduleParameters, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScheduleParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[7]);
}

// ===================================================================

class StepParameter::_Internal {
 public:
  using HasBits = decltype(std::declval<StepParameter>()._impl_._has_bits_);
  static const ::gooseai::SamplerParameters& sampler(const StepParameter* msg);
  static void set_has_sampler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::ScheduleParameters& schedule(const StepParameter* msg);
  static void set_has_schedule(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::gooseai::GuidanceParameters& guidance(const StepParameter* msg);
  static void set_has_guidance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::gooseai::SamplerParameters&
StepParameter::_Internal::sampler(const StepParameter* msg) {
  return *msg->_impl_.sampler_;
}
const ::gooseai::ScheduleParameters&
StepParameter::_Internal::schedule(const StepParameter* msg) {
  return *msg->_impl_.schedule_;
}
const ::gooseai::GuidanceParameters&
StepParameter::_Internal::guidance(const StepParameter* msg) {
  return *msg->_impl_.guidance_;
}
StepParameter::StepParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.StepParameter)
}
StepParameter::StepParameter(const StepParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StepParameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sampler_){nullptr}
    , decltype(_impl_.schedule_){nullptr}
    , decltype(_impl_.guidance_){nullptr}
    , decltype(_impl_.scaled_step_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sampler()) {
    _this->_impl_.sampler_ = new ::gooseai::SamplerParameters(*from._impl_.sampler_);
  }
  if (from._internal_has_schedule()) {
    _this->_impl_.schedule_ = new ::gooseai::ScheduleParameters(*from._impl_.schedule_);
  }
  if (from._internal_has_guidance()) {
    _this->_impl_.guidance_ = new ::gooseai::GuidanceParameters(*from._impl_.guidance_);
  }
  _this->_impl_.scaled_step_ = from._impl_.scaled_step_;
  // @@protoc_insertion_point(copy_constructor:gooseai.StepParameter)
}

inline void StepParameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sampler_){nullptr}
    , decltype(_impl_.schedule_){nullptr}
    , decltype(_impl_.guidance_){nullptr}
    , decltype(_impl_.scaled_step_){0}
  };
}

StepParameter::~StepParameter() {
  // @@protoc_insertion_point(destructor:gooseai.StepParameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StepParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sampler_;
  if (this != internal_default_instance()) delete _impl_.schedule_;
  if (this != internal_default_instance()) delete _impl_.guidance_;
}

void StepParameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StepParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.StepParameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sampler_ != nullptr);
      _impl_.sampler_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.schedule_ != nullptr);
      _impl_.schedule_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.guidance_ != nullptr);
      _impl_.guidance_->Clear();
    }
  }
  _impl_.scaled_step_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StepParameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float scaled_step = 1 [json_name = "scaledStep"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.scaled_step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.SamplerParameters sampler = 2 [json_name = "sampler"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sampler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ScheduleParameters schedule = 3 [json_name = "schedule"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_schedule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.GuidanceParameters guidance = 4 [json_name = "guidance"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_guidance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StepParameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.StepParameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float scaled_step = 1 [json_name = "scaledStep"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scaled_step = this->_internal_scaled_step();
  uint32_t raw_scaled_step;
  memcpy(&raw_scaled_step, &tmp_scaled_step, sizeof(tmp_scaled_step));
  if (raw_scaled_step != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_scaled_step(), target);
  }

  // optional .gooseai.SamplerParameters sampler = 2 [json_name = "sampler"];
  if (_internal_has_sampler()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sampler(this),
        _Internal::sampler(this).GetCachedSize(), target, stream);
  }

  // optional .gooseai.ScheduleParameters schedule = 3 [json_name = "schedule"];
  if (_internal_has_schedule()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::schedule(this),
        _Internal::schedule(this).GetCachedSize(), target, stream);
  }

  // optional .gooseai.GuidanceParameters guidance = 4 [json_name = "guidance"];
  if (_internal_has_guidance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::guidance(this),
        _Internal::guidance(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.StepParameter)
  return target;
}

size_t StepParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.StepParameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .gooseai.SamplerParameters sampler = 2 [json_name = "sampler"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sampler_);
    }

    // optional .gooseai.ScheduleParameters schedule = 3 [json_name = "schedule"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.schedule_);
    }

    // optional .gooseai.GuidanceParameters guidance = 4 [json_name = "guidance"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.guidance_);
    }

  }
  // float scaled_step = 1 [json_name = "scaledStep"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scaled_step = this->_internal_scaled_step();
  uint32_t raw_scaled_step;
  memcpy(&raw_scaled_step, &tmp_scaled_step, sizeof(tmp_scaled_step));
  if (raw_scaled_step != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StepParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StepParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StepParameter::GetClassData() const { return &_class_data_; }


void StepParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StepParameter*>(&to_msg);
  auto& from = static_cast<const StepParameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.StepParameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sampler()->::gooseai::SamplerParameters::MergeFrom(
          from._internal_sampler());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_schedule()->::gooseai::ScheduleParameters::MergeFrom(
          from._internal_schedule());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_guidance()->::gooseai::GuidanceParameters::MergeFrom(
          from._internal_guidance());
    }
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_scaled_step = from._internal_scaled_step();
  uint32_t raw_scaled_step;
  memcpy(&raw_scaled_step, &tmp_scaled_step, sizeof(tmp_scaled_step));
  if (raw_scaled_step != 0) {
    _this->_internal_set_scaled_step(from._internal_scaled_step());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StepParameter::CopyFrom(const StepParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.StepParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepParameter::IsInitialized() const {
  return true;
}

void StepParameter::InternalSwap(StepParameter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StepParameter, _impl_.scaled_step_)
      + sizeof(StepParameter::_impl_.scaled_step_)
      - PROTOBUF_FIELD_OFFSET(StepParameter, _impl_.sampler_)>(
          reinterpret_cast<char*>(&_impl_.sampler_),
          reinterpret_cast<char*>(&other->_impl_.sampler_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StepParameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[8]);
}

// ===================================================================

class Model::_Internal {
 public:
};

Model::Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Model)
}
Model::Model(const Model& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Model* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.publisher_){}
    , decltype(_impl_.dataset_){}
    , decltype(_impl_.semantic_version_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.architecture_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.publisher_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publisher_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_publisher().empty()) {
    _this->_impl_.publisher_.Set(from._internal_publisher(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dataset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dataset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dataset().empty()) {
    _this->_impl_.dataset_.Set(from._internal_dataset(), 
      _this->GetArenaForAllocation());
  }
  _impl_.semantic_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.semantic_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_semantic_version().empty()) {
    _this->_impl_.semantic_version_.Set(from._internal_semantic_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.architecture_, &from._impl_.architecture_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.architecture_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:gooseai.Model)
}

inline void Model::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.publisher_){}
    , decltype(_impl_.dataset_){}
    , decltype(_impl_.semantic_version_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.architecture_){0}
    , decltype(_impl_.version_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.publisher_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.publisher_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dataset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dataset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.semantic_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.semantic_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Model::~Model() {
  // @@protoc_insertion_point(destructor:gooseai.Model)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Model::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.publisher_.Destroy();
  _impl_.dataset_.Destroy();
  _impl_.semantic_version_.Destroy();
  _impl_.alias_.Destroy();
}

void Model::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Model::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Model)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.publisher_.ClearToEmpty();
  _impl_.dataset_.ClearToEmpty();
  _impl_.semantic_version_.ClearToEmpty();
  _impl_.alias_.ClearToEmpty();
  ::memset(&_impl_.architecture_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.version_) -
      reinterpret_cast<char*>(&_impl_.architecture_)) + sizeof(_impl_.version_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Model::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gooseai.ModelArchitecture architecture = 1 [json_name = "architecture"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_architecture(static_cast<::gooseai::ModelArchitecture>(val));
        } else
          goto handle_unusual;
        continue;
      // string publisher = 2 [json_name = "publisher"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_publisher();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Model.publisher"));
        } else
          goto handle_unusual;
        continue;
      // string dataset = 3 [json_name = "dataset"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dataset();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Model.dataset"));
        } else
          goto handle_unusual;
        continue;
      // float version = 4 [json_name = "version"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string semantic_version = 5 [json_name = "semanticVersion"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_semantic_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Model.semantic_version"));
        } else
          goto handle_unusual;
        continue;
      // string alias = 6 [json_name = "alias"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Model.alias"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Model::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Model)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gooseai.ModelArchitecture architecture = 1 [json_name = "architecture"];
  if (this->_internal_architecture() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_architecture(), target);
  }

  // string publisher = 2 [json_name = "publisher"];
  if (!this->_internal_publisher().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_publisher().data(), static_cast<int>(this->_internal_publisher().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Model.publisher");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_publisher(), target);
  }

  // string dataset = 3 [json_name = "dataset"];
  if (!this->_internal_dataset().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dataset().data(), static_cast<int>(this->_internal_dataset().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Model.dataset");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dataset(), target);
  }

  // float version = 4 [json_name = "version"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_version = this->_internal_version();
  uint32_t raw_version;
  memcpy(&raw_version, &tmp_version, sizeof(tmp_version));
  if (raw_version != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_version(), target);
  }

  // string semantic_version = 5 [json_name = "semanticVersion"];
  if (!this->_internal_semantic_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_semantic_version().data(), static_cast<int>(this->_internal_semantic_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Model.semantic_version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_semantic_version(), target);
  }

  // string alias = 6 [json_name = "alias"];
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Model.alias");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_alias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Model)
  return target;
}

size_t Model::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Model)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string publisher = 2 [json_name = "publisher"];
  if (!this->_internal_publisher().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publisher());
  }

  // string dataset = 3 [json_name = "dataset"];
  if (!this->_internal_dataset().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dataset());
  }

  // string semantic_version = 5 [json_name = "semanticVersion"];
  if (!this->_internal_semantic_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_semantic_version());
  }

  // string alias = 6 [json_name = "alias"];
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // .gooseai.ModelArchitecture architecture = 1 [json_name = "architecture"];
  if (this->_internal_architecture() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_architecture());
  }

  // float version = 4 [json_name = "version"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_version = this->_internal_version();
  uint32_t raw_version;
  memcpy(&raw_version, &tmp_version, sizeof(tmp_version));
  if (raw_version != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Model::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Model::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Model::GetClassData() const { return &_class_data_; }


void Model::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Model*>(&to_msg);
  auto& from = static_cast<const Model&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Model)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_publisher().empty()) {
    _this->_internal_set_publisher(from._internal_publisher());
  }
  if (!from._internal_dataset().empty()) {
    _this->_internal_set_dataset(from._internal_dataset());
  }
  if (!from._internal_semantic_version().empty()) {
    _this->_internal_set_semantic_version(from._internal_semantic_version());
  }
  if (!from._internal_alias().empty()) {
    _this->_internal_set_alias(from._internal_alias());
  }
  if (from._internal_architecture() != 0) {
    _this->_internal_set_architecture(from._internal_architecture());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_version = from._internal_version();
  uint32_t raw_version;
  memcpy(&raw_version, &tmp_version, sizeof(tmp_version));
  if (raw_version != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Model::CopyFrom(const Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  return true;
}

void Model::InternalSwap(Model* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.publisher_, lhs_arena,
      &other->_impl_.publisher_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dataset_, lhs_arena,
      &other->_impl_.dataset_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.semantic_version_, lhs_arena,
      &other->_impl_.semantic_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Model, _impl_.version_)
      + sizeof(Model::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(Model, _impl_.architecture_)>(
          reinterpret_cast<char*>(&_impl_.architecture_),
          reinterpret_cast<char*>(&other->_impl_.architecture_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Model::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[9]);
}

// ===================================================================

class CutoutParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<CutoutParameters>()._impl_._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gray(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blur(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size_power(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CutoutParameters::CutoutParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.CutoutParameters)
}
CutoutParameters::CutoutParameters(const CutoutParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CutoutParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cutouts_){from._impl_.cutouts_}
    , decltype(_impl_.count_){}
    , decltype(_impl_.gray_){}
    , decltype(_impl_.blur_){}
    , decltype(_impl_.size_power_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.count_, &from._impl_.count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_power_) -
    reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.size_power_));
  // @@protoc_insertion_point(copy_constructor:gooseai.CutoutParameters)
}

inline void CutoutParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cutouts_){arena}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.gray_){0}
    , decltype(_impl_.blur_){0}
    , decltype(_impl_.size_power_){0}
  };
}

CutoutParameters::~CutoutParameters() {
  // @@protoc_insertion_point(destructor:gooseai.CutoutParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CutoutParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cutouts_.~RepeatedPtrField();
}

void CutoutParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CutoutParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.CutoutParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cutouts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_power_) -
        reinterpret_cast<char*>(&_impl_.count_)) + sizeof(_impl_.size_power_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CutoutParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.CutoutParameters cutouts = 1 [json_name = "cutouts"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cutouts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2 [json_name = "count"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float gray = 3 [json_name = "gray"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_gray(&has_bits);
          _impl_.gray_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float blur = 4 [json_name = "blur"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_blur(&has_bits);
          _impl_.blur_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float size_power = 5 [json_name = "sizePower"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_size_power(&has_bits);
          _impl_.size_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CutoutParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.CutoutParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.CutoutParameters cutouts = 1 [json_name = "cutouts"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cutouts_size()); i < n; i++) {
    const auto& repfield = this->_internal_cutouts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 count = 2 [json_name = "count"];
  if (_internal_has_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // optional float gray = 3 [json_name = "gray"];
  if (_internal_has_gray()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_gray(), target);
  }

  // optional float blur = 4 [json_name = "blur"];
  if (_internal_has_blur()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_blur(), target);
  }

  // optional float size_power = 5 [json_name = "sizePower"];
  if (_internal_has_size_power()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_size_power(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.CutoutParameters)
  return target;
}

size_t CutoutParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.CutoutParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.CutoutParameters cutouts = 1 [json_name = "cutouts"];
  total_size += 1UL * this->_internal_cutouts_size();
  for (const auto& msg : this->_impl_.cutouts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 count = 2 [json_name = "count"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional float gray = 3 [json_name = "gray"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float blur = 4 [json_name = "blur"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float size_power = 5 [json_name = "sizePower"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CutoutParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CutoutParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CutoutParameters::GetClassData() const { return &_class_data_; }


void CutoutParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CutoutParameters*>(&to_msg);
  auto& from = static_cast<const CutoutParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.CutoutParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cutouts_.MergeFrom(from._impl_.cutouts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gray_ = from._impl_.gray_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blur_ = from._impl_.blur_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_power_ = from._impl_.size_power_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CutoutParameters::CopyFrom(const CutoutParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.CutoutParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CutoutParameters::IsInitialized() const {
  return true;
}

void CutoutParameters::InternalSwap(CutoutParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cutouts_.InternalSwap(&other->_impl_.cutouts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CutoutParameters, _impl_.size_power_)
      + sizeof(CutoutParameters::_impl_.size_power_)
      - PROTOBUF_FIELD_OFFSET(CutoutParameters, _impl_.count_)>(
          reinterpret_cast<char*>(&_impl_.count_),
          reinterpret_cast<char*>(&other->_impl_.count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CutoutParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[10]);
}

// ===================================================================

class GuidanceScheduleParameters::_Internal {
 public:
};

GuidanceScheduleParameters::GuidanceScheduleParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.GuidanceScheduleParameters)
}
GuidanceScheduleParameters::GuidanceScheduleParameters(const GuidanceScheduleParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuidanceScheduleParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.duration_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.duration_, &from._impl_.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:gooseai.GuidanceScheduleParameters)
}

inline void GuidanceScheduleParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.duration_){0}
    , decltype(_impl_.value_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GuidanceScheduleParameters::~GuidanceScheduleParameters() {
  // @@protoc_insertion_point(destructor:gooseai.GuidanceScheduleParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuidanceScheduleParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GuidanceScheduleParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuidanceScheduleParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.GuidanceScheduleParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuidanceScheduleParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float duration = 1 [json_name = "duration"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float value = 2 [json_name = "value"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuidanceScheduleParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.GuidanceScheduleParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float duration = 1 [json_name = "duration"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration = this->_internal_duration();
  uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_duration(), target);
  }

  // float value = 2 [json_name = "value"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.GuidanceScheduleParameters)
  return target;
}

size_t GuidanceScheduleParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.GuidanceScheduleParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float duration = 1 [json_name = "duration"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration = this->_internal_duration();
  uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    total_size += 1 + 4;
  }

  // float value = 2 [json_name = "value"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = this->_internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuidanceScheduleParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuidanceScheduleParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuidanceScheduleParameters::GetClassData() const { return &_class_data_; }


void GuidanceScheduleParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuidanceScheduleParameters*>(&to_msg);
  auto& from = static_cast<const GuidanceScheduleParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.GuidanceScheduleParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration = from._internal_duration();
  uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_value = from._internal_value();
  uint32_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuidanceScheduleParameters::CopyFrom(const GuidanceScheduleParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.GuidanceScheduleParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuidanceScheduleParameters::IsInitialized() const {
  return true;
}

void GuidanceScheduleParameters::InternalSwap(GuidanceScheduleParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GuidanceScheduleParameters, _impl_.value_)
      + sizeof(GuidanceScheduleParameters::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(GuidanceScheduleParameters, _impl_.duration_)>(
          reinterpret_cast<char*>(&_impl_.duration_),
          reinterpret_cast<char*>(&other->_impl_.duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GuidanceScheduleParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[11]);
}

// ===================================================================

class GuidanceInstanceParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<GuidanceInstanceParameters>()._impl_._has_bits_);
  static void set_has_guidance_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::gooseai::CutoutParameters& cutouts(const GuidanceInstanceParameters* msg);
  static void set_has_cutouts(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::gooseai::Prompt& prompt(const GuidanceInstanceParameters* msg);
  static void set_has_prompt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::gooseai::CutoutParameters&
GuidanceInstanceParameters::_Internal::cutouts(const GuidanceInstanceParameters* msg) {
  return *msg->_impl_.cutouts_;
}
const ::gooseai::Prompt&
GuidanceInstanceParameters::_Internal::prompt(const GuidanceInstanceParameters* msg) {
  return *msg->_impl_.prompt_;
}
GuidanceInstanceParameters::GuidanceInstanceParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.GuidanceInstanceParameters)
}
GuidanceInstanceParameters::GuidanceInstanceParameters(const GuidanceInstanceParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuidanceInstanceParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.models_){from._impl_.models_}
    , decltype(_impl_.schedule_){from._impl_.schedule_}
    , decltype(_impl_.cutouts_){nullptr}
    , decltype(_impl_.prompt_){nullptr}
    , decltype(_impl_.guidance_strength_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cutouts()) {
    _this->_impl_.cutouts_ = new ::gooseai::CutoutParameters(*from._impl_.cutouts_);
  }
  if (from._internal_has_prompt()) {
    _this->_impl_.prompt_ = new ::gooseai::Prompt(*from._impl_.prompt_);
  }
  _this->_impl_.guidance_strength_ = from._impl_.guidance_strength_;
  // @@protoc_insertion_point(copy_constructor:gooseai.GuidanceInstanceParameters)
}

inline void GuidanceInstanceParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.models_){arena}
    , decltype(_impl_.schedule_){arena}
    , decltype(_impl_.cutouts_){nullptr}
    , decltype(_impl_.prompt_){nullptr}
    , decltype(_impl_.guidance_strength_){0}
  };
}

GuidanceInstanceParameters::~GuidanceInstanceParameters() {
  // @@protoc_insertion_point(destructor:gooseai.GuidanceInstanceParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuidanceInstanceParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.models_.~RepeatedPtrField();
  _impl_.schedule_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.cutouts_;
  if (this != internal_default_instance()) delete _impl_.prompt_;
}

void GuidanceInstanceParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuidanceInstanceParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.GuidanceInstanceParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.models_.Clear();
  _impl_.schedule_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cutouts_ != nullptr);
      _impl_.cutouts_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.prompt_ != nullptr);
      _impl_.prompt_->Clear();
    }
  }
  _impl_.guidance_strength_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuidanceInstanceParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.Model models = 2 [json_name = "models"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_models(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float guidance_strength = 3 [json_name = "guidanceStrength"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_guidance_strength(&has_bits);
          _impl_.guidance_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.GuidanceScheduleParameters schedule = 4 [json_name = "schedule"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_schedule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.CutoutParameters cutouts = 5 [json_name = "cutouts"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cutouts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.Prompt prompt = 6 [json_name = "prompt"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_prompt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuidanceInstanceParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.GuidanceInstanceParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.Model models = 2 [json_name = "models"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_models_size()); i < n; i++) {
    const auto& repfield = this->_internal_models(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float guidance_strength = 3 [json_name = "guidanceStrength"];
  if (_internal_has_guidance_strength()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_guidance_strength(), target);
  }

  // repeated .gooseai.GuidanceScheduleParameters schedule = 4 [json_name = "schedule"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_schedule_size()); i < n; i++) {
    const auto& repfield = this->_internal_schedule(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .gooseai.CutoutParameters cutouts = 5 [json_name = "cutouts"];
  if (_internal_has_cutouts()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cutouts(this),
        _Internal::cutouts(this).GetCachedSize(), target, stream);
  }

  // optional .gooseai.Prompt prompt = 6 [json_name = "prompt"];
  if (_internal_has_prompt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::prompt(this),
        _Internal::prompt(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.GuidanceInstanceParameters)
  return target;
}

size_t GuidanceInstanceParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.GuidanceInstanceParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.Model models = 2 [json_name = "models"];
  total_size += 1UL * this->_internal_models_size();
  for (const auto& msg : this->_impl_.models_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gooseai.GuidanceScheduleParameters schedule = 4 [json_name = "schedule"];
  total_size += 1UL * this->_internal_schedule_size();
  for (const auto& msg : this->_impl_.schedule_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .gooseai.CutoutParameters cutouts = 5 [json_name = "cutouts"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cutouts_);
    }

    // optional .gooseai.Prompt prompt = 6 [json_name = "prompt"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prompt_);
    }

    // optional float guidance_strength = 3 [json_name = "guidanceStrength"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuidanceInstanceParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuidanceInstanceParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuidanceInstanceParameters::GetClassData() const { return &_class_data_; }


void GuidanceInstanceParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuidanceInstanceParameters*>(&to_msg);
  auto& from = static_cast<const GuidanceInstanceParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.GuidanceInstanceParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.models_.MergeFrom(from._impl_.models_);
  _this->_impl_.schedule_.MergeFrom(from._impl_.schedule_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cutouts()->::gooseai::CutoutParameters::MergeFrom(
          from._internal_cutouts());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_prompt()->::gooseai::Prompt::MergeFrom(
          from._internal_prompt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.guidance_strength_ = from._impl_.guidance_strength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuidanceInstanceParameters::CopyFrom(const GuidanceInstanceParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.GuidanceInstanceParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuidanceInstanceParameters::IsInitialized() const {
  return true;
}

void GuidanceInstanceParameters::InternalSwap(GuidanceInstanceParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.models_.InternalSwap(&other->_impl_.models_);
  _impl_.schedule_.InternalSwap(&other->_impl_.schedule_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GuidanceInstanceParameters, _impl_.guidance_strength_)
      + sizeof(GuidanceInstanceParameters::_impl_.guidance_strength_)
      - PROTOBUF_FIELD_OFFSET(GuidanceInstanceParameters, _impl_.cutouts_)>(
          reinterpret_cast<char*>(&_impl_.cutouts_),
          reinterpret_cast<char*>(&other->_impl_.cutouts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GuidanceInstanceParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[12]);
}

// ===================================================================

class GuidanceParameters::_Internal {
 public:
};

GuidanceParameters::GuidanceParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.GuidanceParameters)
}
GuidanceParameters::GuidanceParameters(const GuidanceParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuidanceParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.instances_){from._impl_.instances_}
    , decltype(_impl_.guidance_preset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.guidance_preset_ = from._impl_.guidance_preset_;
  // @@protoc_insertion_point(copy_constructor:gooseai.GuidanceParameters)
}

inline void GuidanceParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.instances_){arena}
    , decltype(_impl_.guidance_preset_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GuidanceParameters::~GuidanceParameters() {
  // @@protoc_insertion_point(destructor:gooseai.GuidanceParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuidanceParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.instances_.~RepeatedPtrField();
}

void GuidanceParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuidanceParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.GuidanceParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.instances_.Clear();
  _impl_.guidance_preset_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuidanceParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gooseai.GuidancePreset guidance_preset = 1 [json_name = "guidancePreset"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_guidance_preset(static_cast<::gooseai::GuidancePreset>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.GuidanceInstanceParameters instances = 2 [json_name = "instances"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuidanceParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.GuidanceParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gooseai.GuidancePreset guidance_preset = 1 [json_name = "guidancePreset"];
  if (this->_internal_guidance_preset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_guidance_preset(), target);
  }

  // repeated .gooseai.GuidanceInstanceParameters instances = 2 [json_name = "instances"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_instances_size()); i < n; i++) {
    const auto& repfield = this->_internal_instances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.GuidanceParameters)
  return target;
}

size_t GuidanceParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.GuidanceParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.GuidanceInstanceParameters instances = 2 [json_name = "instances"];
  total_size += 1UL * this->_internal_instances_size();
  for (const auto& msg : this->_impl_.instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gooseai.GuidancePreset guidance_preset = 1 [json_name = "guidancePreset"];
  if (this->_internal_guidance_preset() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_guidance_preset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuidanceParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuidanceParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuidanceParameters::GetClassData() const { return &_class_data_; }


void GuidanceParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuidanceParameters*>(&to_msg);
  auto& from = static_cast<const GuidanceParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.GuidanceParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.instances_.MergeFrom(from._impl_.instances_);
  if (from._internal_guidance_preset() != 0) {
    _this->_internal_set_guidance_preset(from._internal_guidance_preset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuidanceParameters::CopyFrom(const GuidanceParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.GuidanceParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuidanceParameters::IsInitialized() const {
  return true;
}

void GuidanceParameters::InternalSwap(GuidanceParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.instances_.InternalSwap(&other->_impl_.instances_);
  swap(_impl_.guidance_preset_, other->_impl_.guidance_preset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GuidanceParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[13]);
}

// ===================================================================

class TransformType::_Internal {
 public:
};

TransformType::TransformType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.TransformType)
}
TransformType::TransformType(const TransformType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransformType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kDiffusion: {
      _this->_internal_set_diffusion(from._internal_diffusion());
      break;
    }
    case kUpscaler: {
      _this->_internal_set_upscaler(from._internal_upscaler());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.TransformType)
}

inline void TransformType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type();
}

TransformType::~TransformType() {
  // @@protoc_insertion_point(destructor:gooseai.TransformType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransformType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void TransformType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransformType::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:gooseai.TransformType)
  switch (type_case()) {
    case kDiffusion: {
      // No need to clear
      break;
    }
    case kUpscaler: {
      // No need to clear
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void TransformType::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.TransformType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransformType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gooseai.DiffusionSampler diffusion = 1 [json_name = "diffusion"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_diffusion(static_cast<::gooseai::DiffusionSampler>(val));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Upscaler upscaler = 2 [json_name = "upscaler"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_upscaler(static_cast<::gooseai::Upscaler>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransformType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.TransformType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gooseai.DiffusionSampler diffusion = 1 [json_name = "diffusion"];
  if (_internal_has_diffusion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_diffusion(), target);
  }

  // .gooseai.Upscaler upscaler = 2 [json_name = "upscaler"];
  if (_internal_has_upscaler()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_upscaler(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.TransformType)
  return target;
}

size_t TransformType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.TransformType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // .gooseai.DiffusionSampler diffusion = 1 [json_name = "diffusion"];
    case kDiffusion: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_diffusion());
      break;
    }
    // .gooseai.Upscaler upscaler = 2 [json_name = "upscaler"];
    case kUpscaler: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_upscaler());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransformType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransformType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransformType::GetClassData() const { return &_class_data_; }


void TransformType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransformType*>(&to_msg);
  auto& from = static_cast<const TransformType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.TransformType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kDiffusion: {
      _this->_internal_set_diffusion(from._internal_diffusion());
      break;
    }
    case kUpscaler: {
      _this->_internal_set_upscaler(from._internal_upscaler());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransformType::CopyFrom(const TransformType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.TransformType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransformType::IsInitialized() const {
  return true;
}

void TransformType::InternalSwap(TransformType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransformType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[14]);
}

// ===================================================================

class ImageParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageParameters>()._impl_._has_bits_);
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_steps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::gooseai::TransformType& transform(const ImageParameters* msg);
  static void set_has_transform(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_masked_area_init(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_weight_method(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_quantize(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::gooseai::TransformType&
ImageParameters::_Internal::transform(const ImageParameters* msg) {
  return *msg->_impl_.transform_;
}
ImageParameters::ImageParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ImageParameters)
}
ImageParameters::ImageParameters(const ImageParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seed_){from._impl_.seed_}
    , /*decltype(_impl_._seed_cached_byte_size_)*/{0}
    , decltype(_impl_.parameters_){from._impl_.parameters_}
    , decltype(_impl_.transform_){nullptr}
    , decltype(_impl_.height_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.samples_){}
    , decltype(_impl_.steps_){}
    , decltype(_impl_.masked_area_init_){}
    , decltype(_impl_.weight_method_){}
    , decltype(_impl_.quantize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_transform()) {
    _this->_impl_.transform_ = new ::gooseai::TransformType(*from._impl_.transform_);
  }
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quantize_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.quantize_));
  // @@protoc_insertion_point(copy_constructor:gooseai.ImageParameters)
}

inline void ImageParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seed_){arena}
    , /*decltype(_impl_._seed_cached_byte_size_)*/{0}
    , decltype(_impl_.parameters_){arena}
    , decltype(_impl_.transform_){nullptr}
    , decltype(_impl_.height_){uint64_t{0u}}
    , decltype(_impl_.width_){uint64_t{0u}}
    , decltype(_impl_.samples_){uint64_t{0u}}
    , decltype(_impl_.steps_){uint64_t{0u}}
    , decltype(_impl_.masked_area_init_){0}
    , decltype(_impl_.weight_method_){0}
    , decltype(_impl_.quantize_){false}
  };
}

ImageParameters::~ImageParameters() {
  // @@protoc_insertion_point(destructor:gooseai.ImageParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.seed_.~RepeatedField();
  _impl_.parameters_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.transform_;
}

void ImageParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ImageParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.seed_.Clear();
  _impl_.parameters_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.transform_ != nullptr);
    _impl_.transform_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quantize_) -
        reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.quantize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 height = 1 [json_name = "height"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 width = 2 [json_name = "width"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 seed = 3 [json_name = "seed"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_seed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_seed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 samples = 4 [json_name = "samples"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_samples(&has_bits);
          _impl_.samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steps = 5 [json_name = "steps"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_steps(&has_bits);
          _impl_.steps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.TransformType transform = 6 [json_name = "transform"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transform(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.StepParameter parameters = 7 [json_name = "parameters"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.MaskedAreaInit masked_area_init = 8 [json_name = "maskedAreaInit"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_masked_area_init(static_cast<::gooseai::MaskedAreaInit>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.WeightMethod weight_method = 9 [json_name = "weightMethod"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_weight_method(static_cast<::gooseai::WeightMethod>(val));
        } else
          goto handle_unusual;
        continue;
      // optional bool quantize = 10 [json_name = "quantize"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_quantize(&has_bits);
          _impl_.quantize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ImageParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 height = 1 [json_name = "height"];
  if (_internal_has_height()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_height(), target);
  }

  // optional uint64 width = 2 [json_name = "width"];
  if (_internal_has_width()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_width(), target);
  }

  // repeated uint32 seed = 3 [json_name = "seed"];
  {
    int byte_size = _impl_._seed_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_seed(), byte_size, target);
    }
  }

  // optional uint64 samples = 4 [json_name = "samples"];
  if (_internal_has_samples()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_samples(), target);
  }

  // optional uint64 steps = 5 [json_name = "steps"];
  if (_internal_has_steps()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_steps(), target);
  }

  // optional .gooseai.TransformType transform = 6 [json_name = "transform"];
  if (_internal_has_transform()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transform(this),
        _Internal::transform(this).GetCachedSize(), target, stream);
  }

  // repeated .gooseai.StepParameter parameters = 7 [json_name = "parameters"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .gooseai.MaskedAreaInit masked_area_init = 8 [json_name = "maskedAreaInit"];
  if (_internal_has_masked_area_init()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_masked_area_init(), target);
  }

  // optional .gooseai.WeightMethod weight_method = 9 [json_name = "weightMethod"];
  if (_internal_has_weight_method()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_weight_method(), target);
  }

  // optional bool quantize = 10 [json_name = "quantize"];
  if (_internal_has_quantize()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_quantize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ImageParameters)
  return target;
}

size_t ImageParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ImageParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 seed = 3 [json_name = "seed"];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.seed_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._seed_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .gooseai.StepParameter parameters = 7 [json_name = "parameters"];
  total_size += 1UL * this->_internal_parameters_size();
  for (const auto& msg : this->_impl_.parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .gooseai.TransformType transform = 6 [json_name = "transform"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transform_);
    }

    // optional uint64 height = 1 [json_name = "height"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_height());
    }

    // optional uint64 width = 2 [json_name = "width"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_width());
    }

    // optional uint64 samples = 4 [json_name = "samples"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_samples());
    }

    // optional uint64 steps = 5 [json_name = "steps"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steps());
    }

    // optional .gooseai.MaskedAreaInit masked_area_init = 8 [json_name = "maskedAreaInit"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_masked_area_init());
    }

    // optional .gooseai.WeightMethod weight_method = 9 [json_name = "weightMethod"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_weight_method());
    }

    // optional bool quantize = 10 [json_name = "quantize"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageParameters::GetClassData() const { return &_class_data_; }


void ImageParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageParameters*>(&to_msg);
  auto& from = static_cast<const ImageParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ImageParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.seed_.MergeFrom(from._impl_.seed_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_transform()->::gooseai::TransformType::MergeFrom(
          from._internal_transform());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.samples_ = from._impl_.samples_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.steps_ = from._impl_.steps_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.masked_area_init_ = from._impl_.masked_area_init_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.weight_method_ = from._impl_.weight_method_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.quantize_ = from._impl_.quantize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageParameters::CopyFrom(const ImageParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ImageParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageParameters::IsInitialized() const {
  return true;
}

void ImageParameters::InternalSwap(ImageParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.seed_.InternalSwap(&other->_impl_.seed_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageParameters, _impl_.quantize_)
      + sizeof(ImageParameters::_impl_.quantize_)
      - PROTOBUF_FIELD_OFFSET(ImageParameters, _impl_.transform_)>(
          reinterpret_cast<char*>(&_impl_.transform_),
          reinterpret_cast<char*>(&other->_impl_.transform_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[15]);
}

// ===================================================================

class ClassifierConcept::_Internal {
 public:
  using HasBits = decltype(std::declval<ClassifierConcept>()._impl_._has_bits_);
  static void set_has_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClassifierConcept::ClassifierConcept(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ClassifierConcept)
}
ClassifierConcept::ClassifierConcept(const ClassifierConcept& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClassifierConcept* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.concept_){}
    , decltype(_impl_.threshold_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.concept_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.concept_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_concept().empty()) {
    _this->_impl_.concept_.Set(from._internal_concept(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.threshold_ = from._impl_.threshold_;
  // @@protoc_insertion_point(copy_constructor:gooseai.ClassifierConcept)
}

inline void ClassifierConcept::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.concept_){}
    , decltype(_impl_.threshold_){0}
  };
  _impl_.concept_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.concept_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClassifierConcept::~ClassifierConcept() {
  // @@protoc_insertion_point(destructor:gooseai.ClassifierConcept)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClassifierConcept::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.concept_.Destroy();
}

void ClassifierConcept::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClassifierConcept::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ClassifierConcept)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.concept_.ClearToEmpty();
  _impl_.threshold_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClassifierConcept::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string concept = 1 [json_name = "concept"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_concept();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ClassifierConcept.concept"));
        } else
          goto handle_unusual;
        continue;
      // optional float threshold = 2 [json_name = "threshold"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_threshold(&has_bits);
          _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClassifierConcept::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ClassifierConcept)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string concept = 1 [json_name = "concept"];
  if (!this->_internal_concept().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_concept().data(), static_cast<int>(this->_internal_concept().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ClassifierConcept.concept");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_concept(), target);
  }

  // optional float threshold = 2 [json_name = "threshold"];
  if (_internal_has_threshold()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ClassifierConcept)
  return target;
}

size_t ClassifierConcept::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ClassifierConcept)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string concept = 1 [json_name = "concept"];
  if (!this->_internal_concept().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_concept());
  }

  // optional float threshold = 2 [json_name = "threshold"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClassifierConcept::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClassifierConcept::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClassifierConcept::GetClassData() const { return &_class_data_; }


void ClassifierConcept::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClassifierConcept*>(&to_msg);
  auto& from = static_cast<const ClassifierConcept&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ClassifierConcept)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_concept().empty()) {
    _this->_internal_set_concept(from._internal_concept());
  }
  if (from._internal_has_threshold()) {
    _this->_internal_set_threshold(from._internal_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClassifierConcept::CopyFrom(const ClassifierConcept& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ClassifierConcept)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClassifierConcept::IsInitialized() const {
  return true;
}

void ClassifierConcept::InternalSwap(ClassifierConcept* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.concept_, lhs_arena,
      &other->_impl_.concept_, rhs_arena
  );
  swap(_impl_.threshold_, other->_impl_.threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClassifierConcept::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[16]);
}

// ===================================================================

class ClassifierCategory::_Internal {
 public:
  using HasBits = decltype(std::declval<ClassifierCategory>()._impl_._has_bits_);
  static void set_has_adjustment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_classifier_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClassifierCategory::ClassifierCategory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ClassifierCategory)
}
ClassifierCategory::ClassifierCategory(const ClassifierCategory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClassifierCategory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.concepts_){from._impl_.concepts_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.adjustment_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.classifier_mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.adjustment_, &from._impl_.adjustment_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.classifier_mode_) -
    reinterpret_cast<char*>(&_impl_.adjustment_)) + sizeof(_impl_.classifier_mode_));
  // @@protoc_insertion_point(copy_constructor:gooseai.ClassifierCategory)
}

inline void ClassifierCategory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.concepts_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.adjustment_){0}
    , decltype(_impl_.action_){0}
    , decltype(_impl_.classifier_mode_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClassifierCategory::~ClassifierCategory() {
  // @@protoc_insertion_point(destructor:gooseai.ClassifierCategory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClassifierCategory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.concepts_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void ClassifierCategory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClassifierCategory::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ClassifierCategory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.concepts_.Clear();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.adjustment_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.classifier_mode_) -
        reinterpret_cast<char*>(&_impl_.adjustment_)) + sizeof(_impl_.classifier_mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClassifierCategory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [json_name = "name"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ClassifierCategory.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.ClassifierConcept concepts = 2 [json_name = "concepts"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_concepts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float adjustment = 3 [json_name = "adjustment"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_adjustment(&has_bits);
          _impl_.adjustment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.Action action = 4 [json_name = "action"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::gooseai::Action>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ClassifierMode classifier_mode = 5 [json_name = "classifierMode"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_classifier_mode(static_cast<::gooseai::ClassifierMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClassifierCategory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ClassifierCategory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ClassifierCategory.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .gooseai.ClassifierConcept concepts = 2 [json_name = "concepts"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_concepts_size()); i < n; i++) {
    const auto& repfield = this->_internal_concepts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float adjustment = 3 [json_name = "adjustment"];
  if (_internal_has_adjustment()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_adjustment(), target);
  }

  // optional .gooseai.Action action = 4 [json_name = "action"];
  if (_internal_has_action()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_action(), target);
  }

  // optional .gooseai.ClassifierMode classifier_mode = 5 [json_name = "classifierMode"];
  if (_internal_has_classifier_mode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_classifier_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ClassifierCategory)
  return target;
}

size_t ClassifierCategory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ClassifierCategory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.ClassifierConcept concepts = 2 [json_name = "concepts"];
  total_size += 1UL * this->_internal_concepts_size();
  for (const auto& msg : this->_impl_.concepts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float adjustment = 3 [json_name = "adjustment"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional .gooseai.Action action = 4 [json_name = "action"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
    }

    // optional .gooseai.ClassifierMode classifier_mode = 5 [json_name = "classifierMode"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_classifier_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClassifierCategory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClassifierCategory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClassifierCategory::GetClassData() const { return &_class_data_; }


void ClassifierCategory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClassifierCategory*>(&to_msg);
  auto& from = static_cast<const ClassifierCategory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ClassifierCategory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.concepts_.MergeFrom(from._impl_.concepts_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.adjustment_ = from._impl_.adjustment_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.action_ = from._impl_.action_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.classifier_mode_ = from._impl_.classifier_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClassifierCategory::CopyFrom(const ClassifierCategory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ClassifierCategory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClassifierCategory::IsInitialized() const {
  return true;
}

void ClassifierCategory::InternalSwap(ClassifierCategory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.concepts_.InternalSwap(&other->_impl_.concepts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClassifierCategory, _impl_.classifier_mode_)
      + sizeof(ClassifierCategory::_impl_.classifier_mode_)
      - PROTOBUF_FIELD_OFFSET(ClassifierCategory, _impl_.adjustment_)>(
          reinterpret_cast<char*>(&_impl_.adjustment_),
          reinterpret_cast<char*>(&other->_impl_.adjustment_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClassifierCategory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[17]);
}

// ===================================================================

class ClassifierParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ClassifierParameters>()._impl_._has_bits_);
  static void set_has_realized_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClassifierParameters::ClassifierParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ClassifierParameters)
}
ClassifierParameters::ClassifierParameters(const ClassifierParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClassifierParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.categories_){from._impl_.categories_}
    , decltype(_impl_.exceeds_){from._impl_.exceeds_}
    , decltype(_impl_.realized_action_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.realized_action_ = from._impl_.realized_action_;
  // @@protoc_insertion_point(copy_constructor:gooseai.ClassifierParameters)
}

inline void ClassifierParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.categories_){arena}
    , decltype(_impl_.exceeds_){arena}
    , decltype(_impl_.realized_action_){0}
  };
}

ClassifierParameters::~ClassifierParameters() {
  // @@protoc_insertion_point(destructor:gooseai.ClassifierParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClassifierParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.categories_.~RepeatedPtrField();
  _impl_.exceeds_.~RepeatedPtrField();
}

void ClassifierParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClassifierParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ClassifierParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.categories_.Clear();
  _impl_.exceeds_.Clear();
  _impl_.realized_action_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClassifierParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.ClassifierCategory categories = 1 [json_name = "categories"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_categories(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.ClassifierCategory exceeds = 2 [json_name = "exceeds"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exceeds(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.Action realized_action = 3 [json_name = "realizedAction"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_realized_action(static_cast<::gooseai::Action>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClassifierParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ClassifierParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.ClassifierCategory categories = 1 [json_name = "categories"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_categories_size()); i < n; i++) {
    const auto& repfield = this->_internal_categories(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gooseai.ClassifierCategory exceeds = 2 [json_name = "exceeds"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exceeds_size()); i < n; i++) {
    const auto& repfield = this->_internal_exceeds(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .gooseai.Action realized_action = 3 [json_name = "realizedAction"];
  if (_internal_has_realized_action()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_realized_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ClassifierParameters)
  return target;
}

size_t ClassifierParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ClassifierParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.ClassifierCategory categories = 1 [json_name = "categories"];
  total_size += 1UL * this->_internal_categories_size();
  for (const auto& msg : this->_impl_.categories_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gooseai.ClassifierCategory exceeds = 2 [json_name = "exceeds"];
  total_size += 1UL * this->_internal_exceeds_size();
  for (const auto& msg : this->_impl_.exceeds_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .gooseai.Action realized_action = 3 [json_name = "realizedAction"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_realized_action());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClassifierParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClassifierParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClassifierParameters::GetClassData() const { return &_class_data_; }


void ClassifierParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClassifierParameters*>(&to_msg);
  auto& from = static_cast<const ClassifierParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ClassifierParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.categories_.MergeFrom(from._impl_.categories_);
  _this->_impl_.exceeds_.MergeFrom(from._impl_.exceeds_);
  if (from._internal_has_realized_action()) {
    _this->_internal_set_realized_action(from._internal_realized_action());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClassifierParameters::CopyFrom(const ClassifierParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ClassifierParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClassifierParameters::IsInitialized() const {
  return true;
}

void ClassifierParameters::InternalSwap(ClassifierParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.categories_.InternalSwap(&other->_impl_.categories_);
  _impl_.exceeds_.InternalSwap(&other->_impl_.exceeds_);
  swap(_impl_.realized_action_, other->_impl_.realized_action_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClassifierParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[18]);
}

// ===================================================================

class AssetParameters::_Internal {
 public:
};

AssetParameters::AssetParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.AssetParameters)
}
AssetParameters::AssetParameters(const AssetParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AssetParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.project_id_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.use_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.project_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.project_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_project_id().empty()) {
    _this->_impl_.project_id_.Set(from._internal_project_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.action_, &from._impl_.action_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_) -
    reinterpret_cast<char*>(&_impl_.action_)) + sizeof(_impl_.use_));
  // @@protoc_insertion_point(copy_constructor:gooseai.AssetParameters)
}

inline void AssetParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.project_id_){}
    , decltype(_impl_.action_){0}
    , decltype(_impl_.use_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.project_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.project_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AssetParameters::~AssetParameters() {
  // @@protoc_insertion_point(destructor:gooseai.AssetParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AssetParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.project_id_.Destroy();
}

void AssetParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AssetParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.AssetParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.project_id_.ClearToEmpty();
  ::memset(&_impl_.action_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.use_) -
      reinterpret_cast<char*>(&_impl_.action_)) + sizeof(_impl_.use_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssetParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gooseai.AssetAction action = 1 [json_name = "action"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::gooseai::AssetAction>(val));
        } else
          goto handle_unusual;
        continue;
      // string project_id = 2 [json_name = "projectId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_project_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.AssetParameters.project_id"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.AssetUse use = 3 [json_name = "use"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::gooseai::AssetUse>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssetParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.AssetParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gooseai.AssetAction action = 1 [json_name = "action"];
  if (this->_internal_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  // string project_id = 2 [json_name = "projectId"];
  if (!this->_internal_project_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_project_id().data(), static_cast<int>(this->_internal_project_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.AssetParameters.project_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_project_id(), target);
  }

  // .gooseai.AssetUse use = 3 [json_name = "use"];
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_use(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.AssetParameters)
  return target;
}

size_t AssetParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.AssetParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string project_id = 2 [json_name = "projectId"];
  if (!this->_internal_project_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_project_id());
  }

  // .gooseai.AssetAction action = 1 [json_name = "action"];
  if (this->_internal_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  // .gooseai.AssetUse use = 3 [json_name = "use"];
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_use());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssetParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AssetParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssetParameters::GetClassData() const { return &_class_data_; }


void AssetParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AssetParameters*>(&to_msg);
  auto& from = static_cast<const AssetParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.AssetParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_project_id().empty()) {
    _this->_internal_set_project_id(from._internal_project_id());
  }
  if (from._internal_action() != 0) {
    _this->_internal_set_action(from._internal_action());
  }
  if (from._internal_use() != 0) {
    _this->_internal_set_use(from._internal_use());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssetParameters::CopyFrom(const AssetParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.AssetParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssetParameters::IsInitialized() const {
  return true;
}

void AssetParameters::InternalSwap(AssetParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.project_id_, lhs_arena,
      &other->_impl_.project_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AssetParameters, _impl_.use_)
      + sizeof(AssetParameters::_impl_.use_)
      - PROTOBUF_FIELD_OFFSET(AssetParameters, _impl_.action_)>(
          reinterpret_cast<char*>(&_impl_.action_),
          reinterpret_cast<char*>(&other->_impl_.action_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AssetParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[19]);
}

// ===================================================================

class AnswerMeta::_Internal {
 public:
  using HasBits = decltype(std::declval<AnswerMeta>()._impl_._has_bits_);
  static void set_has_gpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_engine_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

AnswerMeta::AnswerMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.AnswerMeta)
}
AnswerMeta::AnswerMeta(const AnswerMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnswerMeta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpu_id_){}
    , decltype(_impl_.cpu_id_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.engine_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gpu_id()) {
    _this->_impl_.gpu_id_.Set(from._internal_gpu_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_id()) {
    _this->_impl_.cpu_id_.Set(from._internal_cpu_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_node_id()) {
    _this->_impl_.node_id_.Set(from._internal_node_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.engine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_engine_id()) {
    _this->_impl_.engine_id_.Set(from._internal_engine_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.AnswerMeta)
}

inline void AnswerMeta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpu_id_){}
    , decltype(_impl_.cpu_id_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.engine_id_){}
  };
  _impl_.gpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cpu_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.engine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AnswerMeta::~AnswerMeta() {
  // @@protoc_insertion_point(destructor:gooseai.AnswerMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnswerMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gpu_id_.Destroy();
  _impl_.cpu_id_.Destroy();
  _impl_.node_id_.Destroy();
  _impl_.engine_id_.Destroy();
}

void AnswerMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnswerMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.AnswerMeta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gpu_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cpu_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.node_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.engine_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnswerMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string gpu_id = 1 [json_name = "gpuId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gpu_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.AnswerMeta.gpu_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string cpu_id = 2 [json_name = "cpuId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cpu_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.AnswerMeta.cpu_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string node_id = 3 [json_name = "nodeId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.AnswerMeta.node_id"));
        } else
          goto handle_unusual;
        continue;
      // optional string engine_id = 4 [json_name = "engineId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_engine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.AnswerMeta.engine_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnswerMeta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.AnswerMeta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string gpu_id = 1 [json_name = "gpuId"];
  if (_internal_has_gpu_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gpu_id().data(), static_cast<int>(this->_internal_gpu_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.AnswerMeta.gpu_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_gpu_id(), target);
  }

  // optional string cpu_id = 2 [json_name = "cpuId"];
  if (_internal_has_cpu_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cpu_id().data(), static_cast<int>(this->_internal_cpu_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.AnswerMeta.cpu_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cpu_id(), target);
  }

  // optional string node_id = 3 [json_name = "nodeId"];
  if (_internal_has_node_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_node_id().data(), static_cast<int>(this->_internal_node_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.AnswerMeta.node_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_node_id(), target);
  }

  // optional string engine_id = 4 [json_name = "engineId"];
  if (_internal_has_engine_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_engine_id().data(), static_cast<int>(this->_internal_engine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.AnswerMeta.engine_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_engine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.AnswerMeta)
  return target;
}

size_t AnswerMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.AnswerMeta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string gpu_id = 1 [json_name = "gpuId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gpu_id());
    }

    // optional string cpu_id = 2 [json_name = "cpuId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_id());
    }

    // optional string node_id = 3 [json_name = "nodeId"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_node_id());
    }

    // optional string engine_id = 4 [json_name = "engineId"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_engine_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnswerMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnswerMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnswerMeta::GetClassData() const { return &_class_data_; }


void AnswerMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnswerMeta*>(&to_msg);
  auto& from = static_cast<const AnswerMeta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.AnswerMeta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gpu_id(from._internal_gpu_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cpu_id(from._internal_cpu_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_node_id(from._internal_node_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_engine_id(from._internal_engine_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnswerMeta::CopyFrom(const AnswerMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.AnswerMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnswerMeta::IsInitialized() const {
  return true;
}

void AnswerMeta::InternalSwap(AnswerMeta* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gpu_id_, lhs_arena,
      &other->_impl_.gpu_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_id_, lhs_arena,
      &other->_impl_.cpu_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.node_id_, lhs_arena,
      &other->_impl_.node_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.engine_id_, lhs_arena,
      &other->_impl_.engine_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AnswerMeta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[20]);
}

// ===================================================================

class Answer::_Internal {
 public:
  using HasBits = decltype(std::declval<Answer>()._impl_._has_bits_);
  static const ::gooseai::AnswerMeta& meta(const Answer* msg);
  static void set_has_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::gooseai::AnswerMeta&
Answer::_Internal::meta(const Answer* msg) {
  return *msg->_impl_.meta_;
}
Answer::Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Answer)
}
Answer::Answer(const Answer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Answer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.artifacts_){from._impl_.artifacts_}
    , decltype(_impl_.answer_id_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.received_){}
    , decltype(_impl_.created_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.answer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.answer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_answer_id().empty()) {
    _this->_impl_.answer_id_.Set(from._internal_answer_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_request_id().empty()) {
    _this->_impl_.request_id_.Set(from._internal_request_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::gooseai::AnswerMeta(*from._impl_.meta_);
  }
  ::memcpy(&_impl_.received_, &from._impl_.received_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.created_) -
    reinterpret_cast<char*>(&_impl_.received_)) + sizeof(_impl_.created_));
  // @@protoc_insertion_point(copy_constructor:gooseai.Answer)
}

inline void Answer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.artifacts_){arena}
    , decltype(_impl_.answer_id_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.received_){uint64_t{0u}}
    , decltype(_impl_.created_){uint64_t{0u}}
  };
  _impl_.answer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.answer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Answer::~Answer() {
  // @@protoc_insertion_point(destructor:gooseai.Answer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Answer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.artifacts_.~RepeatedPtrField();
  _impl_.answer_id_.Destroy();
  _impl_.request_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void Answer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Answer::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Answer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.artifacts_.Clear();
  _impl_.answer_id_.ClearToEmpty();
  _impl_.request_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.meta_ != nullptr);
    _impl_.meta_->Clear();
  }
  ::memset(&_impl_.received_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.created_) -
      reinterpret_cast<char*>(&_impl_.received_)) + sizeof(_impl_.created_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Answer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string answer_id = 1 [json_name = "answerId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_answer_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Answer.answer_id"));
        } else
          goto handle_unusual;
        continue;
      // string request_id = 2 [json_name = "requestId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_request_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Answer.request_id"));
        } else
          goto handle_unusual;
        continue;
      // uint64 received = 3 [json_name = "received"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 created = 4 [json_name = "created"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.AnswerMeta meta = 6 [json_name = "meta"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.Artifact artifacts = 7 [json_name = "artifacts"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_artifacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Answer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Answer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string answer_id = 1 [json_name = "answerId"];
  if (!this->_internal_answer_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_answer_id().data(), static_cast<int>(this->_internal_answer_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Answer.answer_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_answer_id(), target);
  }

  // string request_id = 2 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_request_id().data(), static_cast<int>(this->_internal_request_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Answer.request_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_request_id(), target);
  }

  // uint64 received = 3 [json_name = "received"];
  if (this->_internal_received() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_received(), target);
  }

  // uint64 created = 4 [json_name = "created"];
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_created(), target);
  }

  // optional .gooseai.AnswerMeta meta = 6 [json_name = "meta"];
  if (_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  // repeated .gooseai.Artifact artifacts = 7 [json_name = "artifacts"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_artifacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_artifacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Answer)
  return target;
}

size_t Answer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Answer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.Artifact artifacts = 7 [json_name = "artifacts"];
  total_size += 1UL * this->_internal_artifacts_size();
  for (const auto& msg : this->_impl_.artifacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string answer_id = 1 [json_name = "answerId"];
  if (!this->_internal_answer_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_answer_id());
  }

  // string request_id = 2 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_request_id());
  }

  // optional .gooseai.AnswerMeta meta = 6 [json_name = "meta"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  // uint64 received = 3 [json_name = "received"];
  if (this->_internal_received() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_received());
  }

  // uint64 created = 4 [json_name = "created"];
  if (this->_internal_created() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_created());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Answer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Answer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Answer::GetClassData() const { return &_class_data_; }


void Answer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Answer*>(&to_msg);
  auto& from = static_cast<const Answer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Answer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.artifacts_.MergeFrom(from._impl_.artifacts_);
  if (!from._internal_answer_id().empty()) {
    _this->_internal_set_answer_id(from._internal_answer_id());
  }
  if (!from._internal_request_id().empty()) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::gooseai::AnswerMeta::MergeFrom(
        from._internal_meta());
  }
  if (from._internal_received() != 0) {
    _this->_internal_set_received(from._internal_received());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Answer::CopyFrom(const Answer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Answer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Answer::IsInitialized() const {
  return true;
}

void Answer::InternalSwap(Answer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.artifacts_.InternalSwap(&other->_impl_.artifacts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.answer_id_, lhs_arena,
      &other->_impl_.answer_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.request_id_, lhs_arena,
      &other->_impl_.request_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Answer, _impl_.created_)
      + sizeof(Answer::_impl_.created_)
      - PROTOBUF_FIELD_OFFSET(Answer, _impl_.meta_)>(
          reinterpret_cast<char*>(&_impl_.meta_),
          reinterpret_cast<char*>(&other->_impl_.meta_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Answer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[21]);
}

// ===================================================================

class Request::_Internal {
 public:
  using HasBits = decltype(std::declval<Request>()._impl_._has_bits_);
  static const ::gooseai::ImageParameters& image(const Request* msg);
  static const ::gooseai::ClassifierParameters& classifier(const Request* msg);
  static const ::gooseai::AssetParameters& asset(const Request* msg);
  static const ::gooseai::ConditionerParameters& conditioner(const Request* msg);
  static void set_has_conditioner(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::gooseai::ImageParameters&
Request::_Internal::image(const Request* msg) {
  return *msg->_impl_.params_.image_;
}
const ::gooseai::ClassifierParameters&
Request::_Internal::classifier(const Request* msg) {
  return *msg->_impl_.params_.classifier_;
}
const ::gooseai::AssetParameters&
Request::_Internal::asset(const Request* msg) {
  return *msg->_impl_.params_.asset_;
}
const ::gooseai::ConditionerParameters&
Request::_Internal::conditioner(const Request* msg) {
  return *msg->_impl_.conditioner_;
}
void Request::set_allocated_image(::gooseai::ImageParameters* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_params();
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    set_has_image();
    _impl_.params_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.image)
}
void Request::set_allocated_classifier(::gooseai::ClassifierParameters* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_params();
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(classifier);
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    set_has_classifier();
    _impl_.params_.classifier_ = classifier;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.classifier)
}
void Request::set_allocated_asset(::gooseai::AssetParameters* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_params();
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    set_has_asset();
    _impl_.params_.asset_ = asset;
  }
  // @@protoc_insertion_point(field_set_allocated:gooseai.Request.asset)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prompt_){from._impl_.prompt_}
    , decltype(_impl_.engine_id_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.conditioner_){nullptr}
    , decltype(_impl_.requested_type_){}
    , decltype(_impl_.params_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.engine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_engine_id().empty()) {
    _this->_impl_.engine_id_.Set(from._internal_engine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_request_id().empty()) {
    _this->_impl_.request_id_.Set(from._internal_request_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_conditioner()) {
    _this->_impl_.conditioner_ = new ::gooseai::ConditionerParameters(*from._impl_.conditioner_);
  }
  _this->_impl_.requested_type_ = from._impl_.requested_type_;
  clear_has_params();
  switch (from.params_case()) {
    case kImage: {
      _this->_internal_mutable_image()->::gooseai::ImageParameters::MergeFrom(
          from._internal_image());
      break;
    }
    case kClassifier: {
      _this->_internal_mutable_classifier()->::gooseai::ClassifierParameters::MergeFrom(
          from._internal_classifier());
      break;
    }
    case kAsset: {
      _this->_internal_mutable_asset()->::gooseai::AssetParameters::MergeFrom(
          from._internal_asset());
      break;
    }
    case PARAMS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prompt_){arena}
    , decltype(_impl_.engine_id_){}
    , decltype(_impl_.request_id_){}
    , decltype(_impl_.conditioner_){nullptr}
    , decltype(_impl_.requested_type_){0}
    , decltype(_impl_.params_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.engine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.engine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_params();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:gooseai.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prompt_.~RepeatedPtrField();
  _impl_.engine_id_.Destroy();
  _impl_.request_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.conditioner_;
  if (has_params()) {
    clear_params();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_params() {
// @@protoc_insertion_point(one_of_clear_start:gooseai.Request)
  switch (params_case()) {
    case kImage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.params_.image_;
      }
      break;
    }
    case kClassifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.params_.classifier_;
      }
      break;
    }
    case kAsset: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.params_.asset_;
      }
      break;
    }
    case PARAMS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PARAMS_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prompt_.Clear();
  _impl_.engine_id_.ClearToEmpty();
  _impl_.request_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.conditioner_ != nullptr);
    _impl_.conditioner_->Clear();
  }
  _impl_.requested_type_ = 0;
  clear_params();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string engine_id = 1 [json_name = "engineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_engine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Request.engine_id"));
        } else
          goto handle_unusual;
        continue;
      // string request_id = 2 [json_name = "requestId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_request_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Request.request_id"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ArtifactType requested_type = 3 [json_name = "requestedType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_requested_type(static_cast<::gooseai::ArtifactType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.Prompt prompt = 4 [json_name = "prompt"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prompt(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ImageParameters image = 5 [json_name = "image"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .gooseai.ConditionerParameters conditioner = 6 [json_name = "conditioner"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditioner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.ClassifierParameters classifier = 7 [json_name = "classifier"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gooseai.AssetParameters asset = 8 [json_name = "asset"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_asset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string engine_id = 1 [json_name = "engineId"];
  if (!this->_internal_engine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_engine_id().data(), static_cast<int>(this->_internal_engine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Request.engine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_engine_id(), target);
  }

  // string request_id = 2 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_request_id().data(), static_cast<int>(this->_internal_request_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Request.request_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_request_id(), target);
  }

  // .gooseai.ArtifactType requested_type = 3 [json_name = "requestedType"];
  if (this->_internal_requested_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_requested_type(), target);
  }

  // repeated .gooseai.Prompt prompt = 4 [json_name = "prompt"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prompt_size()); i < n; i++) {
    const auto& repfield = this->_internal_prompt(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gooseai.ImageParameters image = 5 [json_name = "image"];
  if (_internal_has_image()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  // optional .gooseai.ConditionerParameters conditioner = 6 [json_name = "conditioner"];
  if (_internal_has_conditioner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::conditioner(this),
        _Internal::conditioner(this).GetCachedSize(), target, stream);
  }

  // .gooseai.ClassifierParameters classifier = 7 [json_name = "classifier"];
  if (_internal_has_classifier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  // .gooseai.AssetParameters asset = 8 [json_name = "asset"];
  if (_internal_has_asset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::asset(this),
        _Internal::asset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.Prompt prompt = 4 [json_name = "prompt"];
  total_size += 1UL * this->_internal_prompt_size();
  for (const auto& msg : this->_impl_.prompt_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string engine_id = 1 [json_name = "engineId"];
  if (!this->_internal_engine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_engine_id());
  }

  // string request_id = 2 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_request_id());
  }

  // optional .gooseai.ConditionerParameters conditioner = 6 [json_name = "conditioner"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.conditioner_);
  }

  // .gooseai.ArtifactType requested_type = 3 [json_name = "requestedType"];
  if (this->_internal_requested_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_requested_type());
  }

  switch (params_case()) {
    // .gooseai.ImageParameters image = 5 [json_name = "image"];
    case kImage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.params_.image_);
      break;
    }
    // .gooseai.ClassifierParameters classifier = 7 [json_name = "classifier"];
    case kClassifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.params_.classifier_);
      break;
    }
    // .gooseai.AssetParameters asset = 8 [json_name = "asset"];
    case kAsset: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.params_.asset_);
      break;
    }
    case PARAMS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prompt_.MergeFrom(from._impl_.prompt_);
  if (!from._internal_engine_id().empty()) {
    _this->_internal_set_engine_id(from._internal_engine_id());
  }
  if (!from._internal_request_id().empty()) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_has_conditioner()) {
    _this->_internal_mutable_conditioner()->::gooseai::ConditionerParameters::MergeFrom(
        from._internal_conditioner());
  }
  if (from._internal_requested_type() != 0) {
    _this->_internal_set_requested_type(from._internal_requested_type());
  }
  switch (from.params_case()) {
    case kImage: {
      _this->_internal_mutable_image()->::gooseai::ImageParameters::MergeFrom(
          from._internal_image());
      break;
    }
    case kClassifier: {
      _this->_internal_mutable_classifier()->::gooseai::ClassifierParameters::MergeFrom(
          from._internal_classifier());
      break;
    }
    case kAsset: {
      _this->_internal_mutable_asset()->::gooseai::AssetParameters::MergeFrom(
          from._internal_asset());
      break;
    }
    case PARAMS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.prompt_.InternalSwap(&other->_impl_.prompt_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.engine_id_, lhs_arena,
      &other->_impl_.engine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.request_id_, lhs_arena,
      &other->_impl_.request_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Request, _impl_.requested_type_)
      + sizeof(Request::_impl_.requested_type_)
      - PROTOBUF_FIELD_OFFSET(Request, _impl_.conditioner_)>(
          reinterpret_cast<char*>(&_impl_.conditioner_),
          reinterpret_cast<char*>(&other->_impl_.conditioner_));
  swap(_impl_.params_, other->_impl_.params_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[22]);
}

// ===================================================================

class OnStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<OnStatus>()._impl_._has_bits_);
  static void set_has_target(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnStatus::OnStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.OnStatus)
}
OnStatus::OnStatus(const OnStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OnStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){from._impl_.reason_}
    , /*decltype(_impl_._reason_cached_byte_size_)*/{0}
    , decltype(_impl_.action_){from._impl_.action_}
    , /*decltype(_impl_._action_cached_byte_size_)*/{0}
    , decltype(_impl_.target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.target_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target()) {
    _this->_impl_.target_.Set(from._internal_target(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.OnStatus)
}

inline void OnStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){arena}
    , /*decltype(_impl_._reason_cached_byte_size_)*/{0}
    , decltype(_impl_.action_){arena}
    , /*decltype(_impl_._action_cached_byte_size_)*/{0}
    , decltype(_impl_.target_){}
  };
  _impl_.target_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnStatus::~OnStatus() {
  // @@protoc_insertion_point(destructor:gooseai.OnStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reason_.~RepeatedField();
  _impl_.action_.~RepeatedField();
  _impl_.target_.Destroy();
}

void OnStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OnStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.OnStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reason_.Clear();
  _impl_.action_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.target_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OnStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .gooseai.FinishReason reason = 1 [json_name = "reason"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_reason(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_reason(static_cast<::gooseai::FinishReason>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string target = 2 [json_name = "target"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_target();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.OnStatus.target"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.StageAction action = 3 [json_name = "action"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_action(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_action(static_cast<::gooseai::StageAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.OnStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .gooseai.FinishReason reason = 1 [json_name = "reason"];
  {
    int byte_size = _impl_._reason_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, _impl_.reason_, byte_size, target);
    }
  }

  // optional string target = 2 [json_name = "target"];
  if (_internal_has_target()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target().data(), static_cast<int>(this->_internal_target().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.OnStatus.target");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_target(), target);
  }

  // repeated .gooseai.StageAction action = 3 [json_name = "action"];
  {
    int byte_size = _impl_._action_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          3, _impl_.action_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.OnStatus)
  return target;
}

size_t OnStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.OnStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.FinishReason reason = 1 [json_name = "reason"];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_reason_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_reason(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._reason_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .gooseai.StageAction action = 3 [json_name = "action"];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_action_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_action(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._action_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional string target = 2 [json_name = "target"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OnStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OnStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OnStatus::GetClassData() const { return &_class_data_; }


void OnStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OnStatus*>(&to_msg);
  auto& from = static_cast<const OnStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.OnStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.reason_.MergeFrom(from._impl_.reason_);
  _this->_impl_.action_.MergeFrom(from._impl_.action_);
  if (from._internal_has_target()) {
    _this->_internal_set_target(from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OnStatus::CopyFrom(const OnStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.OnStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnStatus::IsInitialized() const {
  return true;
}

void OnStatus::InternalSwap(OnStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.reason_.InternalSwap(&other->_impl_.reason_);
  _impl_.action_.InternalSwap(&other->_impl_.action_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_, lhs_arena,
      &other->_impl_.target_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata OnStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[23]);
}

// ===================================================================

class Stage::_Internal {
 public:
  static const ::gooseai::Request& request(const Stage* msg);
};

const ::gooseai::Request&
Stage::_Internal::request(const Stage* msg) {
  return *msg->_impl_.request_;
}
Stage::Stage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.Stage)
}
Stage::Stage(const Stage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.on_status_){from._impl_.on_status_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.request_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_request()) {
    _this->_impl_.request_ = new ::gooseai::Request(*from._impl_.request_);
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.Stage)
}

inline void Stage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.on_status_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.request_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Stage::~Stage() {
  // @@protoc_insertion_point(destructor:gooseai.Stage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.on_status_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.request_;
}

void Stage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stage::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.Stage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.on_status_.Clear();
  _impl_.id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.Stage.id"));
        } else
          goto handle_unusual;
        continue;
      // .gooseai.Request request = 2 [json_name = "request"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.OnStatus on_status = 3 [json_name = "onStatus"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_on_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.Stage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.Stage.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // .gooseai.Request request = 2 [json_name = "request"];
  if (this->_internal_has_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::request(this),
        _Internal::request(this).GetCachedSize(), target, stream);
  }

  // repeated .gooseai.OnStatus on_status = 3 [json_name = "onStatus"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_on_status_size()); i < n; i++) {
    const auto& repfield = this->_internal_on_status(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.Stage)
  return target;
}

size_t Stage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.Stage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.OnStatus on_status = 3 [json_name = "onStatus"];
  total_size += 1UL * this->_internal_on_status_size();
  for (const auto& msg : this->_impl_.on_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // .gooseai.Request request = 2 [json_name = "request"];
  if (this->_internal_has_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.request_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stage::GetClassData() const { return &_class_data_; }


void Stage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stage*>(&to_msg);
  auto& from = static_cast<const Stage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.Stage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.on_status_.MergeFrom(from._impl_.on_status_);
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_has_request()) {
    _this->_internal_mutable_request()->::gooseai::Request::MergeFrom(
        from._internal_request());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stage::CopyFrom(const Stage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.Stage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stage::IsInitialized() const {
  return true;
}

void Stage::InternalSwap(Stage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.on_status_.InternalSwap(&other->_impl_.on_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  swap(_impl_.request_, other->_impl_.request_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Stage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[24]);
}

// ===================================================================

class ChainRequest::_Internal {
 public:
};

ChainRequest::ChainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gooseai.ChainRequest)
}
ChainRequest::ChainRequest(const ChainRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChainRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stage_){from._impl_.stage_}
    , decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_request_id().empty()) {
    _this->_impl_.request_id_.Set(from._internal_request_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:gooseai.ChainRequest)
}

inline void ChainRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stage_){arena}
    , decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChainRequest::~ChainRequest() {
  // @@protoc_insertion_point(destructor:gooseai.ChainRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChainRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stage_.~RepeatedPtrField();
  _impl_.request_id_.Destroy();
}

void ChainRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChainRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:gooseai.ChainRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stage_.Clear();
  _impl_.request_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChainRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string request_id = 1 [json_name = "requestId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_request_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gooseai.ChainRequest.request_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gooseai.Stage stage = 2 [json_name = "stage"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stage(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChainRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gooseai.ChainRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string request_id = 1 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_request_id().data(), static_cast<int>(this->_internal_request_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gooseai.ChainRequest.request_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_request_id(), target);
  }

  // repeated .gooseai.Stage stage = 2 [json_name = "stage"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stage_size()); i < n; i++) {
    const auto& repfield = this->_internal_stage(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gooseai.ChainRequest)
  return target;
}

size_t ChainRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gooseai.ChainRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gooseai.Stage stage = 2 [json_name = "stage"];
  total_size += 1UL * this->_internal_stage_size();
  for (const auto& msg : this->_impl_.stage_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string request_id = 1 [json_name = "requestId"];
  if (!this->_internal_request_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChainRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChainRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChainRequest::GetClassData() const { return &_class_data_; }


void ChainRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChainRequest*>(&to_msg);
  auto& from = static_cast<const ChainRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gooseai.ChainRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stage_.MergeFrom(from._impl_.stage_);
  if (!from._internal_request_id().empty()) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChainRequest::CopyFrom(const ChainRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gooseai.ChainRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChainRequest::IsInitialized() const {
  return true;
}

void ChainRequest::InternalSwap(ChainRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stage_.InternalSwap(&other->_impl_.stage_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.request_id_, lhs_arena,
      &other->_impl_.request_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ChainRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_generation_2eproto_getter, &descriptor_table_generation_2eproto_once,
      file_level_metadata_generation_2eproto[25]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace gooseai
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::gooseai::Token*
Arena::CreateMaybeMessage< ::gooseai::Token >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Token >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Tokens*
Arena::CreateMaybeMessage< ::gooseai::Tokens >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Tokens >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Artifact*
Arena::CreateMaybeMessage< ::gooseai::Artifact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Artifact >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::PromptParameters*
Arena::CreateMaybeMessage< ::gooseai::PromptParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::PromptParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Prompt*
Arena::CreateMaybeMessage< ::gooseai::Prompt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Prompt >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::SamplerParameters*
Arena::CreateMaybeMessage< ::gooseai::SamplerParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::SamplerParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ConditionerParameters*
Arena::CreateMaybeMessage< ::gooseai::ConditionerParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ConditionerParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ScheduleParameters*
Arena::CreateMaybeMessage< ::gooseai::ScheduleParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ScheduleParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::StepParameter*
Arena::CreateMaybeMessage< ::gooseai::StepParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::StepParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Model*
Arena::CreateMaybeMessage< ::gooseai::Model >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Model >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::CutoutParameters*
Arena::CreateMaybeMessage< ::gooseai::CutoutParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::CutoutParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::GuidanceScheduleParameters*
Arena::CreateMaybeMessage< ::gooseai::GuidanceScheduleParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::GuidanceScheduleParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::GuidanceInstanceParameters*
Arena::CreateMaybeMessage< ::gooseai::GuidanceInstanceParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::GuidanceInstanceParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::GuidanceParameters*
Arena::CreateMaybeMessage< ::gooseai::GuidanceParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::GuidanceParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::TransformType*
Arena::CreateMaybeMessage< ::gooseai::TransformType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::TransformType >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ImageParameters*
Arena::CreateMaybeMessage< ::gooseai::ImageParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ImageParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ClassifierConcept*
Arena::CreateMaybeMessage< ::gooseai::ClassifierConcept >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ClassifierConcept >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ClassifierCategory*
Arena::CreateMaybeMessage< ::gooseai::ClassifierCategory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ClassifierCategory >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ClassifierParameters*
Arena::CreateMaybeMessage< ::gooseai::ClassifierParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ClassifierParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::AssetParameters*
Arena::CreateMaybeMessage< ::gooseai::AssetParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::AssetParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::AnswerMeta*
Arena::CreateMaybeMessage< ::gooseai::AnswerMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::AnswerMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Answer*
Arena::CreateMaybeMessage< ::gooseai::Answer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Answer >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Request*
Arena::CreateMaybeMessage< ::gooseai::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::OnStatus*
Arena::CreateMaybeMessage< ::gooseai::OnStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::OnStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::Stage*
Arena::CreateMaybeMessage< ::gooseai::Stage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::Stage >(arena);
}
template<> PROTOBUF_NOINLINE ::gooseai::ChainRequest*
Arena::CreateMaybeMessage< ::gooseai::ChainRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gooseai::ChainRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
